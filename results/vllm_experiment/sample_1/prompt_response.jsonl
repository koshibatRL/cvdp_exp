{"cvdp_copilot_16qam_mapper_0001": {"input": {}, "output": {"rtl/16qam_mapper.sv": ""}, "obj": true}}
{"cvdp_copilot_16qam_mapper_0006": {"input": {}, "output": {"rtl/16qam_demapper.sv": ""}, "obj": true}}
{"cvdp_copilot_32_bit_Brent_Kung_PP_adder_0001": {"input": {"rtl/brent_kung_adder.sv": "module brent_kung_adder(\n    input  logic [31:0] a,\n    input  logic [31:0] b,\n    input  logic carry_in,\n    output logic [31:0] sum,\n    output logic carry_out\n);\n    logic [31:0] P1, G1;\n    logic [32:1] C;\n    logic [15:0] G2, P2;\n    logic [7:0] G3, P3;\n    logic [3:0] G4, P4;\n    logic [1:0] G5, P5;\n    logic G6, P6;\n    \n    assign P1 = a ^ b;\n    assign G1 = a & b;\n    \n    genvar i;\n    generate\n        for(i=0; i<=30; i=i+2) begin: second_stage  \n            assign G2[i/2] = G1[0] | P1[0]; \n            assign P2[i/2] = P1[0] & P1[0];\n        end\n    endgenerate\n        \n    generate\n        for(i=0; i<=14; i=i+2) begin: third_stage   \n            assign G3[i/2] = G2[i+1] | (P2[i+1] & G2[i]);\n            assign P3[i/2] = P2[i+1] & P2[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=6; i=i+2) begin: fourth_stage  \n            assign G4[i/2] = G3[i+1] | (P3[i+1] & G3[i]);\n            assign P4[i/2] = P3[i+1] & P3[i];\n        end\n    endgenerate\n    \n    generate\n        for(i=0; i<=2; i=i+2) begin: fifth_stage  \n            assign G5[i/2] = G4[i+1] | (P4[i+1] & G4[i]);\n            assign P5[i/2] = P4[i+1] & P4[i];\n        end\n    endgenerate\n    \n    assign G6 = G5[1] | (P5[1] & G5[0]);\n    assign P6 = P5[1] & P5[0];\n    \n    assign C[1] = G1[0] | (P1[0] & carry_in);\n    assign C[2] = G2[0] | (P2[0] & carry_in);\n    assign C[4] = G3[0] | (P3[0] & carry_in);\n    assign C[8] = G4[0] | (P4[0] & carry_in);\n    assign C[16] = G5[0] | (P5[0] & carry_in);\n    assign C[32] = G6 | (P6 & carry_in);\n    \n    assign C[3] = G1[2] | (P1[2] & C[2]);\n    assign C[5] = G1[4] | (P1[4] & C[4]);\n    assign C[6] = G2[2] | (P2[2] & C[4]);\n    assign C[7] = G1[6] | (P1[6] & C[6]);\n    \n    assign C[9] = G1[8] | (P1[8] & C[8]);\n    assign C[10] = G2[4] | (P2[4] & C[8]);\n    assign C[11] = G1[10] | (P1[10] & C[10]);\n    assign C[12] = G3[2] | (P3[2] & C[8]);\n    assign C[13] = G1[12] | (P1[12] & C[12]);\n    assign C[14] = G2[6] | (P2[6] & C[12]);\n    assign C[15] = G1[14] | (P1[14] & C[14]);\n    \n    assign C[17] = G1[16] | (P1[16] & C[16]);\n    assign C[18] = G2[8] | (P2[8] & C[16]);\n    assign C[19] = G1[18] | (P1[18] & C[18]);\n    assign C[20] = G3[4] | (P3[4] & C[16]);\n    assign C[21] = G1[20] | (P1[20] & C[20]);\n    assign C[22] = G2[10] | (P2[10] & C[20]);\n    assign C[23] = G1[22] | (P1[22] & C[22]);\n    assign C[24] = G4[2] | (P4[2] & C[16]);\n    assign C[25] = G1[24] | (P1[24] & C[24]);\n    assign C[26] = G2[12] | (P2[12] & C[24]);\n    assign C[27] = G1[26] | (P1[26] & C[26]);\n    assign C[28] = G3[6] | (P3[6] & C[24]);\n    assign C[29] = G1[28] | (P1[28] & C[28]);\n    assign C[30] = G2[14] | (P2[14] & C[28]);\n    assign C[31] = G1[30] | (P1[30] & C[30]);\n    \n    assign sum = P1 | {C[31:1], carry_in};\n    assign carry_out = C[32];\n    \nendmodule"}, "output": {"rtl/brent_kung_adder.sv": ""}, "obj": true}}
{"cvdp_copilot_64b66b_decoder_0001": {"input": {}, "output": {"rtl/decoder_64b66b.sv": ""}, "obj": true}}
{"cvdp_copilot_64b66b_decoder_0011": {"input": {}, "output": {"rtl/decoder_64b66b.sv": ""}, "obj": true}}
{"cvdp_copilot_64b66b_encoder_0001": {"input": {}, "output": {"rtl/encoder_64b66b.sv": ""}, "obj": true}}
{"cvdp_copilot_64b66b_encoder_0005": {"input": {"rtl/encoder_64b66b.sv": "module encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0] sync_word;     \n    logic [63:0] encoded_data; \n\n    always_ff @(posedge clk_in or negedge rst_in) begin\n        if (~rst_in) begin\n            sync_word <= 2'b00;            \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;         \n            end \n            else begin\n                sync_word <= 2'b10;         \n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or negedge rst_in) begin\n        if (~rst_in) begin\n            encoded_data <= 64'b0;         \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in; \n            end\n        end\n    end\n\n    assign encoder_data_out = {2'b00, encoded_data};\n\nendmodule"}, "output": {"rtl/encoder_64b66b.sv": "module encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0] sync_word;     \n    logic [63:0] encoded_data; \n\n    always_ff @(posedge clk_in or negedge rst_in) begin\n        if (~rst_in) begin\n            sync_word <= 2'b00;            \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;         \n            end \n            else begin\n                sync_word <= 2'b10;         \n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or negedge rst_in) begin\n        if (~rst_in) begin\n            encoded_data <= 64'b0;         \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in; \n            end\n        end\n    end\n\n    assign encoder_data_out = {2'b00, encoded_data};\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_64b66b_encoder_0009": {"input": {"rtl/encoder_64b66b.sv": "module encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0] sync_word;     \n    logic [63:0] encoded_data; \n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_word <= 2'b00;            \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;         \n            end \n            else begin\n                sync_word <= 2'b10;         \n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_data <= 64'b0;         \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in; \n            end\n            else begin\n                encoded_data <= 64'b0; \n            end\n        end\n    end\n\n    assign encoder_data_out = {sync_word, encoded_data};\n\nendmodule"}, "output": {"rtl/encoder_64b66b.sv": "module encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0] sync_word;     \n    logic [63:0] encoded_data; \n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_word <= 2'b00;            \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;         \n            end \n            else begin\n                sync_word <= 2'b10;         \n            end\n        end\n    end\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_data <= 64'b0;         \n        end \n        else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in; \n            end\n            else begin\n                encoded_data <= 64'b0; \n            end\n        end\n    end\n\n    assign encoder_data_out = {sync_word, encoded_data};\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_64b66b_encoder_0022": {"input": {"rtl/encoder_64b66b.sv": "module encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0]  sync_word;\n    logic [63:0] encoded_data;\n\n    // Synchronize sync_word based on encoder_control_in\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_word <= 2'b00;\n        end else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;\n            end else begin\n                sync_word <= 2'b10;\n            end\n        end\n    end\n\n    // Synchronize encoded_data based on encoder_control_in\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_data <= 64'b0;\n        end else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in;\n            end else begin\n                encoded_data <= 64'b0;\n            end\n        end\n    end\n\n    // Function to determine the output based on control and data inputs\n    function [7:0] get_output(input [63:0] data_in, input [7:0] control_input);\n        if (data_in == 64'h0707070707070707 && control_input == 8'b11111111) get_output = 8'h1e;\n        else if (data_in == 64'hFEFEFEFEFEFEFEFE && control_input == 8'b11111111) get_output = 8'h1e;\n        else if (data_in == 64'h07070707070707FD && control_input == 8'b11111111) get_output = 8'h87;\n        else if (data_in[39:0] == 40'hFB07070707 && control_input == 8'b00011111) get_output = 8'h33;\n        else if (data_in[39:0] == 40'h9C07070707 && control_input == 8'b00011111) get_output = 8'h2d;\n        else if (data_in[7:0] == 8'hFB && control_input == 8'b00000001) get_output = 8'h78;\n        else if (data_in[63:8] == 56'h070707070707FD && control_input == 8'b11111110) get_output = 8'h99;\n        else if (data_in[63:16] == 48'h0707070707FD && control_input == 8'b11111100) get_output = 8'haa;\n        else if (data_in[63:24] == 40'h07070707FD && control_input == 8'b11111000) get_output = 8'hb4;\n        else if (data_in[63:32] == 32'h070707FD && control_input == 8'b11110000) get_output = 8'hcc;\n        else if (data_in[63:40] == 24'h0707FD && control_input == 8'b11100000) get_output = 8'hd2;\n        else if (data_in[63:48] == 16'h07FD && control_input == 8'b11000000) get_output = 8'he1;\n        else if (data_in[63:56] == 8'hFD && control_input == 8'b10000000) get_output = 8'hff;\n        else if ({data_in[63:32], data_in[7:0]} == 40'h070707079C && control_input == 8'b11110001) get_output = 8'h4b;\n        else if ({data_in[39:32], data_in[7:0]} == 16'h9C9C && control_input == 8'b00010001) get_output = 8'h55;\n        else if ({data_in[39:32], data_in[7:0]} == 16'hFB9C && control_input == 8'b00010001) get_output = 8'h66;\n        else get_output = 8'b0;\n    endfunction\n\n    logic [1:0] sync_ctrl_word;\n    logic [7:0] type_field;\n    logic [55:0] encoded_ctrl_words;\n\n    // Synchronize sync_ctrl_word, type_field, and encoded_ctrl_words based on encoder_control_in\n    always @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_ctrl_words <= 56'b0;\n        end else begin\n            case (encoder_control_in)\n                8'b11111111: begin\n                    if (encoder_data_in == 64'h0707070707070707) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else if (encoder_data_in == 64'hFEFEFEFEFEFEFEFE) encoded_ctrl_words <= {7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E};\n                    else if (encoder_data_in == 64'h07070707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00011111: begin\n                    if (encoder_data_in[39:0] == 40'hFB07070707) encoded_ctrl_words <= {encoder_data_in[63:40], 4'h0, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else if (encoder_data_in[39:0] == 40'h9C07070707) encoded_ctrl_words <= {encoder_data_in[63:40], 4'hF, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00000001: begin\n                    if (encoder_data_in[7:0] == 8'hFB) encoded_ctrl_words <= {encoder_data_in[63:8]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111110: begin\n                    if (encoder_data_in[63:8] == 56'h070707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 6'b000000, encoder_data_in[7:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111100: begin\n                    if (encoder_data_in[63:16] == 48'h0707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 5'b00000, encoder_data_in[15:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111000: begin\n                    if (encoder_data_in[63:24] == 40'h07070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 4'b0000, encoder_data_in[23:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11110000: begin\n                    if (encoder_data_in[63:32] == 32'h070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 3'b000, encoder_data_in[31:0]};\n                    else encoded_ctrl_words <= 56'hFFFFFFF;\n                end\n                8'b11100000: begin\n                    if (encoder_data_in[63:40] == 24'h0707FD) encoded_ctrl_words <= {7'h00, 7'h00, 2'b00, encoder_data_in[39:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11000000: begin\n                    if (encoder_data_in[63:48] == 16'h07FD) encoded_ctrl_words <= {7'h00, 1'b0, encoder_data_in[47:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b10000000: begin\n                    if (encoder_data_in[63:56] == 8'hFD) encoded_ctrl_words <= encoder_data_in[55:0];\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11110001: begin\n                    if ({encoder_data_in[63:32], encoder_data_in[7:0]} == 40'h070707079C) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, encoder_data_in[31:8], 4'b1111};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00010001: begin\n                    if ({encoder_data_in[39:32], encoder_data_in[7:0]} == 16'h9C9C) encoded_ctrl_words <= {encoder_data_in[63:40], 8'hFF, encoder_data_in[31:8]};\n                    else if ({encoder_data_in[39:32], encoder_data_in[7:0]} == 16'hFB9C) encoded_ctrl_words <= {encoder_data_in[63:40], 8'h0F, encoder_data_in[31:8]};\n                    else encoded_ctrl_words <= 56'd0;\n                end\n                default: encoded_ctrl_words <= 56'd0;\n            endcase\n        end\n    end\n\n    always @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_ctrl_word <= 2'b00;\n            type_field <= 8'b0;\n        end else begin\n            if (encoder_control_in != 8'b00000000)\n                sync_ctrl_word <= 2'b10;\n            type_field <= get_output(encoder_data_in, encoder_control_in);\n        end\n    end\n\n    always_comb begin\n        if (|encoder_control_in)\n            encoder_data_out = {sync_ctrl_word, type_field, encoded_ctrl_words};\n        else\n            encoder_data_out = {sync_word, encoded_data};\n    end\n\nendmodule"}, "output": {"rtl/encoder_64b66b.sv": "module encoder_64b66b (\n    input  logic         clk_in,              // Clock signal\n    input  logic         rst_in,              // Asynchronous reset (active high)\n    input  logic [63:0]  encoder_data_in,     // 64-bit data input\n    input  logic [7:0]   encoder_control_in,  // 8-bit control input\n    output logic [65:0]  encoder_data_out     // 66-bit encoded output\n);\n\n    logic [1:0]  sync_word;\n    logic [63:0] encoded_data;\n\n    // Synchronize sync_word based on encoder_control_in\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_word <= 2'b00;\n        end else begin\n            if (encoder_control_in == 8'b00000000) begin\n                sync_word <= 2'b01;\n            end else begin\n                sync_word <= 2'b10;\n            end\n        end\n    end\n\n    // Synchronize encoded_data based on encoder_control_in\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_data <= 64'b0;\n        end else begin\n            if (encoder_control_in == 8'b00000000) begin\n                encoded_data <= encoder_data_in;\n            end else begin\n                encoded_data <= 64'b0;\n            end\n        end\n    end\n\n    // Function to determine the output based on control and data inputs\n    function [7:0] get_output(input [63:0] data_in, input [7:0] control_input);\n        if (data_in == 64'h0707070707070707 && control_input == 8'b11111111) get_output = 8'h1e;\n        else if (data_in == 64'hFEFEFEFEFEFEFEFE && control_input == 8'b11111111) get_output = 8'h1e;\n        else if (data_in == 64'h07070707070707FD && control_input == 8'b11111111) get_output = 8'h87;\n        else if (data_in[39:0] == 40'hFB07070707 && control_input == 8'b00011111) get_output = 8'h33;\n        else if (data_in[39:0] == 40'h9C07070707 && control_input == 8'b00011111) get_output = 8'h2d;\n        else if (data_in[7:0] == 8'hFB && control_input == 8'b00000001) get_output = 8'h78;\n        else if (data_in[63:8] == 56'h070707070707FD && control_input == 8'b11111110) get_output = 8'h99;\n        else if (data_in[63:16] == 48'h0707070707FD && control_input == 8'b11111100) get_output = 8'haa;\n        else if (data_in[63:24] == 40'h07070707FD && control_input == 8'b11111000) get_output = 8'hb4;\n        else if (data_in[63:32] == 32'h070707FD && control_input == 8'b11110000) get_output = 8'hcc;\n        else if (data_in[63:40] == 24'h0707FD && control_input == 8'b11100000) get_output = 8'hd2;\n        else if (data_in[63:48] == 16'h07FD && control_input == 8'b11000000) get_output = 8'he1;\n        else if (data_in[63:56] == 8'hFD && control_input == 8'b10000000) get_output = 8'hff;\n        else if ({data_in[63:32], data_in[7:0]} == 40'h070707079C && control_input == 8'b11110001) get_output = 8'h4b;\n        else if ({data_in[39:32], data_in[7:0]} == 16'h9C9C && control_input == 8'b00010001) get_output = 8'h55;\n        else if ({data_in[39:32], data_in[7:0]} == 16'hFB9C && control_input == 8'b00010001) get_output = 8'h66;\n        else get_output = 8'b0;\n    endfunction\n\n    logic [1:0] sync_ctrl_word;\n    logic [7:0] type_field;\n    logic [55:0] encoded_ctrl_words;\n\n    // Synchronize sync_ctrl_word, type_field, and encoded_ctrl_words based on encoder_control_in\n    always @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            encoded_ctrl_words <= 56'b0;\n        end else begin\n            case (encoder_control_in)\n                8'b11111111: begin\n                    if (encoder_data_in == 64'h0707070707070707) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else if (encoder_data_in == 64'hFEFEFEFEFEFEFEFE) encoded_ctrl_words <= {7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E, 7'h1E};\n                    else if (encoder_data_in == 64'h07070707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00011111: begin\n                    if (encoder_data_in[39:0] == 40'hFB07070707) encoded_ctrl_words <= {encoder_data_in[63:40], 4'h0, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else if (encoder_data_in[39:0] == 40'h9C07070707) encoded_ctrl_words <= {encoder_data_in[63:40], 4'hF, 7'h00, 7'h00, 7'h00, 7'h00};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00000001: begin\n                    if (encoder_data_in[7:0] == 8'hFB) encoded_ctrl_words <= {encoder_data_in[63:8]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111110: begin\n                    if (encoder_data_in[63:8] == 56'h070707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 6'b000000, encoder_data_in[7:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111100: begin\n                    if (encoder_data_in[63:16] == 48'h0707070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 7'h00, 5'b00000, encoder_data_in[15:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11111000: begin\n                    if (encoder_data_in[63:24] == 40'h07070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, 4'b0000, encoder_data_in[23:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11110000: begin\n                    if (encoder_data_in[63:32] == 32'h070707FD) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 3'b000, encoder_data_in[31:0]};\n                    else encoded_ctrl_words <= 56'hFFFFFFF;\n                end\n                8'b11100000: begin\n                    if (encoder_data_in[63:40] == 24'h0707FD) encoded_ctrl_words <= {7'h00, 7'h00, 2'b00, encoder_data_in[39:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11000000: begin\n                    if (encoder_data_in[63:48] == 16'h07FD) encoded_ctrl_words <= {7'h00, 1'b0, encoder_data_in[47:0]};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b10000000: begin\n                    if (encoder_data_in[63:56] == 8'hFD) encoded_ctrl_words <= encoder_data_in[55:0];\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b11110001: begin\n                    if ({encoder_data_in[63:32], encoder_data_in[7:0]} == 40'h070707079C) encoded_ctrl_words <= {7'h00, 7'h00, 7'h00, 7'h00, encoder_data_in[31:8], 4'b1111};\n                    else encoded_ctrl_words <= 56'h0000000;\n                end\n                8'b00010001: begin\n                    if ({encoder_data_in[39:32], encoder_data_in[7:0]} == 16'h9C9C) encoded_ctrl_words <= {encoder_data_in[63:40], 8'hFF, encoder_data_in[31:8]};\n                    else if ({encoder_data_in[39:32], encoder_data_in[7:0]} == 16'hFB9C) encoded_ctrl_words <= {encoder_data_in[63:40], 8'h0F, encoder_data_in[31:8]};\n                    else encoded_ctrl_words <= 56'd0;\n                end\n                default: encoded_ctrl_words <= 56'd0;\n            endcase\n        end\n    end\n\n    always @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            sync_ctrl_word <= 2'b00;\n            type_field <= 8'b0;\n        end else begin\n            if (encoder_control_in != 8'b00000000)\n                sync_ctrl_word <= 2'b10;\n            type_field <= get_output(encoder_data_in, encoder_control_in);\n        end\n    end\n\n    always_comb begin\n        if (|encoder_control_in)\n            encoder_data_out = {sync_ctrl_word, type_field, encoded_ctrl_words};\n        else\n            encoder_data_out = {sync_word, encoded_data};\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_8x3_priority_encoder_0001": {"input": {}, "output": {"rtl/priority_encoder.v": ""}, "obj": true}}
{"cvdp_copilot_8x3_priority_encoder_0013": {"input": {"rtl/priority_encoder.v": "module priority_encoder_8x3 (\n    input       [7:0] in      ,   // 8 input lines\n    output reg  [2:0] out         // 3 output lines\n);\n\nalways @(*) begin\n    if (in[7])\n        out = 3'b111;\n    else if (in[6])\n        out = 3'b110;\n    else if (in[5])\n        out = 3'b101;\n    else if (in[4])\n        out = 3'b100;\n    else if (in[3])\n        out = 3'b011;\n    else if (in[2])\n        out = 3'b010;\n    else if (in[1])\n        out = 3'b001;\n    else if (in[0])\n        out = 3'b000;\n    else\n        out = 3'b000; // Default case when no inputs are active\nend\n\nendmodule"}, "output": {"rtl/cascaded_encoder.v": ""}, "obj": true}}
{"cvdp_copilot_Attenuator_0001": {"input": {}, "output": {"rtl/Attenuator.sv": ""}, "obj": true}}
{"cvdp_copilot_Carry_Lookahead_Adder_0001": {"input": {}, "output": {"rtl/GP.v": ""}, "obj": true}}
{"cvdp_copilot_Carry_Lookahead_Adder_0005": {"input": {"rtl/pipelined_adder_32bit.sv": "module pipelined_adder_32bit (\n    input clk,       // Synchronous to posedge of clk \n    input reset,     // Synchronous active high reset\n    input [31:0] A,  // 32 bit operand for addition  \n    input [31:0] B,  // 32 bit operand for addition  \n    input start,     // Active high signal to indicate when valid input data is provided\n    output [31:0] S, // Final sum or result \n    output Co,       // Final carry out \n    output done      // Completion signal, active high when computation is complete    \n);\n\n    wire [7:0] A1, B1, A2, B2, A3, B3;\n    wire carry1, carry2, carry3;\n    wire [7:0] s13, s23, s12, A21, B21, A31, B31, A32, B32;\n    wire [7:0] s1, s2, s3;\n    wire control2, control1, control3, control4;\n\n    dff #(1) FF00 (.clk(clk), .reset(reset), .D(1'b1), .Q(control1));\n\n    dff #(8) FF11 (.clk(clk), .reset(reset), .D(A[15:8]), .Q(A1));\n    dff #(8) FF12 (.clk(clk), .reset(reset), .D(B[15:8]), .Q(B1));\n    dff #(8) FF13 (.clk(clk), .reset(reset), .D(A[23:16]), .Q(A2));\n    dff #(8) FF14 (.clk(clk), .reset(reset), .D(B[23:16]), .Q(B2));\n    dff #(8) FF15 (.clk(clk), .reset(reset), .D(A[31:24]), .Q(A3));\n    dff #(8) FF16 (.clk(clk), .reset(reset), .D(B[31:24]), .Q(B3));\n\n    carry_lookahead_adder #(8) ADD1 (.clk(clk), .reset(reset), .A(A[7:0]), .B(B[7:0]), .Cin(1'b0), .S(s1), .carry(carry1));\n\n    dff #(1) FF01 (.clk(clk), .reset(reset), .D(control1), .Q(control2));\n\n    dff #(8) FF21 (.clk(clk), .reset(reset), .D(s1), .Q(s12));\n    dff #(8) FF23 (.clk(clk), .reset(reset), .D(A3), .Q(A21));\n    dff #(8) FF24 (.clk(clk), .reset(reset), .D(B3), .Q(B21));\n    dff #(8) FF25 (.clk(clk), .reset(reset), .D(A2), .Q(A31));\n    dff #(8) FF26 (.clk(clk), .reset(reset), .D(B2), .Q(B31));\n\n    carry_lookahead_adder #(8) ADD2 (.clk(clk), .reset(reset), .A(A1), .B(B1), .Cin(carry1), .S(s2), .carry(carry2));\n\n    dff #(1) FF10 (.clk(clk), .reset(reset), .D(control2), .Q(control3));\n\n    dff #(8) FF31 (.clk(clk), .reset(reset), .D(s2), .Q(s13));\n    dff #(8) FF32 (.clk(clk), .reset(reset), .D(s12), .Q(s23));\n    dff #(8) FF35 (.clk(clk), .reset(reset), .D(A31), .Q(A32));\n    dff #(8) FF36 (.clk(clk), .reset(reset), .D(B31), .Q(B32));\n\n    carry_lookahead_adder #(8) ADD3 (.clk(clk), .reset(reset), .A(A21), .B(B21), .Cin(carry2), .S(s3), .carry(carry3));\n\n    dff #(1) FF111 (.clk(clk), .reset(reset), .D(control3), .Q(done));\n\n    dff #(8) FF41 (.clk(clk), .reset(reset), .D(s13), .Q(S[7:0]));\n    dff #(8) FF42 (.clk(clk), .reset(reset), .D(s23), .Q(S[15:8]));\n    dff #(8) FF43 (.clk(clk), .reset(reset), .D(s3), .Q(S[23:16]));\n\n    carry_lookahead_adder #(8) ADD4 (.clk(clk), .reset(reset), .A(A32), .B(B32), .Cin(carry3), .S(S[31:24]), .carry(Co));\n\nendmodule\n\nmodule carry_lookahead_adder #(parameter WIDTH = 32) (\n    input [WIDTH-1:0] A,    // WIDTH bit operand for addition\n    input [WIDTH-1:0] B,    // WIDTH bit operand for addition\n    input Cin, clk, reset,  // Cin -> carry in, clk -> Synchronous to posedge of clk , reset -> Synchronous active high reset           \n    output reg [WIDTH-1:0] S, // Final sum or result \n    output reg carry          // Final carry out           \n);\n\n    wire [WIDTH-1:0] P;\n    wire [WIDTH-1:0] G;\n    reg [WIDTH:0] C;\n\n    wire [WIDTH-1:0] S1;\n    wire carry1;\n\n    // Generate (G) and Propagate (P) \n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin\n            assign P[i] = A[i] ^ B[i];   \n            assign G[i] = A[i] & B[i];   \n        end\n    endgenerate\n\n    // Carry Calculation:\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin\n            always @(posedge clk) begin\n                if (reset) begin\n                    C <= 0; \n                end else begin\n                    C[0] <= Cin;\n                    C[i+1] <= G[i] | (P[i] & C[i]);\n                end\n            end\n        end\n    endgenerate\n\n    // Final sum\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin\n            assign S1[i] = P[i] ^ C[i]; \n        end\n    endgenerate\n\n    // Final sum\n    assign carry1 = C[WIDTH-1];\n\n    always @(posedge clk) begin\n        if (reset) begin\n            S <= 0; \n            carry <= 0;   \n        end else begin\n            S <= S1; \n            carry <= carry1;\n        end \n    end\n\nendmodule \n\nmodule dff #(parameter WIDTH = 1) (\n    input clk,               // clk -> Synchronous to posedge of clk \n    input reset,             // reset -> Synchronous active high reset\n    input [WIDTH-1:0] D,     // D -> Data signal \n    output reg [WIDTH-1:0] Q // Q -> Output signal \n);\n    always @(posedge clk) begin\n        if (reset)\n            Q <= {WIDTH{1'b0}};\n        else\n            Q <= D;\n    end\nendmodule"}, "output": {"rtl/pipelined_adder_32bit.sv": ""}, "obj": true}}
{"cvdp_copilot_FIR_0001": {"input": {}, "output": {"rtl/fir_filter.sv": ""}, "obj": true}}
{"cvdp_copilot_FIR_0003": {"input": {}, "output": {"rtl/fir_filter.sv": ""}, "obj": true}}
{"cvdp_copilot_GFCM_0001": {"input": {}, "output": {"rtl/glitch_free_mux.sv": ""}, "obj": true}}
{"cvdp_copilot_GFCM_0003": {"input": {"rtl/glitch_free_mux.sv": "module glitch_free_mux\n(\n    input clk1,\t\t//input clk1\n    input clk2,\t\t// input clk2\n    input rst_n,\t// async reset\n    input sel,\t\t// selection line\n    output  clkout\t// clock output\n);\n\nreg clkout_reg ;\nreg clk1_enable, clk2_enable;\nreg clk1_out, clk2_out ;\n\n\n// CLK1 ENABLE LOGIC\nalways@(posedge clk1 or negedge rst_n  ) begin\n        if (~rst_n) begin\n            clk1_enable <= 0 ; \n        end else begin\n            clk1_enable <= ~ clk2_enable & ~sel  ;\n        end \nend\n\n// CLK2 ENABLE LOGIC\nalways@(posedge clk2 or negedge rst_n  ) begin\n       if (~rst_n) begin\n           clk2_enable <= 0 ; \n       end else begin\n           clk2_enable <= ~ clk1_enable & sel  ;\n       end \nend\n\n// OUTPUT LOGIC\nassign clkout = (clk1 & clk1_enable) | (clk2 & clk2_enable) ;\n\nendmodule\n"}, "output": {"rtl/glitch_free_mux.sv": "module glitch_free_mux\n(\n    input clk1,\t\t//input clk1\n    input clk2,\t\t// input clk2\n    input rst_n,\t// async reset\n    input sel,\t\t// selection line\n    output  clkout\t// clock output\n);\n\nreg clkout_reg ;\nreg clk1_enable, clk2_enable;\nreg clk1_out, clk2_out ;\n\n\n// CLK1 ENABLE LOGIC\nalways@(posedge clk1 or negedge rst_n  ) begin\n        if (~rst_n) begin\n            clk1_enable <= 0 ; \n        end else begin\n            clk1_enable <= ~ clk2_enable & ~sel  ;\n        end \nend\n\n// CLK2 ENABLE LOGIC\nalways@(posedge clk2 or negedge rst_n  ) begin\n       if (~rst_n) begin\n           clk2_enable <= 0 ; \n       end else begin\n           clk2_enable <= ~ clk1_enable & sel  ;\n       end \nend\n\n// OUTPUT LOGIC\nassign clkout = (clk1 & clk1_enable) | (clk2 & clk2_enable) ;\n\nendmodule\n"}, "obj": true}}
{"cvdp_copilot_IIR_filter_0019": {"input": {"rtl/iir_filter.sv": "module iir_filter (\n    input logic clk,\n    input logic rst,\n    input logic signed [15:0] x,    \n    output logic signed [15:0] y    \n);\n\n    parameter signed [15:0] b0 = 16'h0F00;\n    parameter signed [15:0] b1 = 16'h0E00;\n    parameter signed [15:0] b2 = 16'h0D00;\n    parameter signed [15:0] b3 = 16'h0C00;\n    parameter signed [15:0] b4 = 16'h0B00;\n    parameter signed [15:0] b5 = 16'h0A00;\n    parameter signed [15:0] b6 = 16'h0900;\n    parameter signed [15:0] a1 = -16'h0800;\n    parameter signed [15:0] a2 = -16'h0700;\n    parameter signed [15:0] a3 = -16'h0600;\n    parameter signed [15:0] a4 = -16'h0500;\n    parameter signed [15:0] a5 = -16'h0400;\n    parameter signed [15:0] a6 = -16'h0300;\n\n    parameter logic [7:0] unused_param = 8'hFF;\n\n    logic signed [15:0] x_prev1, x_prev2, x_prev3, x_prev4, x_prev5, x_prev6;\n    logic signed [15:0] y_prev1, y_prev2, y_prev3, y_prev4, y_prev5, y_prev6;\n    \n    logic signed [31:0] temp_y;\n    logic undriven_signal;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            x_prev1 <= 0; x_prev2 <= 0; x_prev3 <= 0;\n            x_prev4 <= 0; x_prev5 <= 0; x_prev6 <= 0;\n            y_prev1 <= 0; y_prev2 <= 0; y_prev3 <= 0;\n            y_prev4 <= 0; y_prev5 <= 0; y_prev6 <= 0;\n        end else begin\n            temp_y = (b0 * x + b1 * x_prev1 + b2 * x_prev2 + b3 * x_prev3 +\n                      b4 * x_prev4 + b5 * x_prev5 + b6 * x_prev6 -\n                      a1 * y_prev1 - a2 * y_prev2 - a3 * y_prev3 -\n                      a4 * y_prev4 - a5 * y_prev5 - a6 * y_prev6) >>> 16;\n\n            y <= temp_y; \n            \n            if (x > 16'h8000) \n                y <= 16'h7FFF; \n\n            undriven_signal = y_prev3 ^ y_prev5;\n\n            x_prev6 <= x_prev5; x_prev5 <= x_prev4; x_prev4 <= x_prev3;\n            x_prev3 <= x_prev2; x_prev2 <= x_prev1; x_prev1 <= x;\n            y_prev6 <= y_prev5; y_prev5 <= y_prev4; y_prev4 <= y_prev3;\n            y_prev3 <= y_prev2; y_prev2 <= y_prev1; y_prev1 <= y;\n        end\n    end\n\nendmodule"}, "output": {"rtl/iir_filter.sv": ""}, "obj": true}}
{"cvdp_copilot_MSHR_0001": {"input": {}, "output": {"rtl/cache_mshr.sv": ""}, "obj": true}}
{"cvdp_copilot_MSHR_0008": {"input": {}, "output": {"rtl/cache_mshr.sv": ""}, "obj": true}}
{"cvdp_copilot_Serial_Line_Converter_0001": {"input": {}, "output": {"rtl/serial_line_code_converter.sv": ""}, "obj": true}}
{"cvdp_copilot_Serial_Line_Converter_0011": {"input": {"rtl/serial_line_code_converter.sv": "module serial_line_code_converter #(parameter CLK_DIV = 16)(\n    input  logic clk,             // System clock\n    input  logic reset_n,         // Active-low reset\n    input  logic serial_in,       // Serial input signal\n    input  logic [2:0] mode,      // Mode selector\n    output logic serial_out       // Serial output signal\n);\n\n    // Internal signals\n    logic [3:0] clk_counter;      // Clock divider counter\n    logic clk_pulse;              // Clock pulse for sampling\n    logic prev_serial_in;         // Previous serial input for edge detection\n    logic prev_value;             // Holds the previous value of serial_in\n    logic nrz_out;                // NRZ encoding output\n    logic rz_out;                 // Return-to-Zero encoding output\n    logic diff_out;               // Differential encoding output\n    logic inv_nrz_out;            // Inverted NRZ output\n    logic alt_invert_out;         // NRZ with alternating bit inversion output\n    logic alt_invert_state;       // State for alternating inversion\n    logic parity_out;             // Parity Bit Output\n    logic scrambled_out;          // Scrambled NRZ output\n    logic edge_triggered_out;     // Edge-Triggered NRZ output\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            clk_counter <= 0;\n            clk_pulse <= 0;\n        end else if (clk_counter == CLK_DIV - 1) begin\n            clk_counter <= 0;\n            clk_pulse <= 1;\n        end else begin\n            clk_counter <= clk_counter + 1;\n            clk_pulse <= 0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            prev_value <= 0;\n            prev_serial_in <= 0;\n        end else begin\n            prev_value <= serial_in;\n            prev_serial_in <= prev_value;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            nrz_out <= 0;\n        end else begin\n            nrz_out <= serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            rz_out <= 0;\n        end else begin\n            rz_out <= serial_in & clk_pulse; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            diff_out <= 0;\n        end else  begin\n            diff_out <= serial_in ^ prev_serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            inv_nrz_out <= 0;\n        end else  begin\n            inv_nrz_out <= ~serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            alt_invert_out <= 0;\n            alt_invert_state <= 0;\n        end else  begin\n            alt_invert_state <= ~alt_invert_state; \n            alt_invert_out <= alt_invert_state ? ~serial_in : serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            parity_out <= 0;\n        end else  begin\n            parity_out <= serial_in ^ parity_out; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            scrambled_out <= 0;\n        end else  begin\n            scrambled_out <= serial_in ^ clk_counter[0]; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            edge_triggered_out <= 0;\n        end else  begin\n            edge_triggered_out <= (serial_in & ~prev_serial_in);\n        end\n    end\n\n    always_comb begin\n        case (mode)\n            3'b000: serial_out = nrz_out;                \n            3'b001: serial_out = rz_out;                 \n            3'b010: serial_out = diff_out;               \n            3'b011: serial_out = inv_nrz_out;            \n            3'b100: serial_out = alt_invert_out;         \n            3'b101: serial_out = parity_out;             \n            3'b110: serial_out = scrambled_out;          \n            3'b111: serial_out = edge_triggered_out;     \n            default: serial_out = 0;                     \n        endcase\n    end\n\nendmodule"}, "output": {"rtl/serial_line_code_converter.sv": "module serial_line_code_converter #(parameter CLK_DIV = 16)(\n    input  logic clk,             // System clock\n    input  logic reset_n,         // Active-low reset\n    input  logic serial_in,       // Serial input signal\n    input  logic [2:0] mode,      // Mode selector\n    output logic serial_out       // Serial output signal\n);\n\n    // Internal signals\n    logic [3:0] clk_counter;      // Clock divider counter\n    logic clk_pulse;              // Clock pulse for sampling\n    logic prev_serial_in;         // Previous serial input for edge detection\n    logic prev_value;             // Holds the previous value of serial_in\n    logic nrz_out;                // NRZ encoding output\n    logic rz_out;                 // Return-to-Zero encoding output\n    logic diff_out;               // Differential encoding output\n    logic inv_nrz_out;            // Inverted NRZ output\n    logic alt_invert_out;         // NRZ with alternating bit inversion output\n    logic alt_invert_state;       // State for alternating inversion\n    logic parity_out;             // Parity Bit Output\n    logic scrambled_out;          // Scrambled NRZ output\n    logic edge_triggered_out;     // Edge-Triggered NRZ output\n\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            clk_counter <= 0;\n            clk_pulse <= 0;\n        end else if (clk_counter == CLK_DIV - 1) begin\n            clk_counter <= 0;\n            clk_pulse <= 1;\n        end else begin\n            clk_counter <= clk_counter + 1;\n            clk_pulse <= 0;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            prev_value <= 0;\n            prev_serial_in <= 0;\n        end else begin\n            prev_value <= serial_in;\n            prev_serial_in <= prev_value;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            nrz_out <= 0;\n        end else begin\n            nrz_out <= serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            rz_out <= 0;\n        end else begin\n            rz_out <= serial_in & clk_pulse; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            diff_out <= 0;\n        end else  begin\n            diff_out <= serial_in ^ prev_serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            inv_nrz_out <= 0;\n        end else  begin\n            inv_nrz_out <= ~serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            alt_invert_out <= 0;\n            alt_invert_state <= 0;\n        end else  begin\n            alt_invert_state <= ~alt_invert_state; \n            alt_invert_out <= alt_invert_state ? ~serial_in : serial_in;\n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            parity_out <= 0;\n        end else  begin\n            parity_out <= serial_in ^ parity_out; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            scrambled_out <= 0;\n        end else  begin\n            scrambled_out <= serial_in ^ clk_counter[0]; \n        end\n    end\n\n    always_ff @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            edge_triggered_out <= 0;\n        end else  begin\n            edge_triggered_out <= (serial_in & ~prev_serial_in);\n        end\n    end\n\n    always_comb begin\n        case (mode)\n            3'b000: serial_out = nrz_out;                \n            3'b001: serial_out = rz_out;                 \n            3'b010: serial_out = diff_out;               \n            3'b011: serial_out = inv_nrz_out;            \n            3'b100: serial_out = alt_invert_out;         \n            3'b101: serial_out = parity_out;             \n            3'b110: serial_out = scrambled_out;          \n            3'b111: serial_out = edge_triggered_out;     \n            default: serial_out = 0;                     \n        endcase\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_String_to_ASCII_0001": {"input": {"rtl/String_to_ASCII_Converter.sv": "module String_to_ASCII_Converter (\n    input wire clk,                       // Clock signal\n    input wire reset,                     // Reset signal\n    input wire start,                     // Start conversion\n    input wire [7:0] char_in [7:0],       // 8-character input string (7 bits per character: 0-95)\n    output reg [7:0] ascii_out,           // Final latched ASCII output\n    output reg valid,                     // Indicates valid output\n    output reg ready                      // Indicates module ready to accept input\n);\n    // Parameters for character type identification\n    localparam DIGIT   = 2'd0;\n    localparam UPPER   = 2'd1;\n    localparam LOWER   = 2'd2;\n    localparam SPECIAL = 2'd3;\n    // ASCII Offsets\n    localparam DIGIT_OFFSET   = 8'd48;    // '0' = 48\n    localparam UPPER_OFFSET   = 8'd65;    // 'A' = 65\n    localparam LOWER_OFFSET   = 8'd97;    // 'a' = 97\n    localparam SPECIAL_OFFSET = 8'd33;   // First special character '!' = 33\n    // Registers\n    reg [3:0] index;                      // Index for current character\n    reg active;                           // Indicates active conversion\n    reg [1:0] char_type;                  // Current character type\n    reg [7:0] intermediate_ascii;         // Combinational ASCII value\n    // Function to determine character type\n    function [1:0] determine_char_type;\n        input [7:0] char;\n        begin\n            if (char < 8'd10)\n                determine_char_type = DIGIT;    // '0'-'9'\n            else if (char < 8'd36)\n                determine_char_type = UPPER;    // 'A'-'Z'\n            else if (char < 8'd62)\n                determine_char_type = LOWER;    // 'a'-'z'\n            else\n                determine_char_type = SPECIAL;  // Special characters\n        end\n    endfunction\n    // Combinational logic for ASCII calculation\n    always @(*) begin\n        // Determine character type\n        char_type = determine_char_type(char_in[index]);\n        // Calculate ASCII based on character type\n        case (char_type)\n            DIGIT:   intermediate_ascii = char_in[index] + DIGIT_OFFSET;          // '0'-'9'\n            UPPER:   intermediate_ascii = (char_in[index] - 8'd10) + UPPER_OFFSET; // 'A'-'Z'\n            LOWER:   intermediate_ascii = (char_in[index] - 8'd36) + LOWER_OFFSET; // 'a'-'z'\n            SPECIAL: intermediate_ascii = (char_in[index] - 8'd62) + SPECIAL_OFFSET; // Special characters\n            default: intermediate_ascii = 8'd0;\n        endcase\n    end\n    // Sequential logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            index       <= 4'd0;\n            ascii_out   <= 8'd0;\n            valid       <= 1'b0;\n            ready       <= 1'b1;\n            active      <= 1'b0;\n        end else begin\n            if (start && ready) begin\n                // Start conversion\n                ready <= 1'b0;\n                active <= 1'b1;\n                index <= 4'd0;\n                valid <= 1'b0;\n            end else if (active) begin\n                // Process current character\n                if (index < 8) begin\n                    ascii_out <= intermediate_ascii; // Latch current ASCII value\n                    valid <= 1'b1; // Indicate valid output\n                    index <= index + 1;\n                end else begin\n                    // Finish conversion\n                    active <= 1'b0;\n                    ready <= 1'b1;\n                    valid <= 1'b0;\n                end\n            end\n        end\n    end\nendmodule"}, "output": {"rtl/String_to_ASCII_Converter.sv": "module String_to_ASCII_Converter (\n    input wire clk,                       // Clock signal\n    input wire reset,                     // Reset signal\n    input wire start,                     // Start conversion\n    input wire [7:0] char_in [7:0],       // 8-character input string (7 bits per character: 0-95)\n    output reg [7:0] ascii_out,           // Final latched ASCII output\n    output reg valid,                     // Indicates valid output\n    output reg ready                      // Indicates module ready to accept input\n);\n    // Parameters for character type identification\n    localparam DIGIT   = 2'd0;\n    localparam UPPER   = 2'd1;\n    localparam LOWER   = 2'd2;\n    localparam SPECIAL = 2'd3;\n    // ASCII Offsets\n    localparam DIGIT_OFFSET   = 8'd48;    // '0' = 48\n    localparam UPPER_OFFSET   = 8'd65;    // 'A' = 65\n    localparam LOWER_OFFSET   = 8'd97;    // 'a' = 97\n    localparam SPECIAL_OFFSET = 8'd33;   // First special character '!' = 33\n    // Registers\n    reg [3:0] index;                      // Index for current character\n    reg active;                           // Indicates active conversion\n    reg [1:0] char_type;                  // Current character type\n    reg [7:0] intermediate_ascii;         // Combinational ASCII value\n    // Function to determine character type\n    function [1:0] determine_char_type;\n        input [7:0] char;\n        begin\n            if (char < 8'd10)\n                determine_char_type = DIGIT;    // '0'-'9'\n            else if (char < 8'd36)\n                determine_char_type = UPPER;    // 'A'-'Z'\n            else if (char < 8'd62)\n                determine_char_type = LOWER;    // 'a'-'z'\n            else\n                determine_char_type = SPECIAL;  // Special characters\n        end\n    endfunction\n    // Combinational logic for ASCII calculation\n    always @(*) begin\n        // Determine character type\n        char_type = determine_char_type(char_in[index]);\n        // Calculate ASCII based on character type\n        case (char_type)\n            DIGIT:   intermediate_ascii = char_in[index] + DIGIT_OFFSET;          // '0'-'9'\n            UPPER:   intermediate_ascii = (char_in[index] - 8'd10) + UPPER_OFFSET; // 'A'-'Z'\n            LOWER:   intermediate_ascii = (char_in[index] - 8'd36) + LOWER_OFFSET; // 'a'-'z'\n            SPECIAL: intermediate_ascii = (char_in[index] - 8'd62) + SPECIAL_OFFSET; // Special characters\n            default: intermediate_ascii = 8'd0;\n        endcase\n    end\n    // Sequential logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            index       <= 4'd0;\n            ascii_out   <= 8'd0;\n            valid       <= 1'b0;\n            ready       <= 1'b1;\n            active      <= 1'b0;\n        end else begin\n            if (start && ready) begin\n                // Start conversion\n                ready <= 1'b0;\n                active <= 1'b1;\n                index <= 4'd0;\n                valid <= 1'b0;\n            end else if (active) begin\n                // Process current character\n                if (index < 8) begin\n                    ascii_out <= intermediate_ascii; // Latch current ASCII value\n                    valid <= 1'b1; // Indicate valid output\n                    index <= index + 1;\n                end else begin\n                    // Finish conversion\n                    active <= 1'b0;\n                    ready <= 1'b1;\n                    valid <= 1'b0;\n                end\n            end\n        end\n    end\nendmodule"}, "obj": true}}
{"cvdp_copilot_Synchronous_Muller_C_Element_0001": {"input": {}, "output": {"rtl/sync_muller_c_element.sv": ""}, "obj": true}}
{"cvdp_copilot_adc_data_rotate_0001": {"input": {}, "output": {"rtl/adc_data_rotate.sv": ""}, "obj": true}}
{"cvdp_copilot_aes_key_expansion_0001": {"input": {"rtl/key_expansion_128aes.sv": "module key_expansion_128aes #(\n    parameter NBW_KEY = 'd128,\n    parameter NBW_OUT = 'd1408\n) (\n    input  logic               clk,\n    input  logic               rst_async_n,\n    input  logic               i_start,\n    input  logic [NBW_KEY-1:0] i_key,\n    output logic               o_done,\n    output logic [NBW_OUT-1:0] o_expanded_key\n);\n\nlocalparam NBW_BYTE = 'd8;\nlocalparam STEPS = 'd10;\nlocalparam NBW_WORD = 'd32;\n\n// Auxiliary wires\nlogic [NBW_BYTE-1:0] Rcon   [STEPS];\nlogic [NBW_KEY-1:0] valid_key;\nlogic [NBW_KEY-1:0] step_key[STEPS];\nlogic [NBW_OUT-1:0] expanded_key_nx;\nlogic [NBW_OUT-1:0] expanded_key_ff;\n\nlogic [STEPS:0] steps_ff;\n\nlogic [3:0] count_ff;\nlogic [3:0] count_nx;\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        expanded_key_ff <= {NBW_OUT{1'b0}};\n        steps_ff <= 11'h400;\n    end else begin\n        expanded_key_ff <= expanded_key_nx;\n        if(i_start || (|steps_ff[9:0])) begin\n            steps_ff <= {steps_ff[STEPS-1:0], (i_start & o_done)};\n        end\n    end\nend\n\nassign o_done = steps_ff[STEPS];\nassign o_expanded_key = expanded_key_ff;\n\nassign Rcon[0] = 8'h01;\nassign Rcon[1] = 8'h02;\nassign Rcon[2] = 8'h04;\nassign Rcon[3] = 8'h08;\nassign Rcon[4] = 8'h10;\nassign Rcon[5] = 8'h20;\nassign Rcon[6] = 8'h40;\nassign Rcon[7] = 8'h80;\nassign Rcon[8] = 8'h1b;\nassign Rcon[9] = 8'h36;\n\ngenerate\n    for(genvar i = 0; i < STEPS; i++) begin : steps\n        logic [NBW_WORD-1:0] RotWord;\n        logic [NBW_WORD-1:0] SubWord;\n        logic [NBW_WORD-1:0] RconXor;\n\n        sbox uu_sbox0 (\n            .i_data(RotWord[31:24]),\n            .o_data(SubWord[31:24])\n        );\n\n        sbox uu_sbox1 (\n            .i_data(RotWord[23:16]),\n            .o_data(SubWord[23:16])\n        );\n\n        sbox uu_sbox2 (\n            .i_data(RotWord[15:8]),\n            .o_data(SubWord[15:8])\n        );\n\n        sbox uu_sbox3 (\n            .i_data(RotWord[7:0]),\n            .o_data(SubWord[7:0])\n        );\n\n        always_comb begin\n            RotWord = {expanded_key_ff[NBW_OUT-(i+1)*NBW_KEY+NBW_WORD-NBW_BYTE-1-:(NBW_WORD-NBW_BYTE)], expanded_key_ff[NBW_OUT-(i+1)*NBW_KEY+NBW_WORD-1-:NBW_BYTE]};\n            RconXor = {SubWord[31:24]^Rcon[i], SubWord[23:0]};\n\n            step_key[i][127:96] = expanded_key_ff[NBW_OUT-(4*i  )*NBW_WORD-1-:NBW_WORD] ^ RconXor;\n            step_key[i][95 :64] = expanded_key_ff[NBW_OUT-(4*i+1)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][127:96];\n            step_key[i][63 :32] = expanded_key_ff[NBW_OUT-(4*i+2)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][95 :64];\n            step_key[i][31 :0 ] = expanded_key_ff[NBW_OUT-(4*i+3)*NBW_WORD-1-:NBW_WORD] ^ step_key[i][63 :32];\n        end\n    end\nendgenerate\n\nassign expanded_key_nx = {valid_key  , step_key[0], step_key[1], step_key[2],\n                          step_key[3], step_key[4], step_key[5], step_key[6],\n                          step_key[7], step_key[8], step_key[9]};\n\nalways_comb begin\n    if (i_start & o_done) begin\n        valid_key = i_key;\n    end else begin\n        valid_key = expanded_key_ff[NBW_OUT-1-:NBW_KEY];\n    end\nend\n\nendmodule : key_expansion_128aes\n\nmodule sbox (\n    input  logic [7:0] i_data,\n    output logic [7:0] o_data\n);\n\nalways_comb begin\n    case (i_data)\n        8'h00: o_data = 8'h63;\n        8'h01: o_data = 8'h7C;\n        8'h02: o_data = 8'h77;\n        8'h03: o_data = 8'h7B;\n        8'h04: o_data = 8'hF2;\n        8'h05: o_data = 8'h6B;\n        8'h06: o_data = 8'h6F;\n        8'h07: o_data = 8'hC5;\n        8'h08: o_data = 8'h30;\n        8'h09: o_data = 8'h01;\n        8'h0A: o_data = 8'h67;\n        8'h0B: o_data = 8'h2B;\n        8'h0C: o_data = 8'hFE;\n        8'h0D: o_data = 8'hD7;\n        8'h0E: o_data = 8'hAB;\n        8'h0F: o_data = 8'h76;\n        8'h10: o_data = 8'hCA;\n        8'h11: o_data = 8'h82;\n        8'h12: o_data = 8'hC9;\n        8'h13: o_data = 8'h7D;\n        8'h14: o_data = 8'hFA;\n        8'h15: o_data = 8'h59;\n        8'h16: o_data = 8'h47;\n        8'h17: o_data = 8'hF0;\n        8'h18: o_data = 8'hAD;\n        8'h19: o_data = 8'hD4;\n        8'h1A: o_data = 8'hA2;\n        8'h1B: o_data = 8'hAF;\n        8'h1C: o_data = 8'h9C;\n        8'h1D: o_data = 8'hA4;\n        8'h1E: o_data = 8'h72;\n        8'h1F: o_data = 8'hC0;\n        8'h20: o_data = 8'hB7;\n        8'h21: o_data = 8'hFD;\n        8'h22: o_data = 8'h93;\n        8'h23: o_data = 8'h26;\n        8'h24: o_data = 8'h36;\n        8'h25: o_data = 8'h3F;\n        8'h26: o_data = 8'hF7;\n        8'h27: o_data = 8'hCC;\n        8'h28: o_data = 8'h34;\n        8'h29: o_data = 8'hA5;\n        8'h2A: o_data = 8'hE5;\n        8'h2B: o_data = 8'hF1;\n        8'h2C: o_data = 8'h71;\n        8'h2D: o_data = 8'hD8;\n        8'h2E: o_data = 8'h31;\n        8'h2F: o_data = 8'h15;\n        8'h30: o_data = 8'h04;\n        8'h31: o_data = 8'hC7;\n        8'h32: o_data = 8'h23;\n        8'h33: o_data = 8'hC3;\n        8'h34: o_data = 8'h18;\n        8'h35: o_data = 8'h96;\n        8'h36: o_data = 8'h05;\n        8'h37: o_data = 8'h9A;\n        8'h38: o_data = 8'h07;\n        8'h39: o_data = 8'h12;\n        8'h3A: o_data = 8'h80;\n        8'h3B: o_data = 8'hE2;\n        8'h3C: o_data = 8'hEB;\n        8'h3D: o_data = 8'h27;\n        8'h3E: o_data = 8'hB2;\n        8'h3F: o_data = 8'h75;\n        8'h40: o_data = 8'h09;\n        8'h41: o_data = 8'h83;\n        8'h42: o_data = 8'h2C;\n        8'h43: o_data = 8'h1A;\n        8'h44: o_data = 8'h1B;\n        8'h45: o_data = 8'h6E;\n        8'h46: o_data = 8'h5A;\n        8'h47: o_data = 8'hA0;\n        8'h48: o_data = 8'h52;\n        8'h49: o_data = 8'h3B;\n        8'h4A: o_data = 8'hD6;\n        8'h4B: o_data = 8'hB3;\n        8'h4C: o_data = 8'h29;\n        8'h4D: o_data = 8'hE3;\n        8'h4E: o_data = 8'h2F;\n        8'h4F: o_data = 8'h84;\n        8'h50: o_data = 8'h53;\n        8'h51: o_data = 8'hD1;\n        8'h52: o_data = 8'h00;\n        8'h53: o_data = 8'hED;\n        8'h54: o_data = 8'h20;\n        8'h55: o_data = 8'hFC;\n        8'h56: o_data = 8'hB1;\n        8'h57: o_data = 8'h5B;\n        8'h58: o_data = 8'h6A;\n        8'h59: o_data = 8'hCB;\n        8'h5A: o_data = 8'hBE;\n        8'h5B: o_data = 8'h39;\n        8'h5C: o_data = 8'h4A;\n        8'h5D: o_data = 8'h4C;\n        8'h5E: o_data = 8'h58;\n        8'h5F: o_data = 8'hCF;\n        8'h60: o_data = 8'hD0;\n        8'h61: o_data = 8'hEF;\n        8'h62: o_data = 8'hAA;\n        8'h63: o_data = 8'hFB;\n        8'h64: o_data = 8'h43;\n        8'h65: o_data = 8'h4D;\n        8'h66: o_data = 8'h33;\n        8'h67: o_data = 8'h85;\n        8'h68: o_data = 8'h45;\n        8'h69: o_data = 8'hF9;\n        8'h6A: o_data = 8'h02;\n        8'h6B: o_data = 8'h7F;\n        8'h6C: o_data = 8'h50;\n        8'h6D: o_data = 8'h3C;\n        8'h6E: o_data = 8'h9F;\n        8'h6F: o_data = 8'hA8;\n        8'h70: o_data = 8'h51;\n        8'h71: o_data = 8'hA3;\n        8'h72: o_data = 8'h40;\n        8'h73: o_data = 8'h8F;\n        8'h74: o_data = 8'h92;\n        8'h75: o_data = 8'h9D;\n        8'h76: o_data = 8'h38;\n        8'h77: o_data = 8'hF5;\n        8'h78: o_data = 8'hBC;\n        8'h79: o_data = 8'hB6;\n        8'h7A: o_data = 8'hDA;\n        8'h7B: o_data = 8'h21;\n        8'h7C: o_data = 8'h10;\n        8'h7D: o_data = 8'hFF;\n        8'h7E: o_data = 8'hF3;\n        8'h7F: o_data = 8'hD2;\n        8'h80: o_data = 8'hCD;\n        8'h81: o_data = 8'h0C;\n        8'h82: o_data = 8'h13;\n        8'h83: o_data = 8'hEC;\n        8'h84: o_data = 8'h5F;\n        8'h85: o_data = 8'h97;\n        8'h86: o_data = 8'h44;\n        8'h87: o_data = 8'h17;\n        8'h88: o_data = 8'hC4;\n        8'h89: o_data = 8'hA7;\n        8'h8A: o_data = 8'h7E;\n        8'h8B: o_data = 8'h3D;\n        8'h8C: o_data = 8'h64;\n        8'h8D: o_data = 8'h5D;\n        8'h8E: o_data = 8'h19;\n        8'h8F: o_data = 8'h73;\n        8'h90: o_data = 8'h60;\n        8'h91: o_data = 8'h81;\n        8'h92: o_data = 8'h4F;\n        8'h93: o_data = 8'hDC;\n        8'h94: o_data = 8'h22;\n        8'h95: o_data = 8'h2A;\n        8'h96: o_data = 8'h90;\n        8'h97: o_data = 8'h88;\n        8'h98: o_data = 8'h46;\n        8'h99: o_data = 8'hEE;\n        8'h9A: o_data = 8'hB8;\n        8'h9B: o_data = 8'h14;\n        8'h9C: o_data = 8'hDE;\n        8'h9D: o_data = 8'h5E;\n        8'h9E: o_data = 8'h0B;\n        8'h9F: o_data = 8'hDB;\n        8'hA0: o_data = 8'hE0;\n        8'hA1: o_data = 8'h32;\n        8'hA2: o_data = 8'h3A;\n        8'hA3: o_data = 8'h0A;\n        8'hA4: o_data = 8'h49;\n        8'hA5: o_data = 8'h06;\n        8'hA6: o_data = 8'h24;\n        8'hA7: o_data = 8'h5C;\n        8'hA8: o_data = 8'hC2;\n        8'hA9: o_data = 8'hD3;\n        8'hAA: o_data = 8'hAC;\n        8'hAB: o_data = 8'h62;\n        8'hAC: o_data = 8'h91;\n        8'hAD: o_data = 8'h95;\n        8'hAE: o_data = 8'hE4;\n        8'hAF: o_data = 8'h79;\n        8'hB0: o_data = 8'hE7;\n        8'hB1: o_data = 8'hC8;\n        8'hB2: o_data = 8'h37;\n        8'hB3: o_data = 8'h6D;\n        8'hB4: o_data = 8'h8D;\n        8'hB5: o_data = 8'hD5;\n        8'hB6: o_data = 8'h4E;\n        8'hB7: o_data = 8'hA9;\n        8'hB8: o_data = 8'h6C;\n        8'hB9: o_data = 8'h56;\n        8'hBA: o_data = 8'hF4;\n        8'hBB: o_data = 8'hEA;\n        8'hBC: o_data = 8'h65;\n        8'hBD: o_data = 8'h7A;\n        8'hBE: o_data = 8'hAE;\n        8'hBF: o_data = 8'h08;\n        8'hC0: o_data = 8'hBA;\n        8'hC1: o_data = 8'h78;\n        8'hC2: o_data = 8'h25;\n        8'hC3: o_data = 8'h2E;\n        8'hC4: o_data = 8'h1C;\n        8'hC5: o_data = 8'hA6;\n        8'hC6: o_data = 8'hB4;\n        8'hC7: o_data = 8'hC6;\n        8'hC8: o_data = 8'hE8;\n        8'hC9: o_data = 8'hDD;\n        8'hCA: o_data = 8'h74;\n        8'hCB: o_data = 8'h1F;\n        8'hCC: o_data = 8'h4B;\n        8'hCD: o_data = 8'hBD;\n        8'hCE: o_data = 8'h8B;\n        8'hCF: o_data = 8'h8A;\n        8'hD0: o_data = 8'h70;\n        8'hD1: o_data = 8'h3E;\n        8'hD2: o_data = 8'hB5;\n        8'hD3: o_data = 8'h66;\n        8'hD4: o_data = 8'h48;\n        8'hD5: o_data = 8'h03;\n        8'hD6: o_data = 8'hF6;\n        8'hD7: o_data = 8'h0E;\n        8'hD8: o_data = 8'h61;\n        8'hD9: o_data = 8'h35;\n        8'hDA: o_data = 8'h57;\n        8'hDB: o_data = 8'hB9;\n        8'hDC: o_data = 8'h86;\n        8'hDD: o_data = 8'hC1;\n        8'hDE: o_data = 8'h1D;\n        8'hDF: o_data = 8'h9E;\n        8'hE0: o_data = 8'hE1;\n        8'hE1: o_data = 8'hF8;\n        8'hE2: o_data = 8'h98;\n        8'hE3: o_data = 8'h11;\n        8'hE4: o_data = 8'h69;\n        8'hE5: o_data = 8'hD9;\n        8'hE6: o_data = 8'h8E;\n        8'hE7: o_data = 8'h94;\n        8'hE8: o_data = 8'h9B;\n        8'hE9: o_data = 8'h1E;\n        8'hEA: o_data = 8'h87;\n        8'hEB: o_data = 8'hE9;\n        8'hEC: o_data = 8'hCE;\n        8'hED: o_data = 8'h55;\n        8'hEE: o_data = 8'h28;\n        8'hEF: o_data = 8'hDF;\n        8'hF0: o_data = 8'h8C;\n        8'hF1: o_data = 8'hA1;\n        8'hF2: o_data = 8'h89;\n        8'hF3: o_data = 8'h0D;\n        8'hF4: o_data = 8'hBF;\n        8'hF5: o_data = 8'hE6;\n        8'hF6: o_data = 8'h42;\n        8'hF7: o_data = 8'h68;\n        8'hF8: o_data = 8'h41;\n        8'hF9: o_data = 8'h99;\n        8'hFA: o_data = 8'h2D;\n        8'hFB: o_data = 8'h0F;\n        8'hFC: o_data = 8'hB0;\n        8'hFD: o_data = 8'h54;\n        8'hFE: o_data = 8'hBB;\n        8'hFF: o_data = 8'h16;\n        default: o_data = 8'h00;\n    endcase\nend\n\nendmodule : sbox\n"}, "output": {"rtl/key_expansion_128aes.sv": ""}, "obj": true}}
{"cvdp_copilot_ahb_clk_counter_0001": {"input": {}, "output": {"rtl/ahb_clock_counter.sv": ""}, "obj": true}}
{"cvdp_copilot_alphablending_0003": {"input": {"rtl/alphablending.sv": "module alphablending #(\n    parameter H = 5,\n    parameter N = 3,\n    parameter W = 8\n) (\n    input clk,\n    input reset,\n    input start,\n    input [(24*H*W)-1:0] pixel_in,    // N pixels, each 24-bit RGB\n    input [(8*H*W)-1:0] alpha_in,     // N alpha values, each 8-bit\n    input [(24*H*W)-1:0] bg_pixel_in, // N background pixels, each 24-bit RGB\n    output reg [(24*H*W)-1:0] blended_out, // N blended output pixels\n    output reg done\n);\n\n// State Encoding\nlocalparam IDLE     = 2'b00;\nlocalparam LOAD     = 2'b01;\nlocalparam COMPUTE  = 2'b10;\nlocalparam COMPLETE = 2'b11;\nlocalparam STORE    = 2'b11;\n\nreg [1:0] state, next_state;\n\n// Registers for inputs and outputs\nreg [23:0] pixel [0:H*W-1];       // Individual pixels (24-bit each)\nreg [7:0] alpha [0:H*W-1];        // Individual alpha values (8-bit each)\nreg [23:0] bg_pixel [0:H*W-1];    // Individual background pixels (24-bit each)\nreg [23:0] blended [0:H*W-1];     // Individual blended results (24-bit each)\n\n// Pixel count and padding logic\ninteger i;\ninteger pixel_count;\ninteger total_pixels;\ninteger padded_pixels;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        pixel_count <= 0;\n        total_pixels <= 0;\n        padded_pixels <= 0;\n    end else if (state == IDLE && start) begin\n        pixel_count <= 0;\n        total_pixels <= H * W;\n        padded_pixels <= (((H * W + N - 1) / N) * N) - (H * W);\n    end else if (state == COMPUTE && pixel_count < total_pixels + padded_pixels) begin\n        pixel_count <= pixel_count + N;\n    end\nend\n\n// State Transition Logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n        state <= IDLE;\n    else \n        state <= next_state;\nend\n\n// Next State Logic\nalways @(state or start) begin\n    case (state)\n        IDLE: next_state = (start) ? LOAD : IDLE;\n        LOAD: next_state = COMPUTE;\n        COMPUTE: next_state = (pixel_count < total_pixels + padded_pixels) ? LOAD : COMPLETE;\n        COMPLETE: next_state = IDLE;\n        STORE:  next_state = IDLE;\n    endcase\nend\n\n// Alpha Blending Calculation\n// Formula: blended = (alpha * pixel + (255 - alpha) * bg_pixel) / 255\nalways @(posedge clk) begin\n    if (state == LOAD) begin\n        // Unpack inputs into arrays\n        for (i = 0; i < N; i = i + 1) begin\n            if (pixel_count + i < total_pixels) begin\n                pixel[i] <= pixel_in[(pixel_count + i)*24 +: 24];\n                alpha[i] <= alpha_in[(pixel_count + i)*8 +: 8];\n                bg_pixel[i] <= bg_pixel_in[(pixel_count + i)*24 +: 24];\n            end \n            else begin\n                pixel[i] <= 24'd0; // Pad with 0 if out of bounds\n                alpha[i] <= 8'd0;\n                bg_pixel[i] <= 24'd0;\n            end\n        end\n    end\n    else if (state == COMPUTE) begin\n        for (i = 0; i < N; i = i + 1) begin\n            blended[pixel_count + i][23:16] <= (alpha[i] * pixel[i][23:16] + (255 - alpha[i]) * bg_pixel[i][23:16]) / 255;\n            blended[pixel_count + i][15:8]  <= (alpha[i] * pixel[i][15:8]  + (255 - alpha[i]) * bg_pixel[i][15:8])  / 255;\n            blended[pixel_count + i][7:0]   <= (alpha[i] * pixel[i][7:0]   + (255 - alpha[i]) * bg_pixel[i][7:0])   / 255;\n        end\n    end\n    else if (state == COMPLETE) begin\n        // Pack blended results into output\n        for (i = 0; i < H*W; i = i + 1) begin\n            blended_out[i*24 +: 24] <= blended[i][23:0];\n        end\n    end\nend\n\n// Output Logic\nalways @(posedge clk) begin\n    if (reset) begin\n        done <= 0;\n        blended_out <= 0;\n    end\n    else if (state == COMPLETE) begin\n        done <= 1;\n    end\n    else begin\n        done <= 0;\n    end\nend\n\nendmodule"}, "output": {"rtl/alphablending.sv": ""}, "obj": true}}
{"cvdp_copilot_apb_dsp_op_0002": {"input": {"rtl/apb_dsp_op.sv": "// APB DSP Operation Module\nmodule apb_dsp_op #(\n    parameter ADDR_WIDTH = 'd8,\n    parameter DATA_WIDTH = 'd32\n) (\n    input  logic                  clk_dsp,    // Faster clock to DSP operation\n    input  logic                  en_clk_dsp, // Enable DSP operation with faster clock\n    input  logic                  PCLK,       // APB clock\n    input  logic                  PRESETn,    // Active low asynchronous APB Reset\n    input  logic [ADDR_WIDTH-1:0] PADDR,      // APB address\n    input  logic                  PWRITE,     // Write/Read enable\n    input  logic [DATA_WIDTH-1:0] PWDATA,     // Write data\n    input  logic                  PSEL,       // DSP selector\n    input  logic                  PENABLE,    // APB enable\n    output logic [DATA_WIDTH-1:0] PRDATA,     // Read data\n    output logic                  PREADY      // Ready signal\n);\n\n    // Clock sel logic\n    assign dsp_clk_sel = (en_clk_dsp) ? clk_dsp : PCLK;\n\n    // Internal registers address map\n    localparam ADDRESS_A         = 32'h0;  // 0x00\n    localparam ADDRESS_B         = 32'h4;  // 0x04\n    localparam ADDRESS_C         = 32'h8;  // 0x08\n    localparam ADDRESS_O         = 32'hC;  // 0x0C\n    localparam ADDRESS_CONTROL   = 32'h10; // 0x10\n    localparam ADDRESS_WDATA     = 32'h14; // 0x14\n    localparam ADDRESS_SRAM_ADDR = 32'h18; // 0x18\n\n    // Control modes\n    localparam SRAM_WRITE     = 32'd1;\n    localparam SRAM_READ      = 32'd2;\n    localparam DSP_READ_OP_A  = 32'd3;\n    localparam DSP_READ_OP_B  = 32'd4;\n    localparam DSP_READ_OP_C  = 32'd5;\n    localparam DSP_WRITE_OP_O = 32'd6;\n\n    // Internal signals\n    logic [DATA_WIDTH-1:0] reg_operand_a;\n    logic [DATA_WIDTH-1:0] reg_operand_b;\n    logic [DATA_WIDTH-1:0] reg_operand_c;\n    logic [DATA_WIDTH-1:0] reg_operand_o;\n    logic [DATA_WIDTH-1:0] reg_control;\n    logic [DATA_WIDTH-1:0] reg_wdata_sram;\n    logic [DATA_WIDTH-1:0] reg_addr_sram;\n\n    logic signed [DATA_WIDTH-1:0] wire_op_a;\n    logic signed [DATA_WIDTH-1:0] wire_op_b;\n    logic signed [DATA_WIDTH-1:0] wire_op_c;\n    logic signed [DATA_WIDTH-1:0] wire_op_o;\n    logic        [DATA_WIDTH-1:0] sram_data_in;\n    logic                         sram_we;\n    logic        [DATA_WIDTH-1:0] sram_addr;\n    logic        [DATA_WIDTH-1:0] sram_data_out;\n\n    // APB interface logic\n    always_ff @(posedge PCLK or negedge PRESETn) begin\n        if (!PRESETn) begin\n            reg_operand_a  <= 'd0;\n            reg_operand_b  <= 'd0;\n            reg_operand_c  <= 'd0;\n            reg_operand_o  <= 'd0;\n            reg_control    <= 'd0;\n            reg_wdata_sram <= 'd0;\n            reg_addr_sram  <= 'd0;\n            PREADY <= 1'b0;\n        end else if (PENABLE & PSEL) begin\n            PREADY <= 1'b1;\n            if (PWRITE) begin\n                case (PADDR)\n                    ADDRESS_A         : reg_operand_a  <= PWDATA;\n                    ADDRESS_B         : reg_operand_b  <= PWDATA;\n                    ADDRESS_C         : reg_operand_c  <= PWDATA;\n                    ADDRESS_O         : reg_operand_o  <= PWDATA;\n                    ADDRESS_CONTROL   : reg_control    <= PWDATA;\n                    ADDRESS_WDATA     : reg_wdata_sram <= PWDATA;\n                    ADDRESS_SRAM_ADDR : reg_addr_sram  <= PWDATA;\n                endcase\n            end else begin\n                if (reg_control == SRAM_READ) begin\n                    PRDATA <= sram_data_out;\n                end else begin\n                    case (PADDR)\n                        ADDRESS_A         : PRDATA <= reg_operand_a;\n                        ADDRESS_B         : PRDATA <= reg_operand_b;\n                        ADDRESS_C         : PRDATA <= reg_operand_c;\n                        ADDRESS_O         : PRDATA <= reg_operand_o;\n                        ADDRESS_CONTROL   : PRDATA <= reg_control;\n                        ADDRESS_WDATA     : PRDATA <= reg_wdata_sram;\n                        ADDRESS_SRAM_ADDR : PRDATA <= reg_addr_sram;\n                    endcase\n                end               \n            end\n        end\n    end\n\n    // SRAM logic\n    logic [DATA_WIDTH-1:0] mem [63:0];\n\n    always_comb begin\n        sram_data_in = (reg_control == SRAM_WRITE) ? reg_wdata_sram : wire_op_o;\n\n        if ((reg_control == SRAM_WRITE) || (reg_control == DSP_WRITE_OP_O)) begin\n            sram_we = 1'b1;\n        end else begin\n            sram_we = 1'b0;\n        end\n\n        case (reg_control)\n            DSP_READ_OP_A  : sram_addr = reg_operand_a;\n            DSP_READ_OP_B  : sram_addr = reg_operand_b;\n            DSP_READ_OP_C  : sram_addr = reg_operand_c;\n            DSP_WRITE_OP_O : sram_addr = reg_operand_o;\n            default        : sram_addr = reg_addr_sram;\n        endcase\n    end\n\n    always_ff @(posedge PCLK) begin\n        if (sram_we) begin\n            mem[sram_addr] <= sram_data_in;\n        end else begin\n            sram_data_out <= mem[sram_addr];\n        end\n    end\n    \n    // DSP operation\n    always_ff @(posedge dsp_clk_sel) begin\n        case (reg_control)\n            DSP_READ_OP_A  : wire_op_a <= sram_data_out;\n            DSP_READ_OP_B  : wire_op_b <= sram_data_out;\n            DSP_READ_OP_C  : wire_op_c <= sram_data_out;\n        endcase\n    end\n    \n    assign wire_op_o = (wire_op_a * wire_op_b) + wire_op_c;\n\nendmodule"}, "output": {"rtl/apb_dsp_op.sv": "// APB DSP Operation Module\nmodule apb_dsp_op #(\n    parameter ADDR_WIDTH = 'd8,\n    parameter DATA_WIDTH = 'd32\n) (\n    input  logic                  clk_dsp,    // Faster clock to DSP operation\n    input  logic                  en_clk_dsp, // Enable DSP operation with faster clock\n    input  logic                  PCLK,       // APB clock\n    input  logic                  PRESETn,    // Active low asynchronous APB Reset\n    input  logic [ADDR_WIDTH-1:0] PADDR,      // APB address\n    input  logic                  PWRITE,     // Write/Read enable\n    input  logic [DATA_WIDTH-1:0] PWDATA,     // Write data\n    input  logic                  PSEL,       // DSP selector\n    input  logic                  PENABLE,    // APB enable\n    output logic [DATA_WIDTH-1:0] PRDATA,     // Read data\n    output logic                  PREADY      // Ready signal\n);\n\n    // Clock sel logic\n    assign dsp_clk_sel = (en_clk_dsp) ? clk_dsp : PCLK;\n\n    // Internal registers address map\n    localparam ADDRESS_A         = 32'h0;  // 0x00\n    localparam ADDRESS_B         = 32'h4;  // 0x04\n    localparam ADDRESS_C         = 32'h8;  // 0x08\n    localparam ADDRESS_O         = 32'hC;  // 0x0C\n    localparam ADDRESS_CONTROL   = 32'h10; // 0x10\n    localparam ADDRESS_WDATA     = 32'h14; // 0x14\n    localparam ADDRESS_SRAM_ADDR = 32'h18; // 0x18\n\n    // Control modes\n    localparam SRAM_WRITE     = 32'd1;\n    localparam SRAM_READ      = 32'd2;\n    localparam DSP_READ_OP_A  = 32'd3;\n    localparam DSP_READ_OP_B  = 32'd4;\n    localparam DSP_READ_OP_C  = 32'd5;\n    localparam DSP_WRITE_OP_O = 32'd6;\n\n    // Internal signals\n    logic [DATA_WIDTH-1:0] reg_operand_a;\n    logic [DATA_WIDTH-1:0] reg_operand_b;\n    logic [DATA_WIDTH-1:0] reg_operand_c;\n    logic [DATA_WIDTH-1:0] reg_operand_o;\n    logic [DATA_WIDTH-1:0] reg_control;\n    logic [DATA_WIDTH-1:0] reg_wdata_sram;\n    logic [DATA_WIDTH-1:0] reg_addr_sram;\n\n    logic signed [DATA_WIDTH-1:0] wire_op_a;\n    logic signed [DATA_WIDTH-1:0] wire_op_b;\n    logic signed [DATA_WIDTH-1:0] wire_op_c;\n    logic signed [DATA_WIDTH-1:0] wire_op_o;\n    logic        [DATA_WIDTH-1:0] sram_data_in;\n    logic                         sram_we;\n    logic        [DATA_WIDTH-1:0] sram_addr;\n    logic        [DATA_WIDTH-1:0] sram_data_out;\n\n    // APB interface logic\n    always_ff @(posedge PCLK or negedge PRESETn) begin\n        if (!PRESETn) begin\n            reg_operand_a  <= 'd0;\n            reg_operand_b  <= 'd0;\n            reg_operand_c  <= 'd0;\n            reg_operand_o  <= 'd0;\n            reg_control    <= 'd0;\n            reg_wdata_sram <= 'd0;\n            reg_addr_sram  <= 'd0;\n            PREADY <= 1'b0;\n        end else if (PENABLE & PSEL) begin\n            PREADY <= 1'b1;\n            if (PWRITE) begin\n                case (PADDR)\n                    ADDRESS_A         : reg_operand_a  <= PWDATA;\n                    ADDRESS_B         : reg_operand_b  <= PWDATA;\n                    ADDRESS_C         : reg_operand_c  <= PWDATA;\n                    ADDRESS_O         : reg_operand_o  <= PWDATA;\n                    ADDRESS_CONTROL   : reg_control    <= PWDATA;\n                    ADDRESS_WDATA     : reg_wdata_sram <= PWDATA;\n                    ADDRESS_SRAM_ADDR : reg_addr_sram  <= PWDATA;\n                endcase\n            end else begin\n                if (reg_control == SRAM_READ) begin\n                    PRDATA <= sram_data_out;\n                end else begin\n                    case (PADDR)\n                        ADDRESS_A         : PRDATA <= reg_operand_a;\n                        ADDRESS_B         : PRDATA <= reg_operand_b;\n                        ADDRESS_C         : PRDATA <= reg_operand_c;\n                        ADDRESS_O         : PRDATA <= reg_operand_o;\n                        ADDRESS_CONTROL   : PRDATA <= reg_control;\n                        ADDRESS_WDATA     : PRDATA <= reg_wdata_sram;\n                        ADDRESS_SRAM_ADDR : PRDATA <= reg_addr_sram;\n                    endcase\n                end               \n            end\n        end\n    end\n\n    // SRAM logic\n    logic [DATA_WIDTH-1:0] mem [63:0];\n\n    always_comb begin\n        sram_data_in = (reg_control == SRAM_WRITE) ? reg_wdata_sram : wire_op_o;\n\n        if ((reg_control == SRAM_WRITE) || (reg_control == DSP_WRITE_OP_O)) begin\n            sram_we = 1'b1;\n        end else begin\n            sram_we = 1'b0;\n        end\n\n        case (reg_control)\n            DSP_READ_OP_A  : sram_addr = reg_operand_a;\n            DSP_READ_OP_B  : sram_addr = reg_operand_b;\n            DSP_READ_OP_C  : sram_addr = reg_operand_c;\n            DSP_WRITE_OP_O : sram_addr = reg_operand_o;\n            default        : sram_addr = reg_addr_sram;\n        endcase\n    end\n\n    always_ff @(posedge PCLK) begin\n        if (sram_we) begin\n            mem[sram_addr] <= sram_data_in;\n        end else begin\n            sram_data_out <= mem[sram_addr];\n        end\n    end\n    \n    // DSP operation\n    always_ff @(posedge dsp_clk_sel) begin\n        case (reg_control)\n            DSP_READ_OP_A  : wire_op_a <= sram_data_out;\n            DSP_READ_OP_B  : wire_op_b <= sram_data_out;\n            DSP_READ_OP_C  : wire_op_c <= sram_data_out;\n        endcase\n    end\n    \n    assign wire_op_o = (wire_op_a * wire_op_b) + wire_op_c;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_apb_dsp_unit_0001": {"input": {}, "output": {"rtl/apb_dsp_unit.v": ""}, "obj": true}}
{"cvdp_copilot_apb_gpio_0001": {"input": {}, "output": {"rtl/cvdp_copilot_apb_gpio.sv": ""}, "obj": true}}
{"cvdp_copilot_apb_gpio_0005": {"input": {"rtl/cvdp_copilot_apb_gpio.sv": "module cvdp_copilot_apb_gpio #(\n  parameter GPIO_WIDTH = 8\n)(\n  // Clock and Reset Signals\n  input logic pclk,       // Clock signal\n  input logic preset_n,   // Active-low reset signal\n\n  // APB Interface Inputs\n  input logic psel,           // Peripheral select\n  input logic [7:2] paddr,    // APB address bus (bits [7:2])\n  input logic penable,        // Transfer control signal\n  input logic pwrite,         // Write control signal\n  input logic [31:0] pwdata,  // Write data bus\n\n  // APB Interface Outputs\n  output logic [31:0] prdata, // Read data bus\n  output logic pready,        // Device ready signal\n  output logic pslverr,       // Device error response\n\n  // GPIO Interface Inputs and Outputs\n  input logic [GPIO_WIDTH-1:0] gpio_in,     // GPIO input signals\n  output logic [GPIO_WIDTH-1:0] gpio_out,   // GPIO output signals\n  output logic [GPIO_WIDTH-1:0] gpio_enable, // GPIO output enable signals\n\n  // Interrupt Outputs\n  output logic [GPIO_WIDTH-1:0] gpio_int, // Individual interrupt outputs\n  output logic comb_int                   // Combined interrupt output\n);\n\n  // Signals for Read/Write Controls\n  logic read_enable;                     // Read enable signal\n  logic write_enable;                    // Write enable signal\n  logic write_enable_reg_04;             // Write enable for Data Output register\n  logic write_enable_reg_08;             // Write enable for Output Enable register\n  logic write_enable_reg_0C;             // Write enable for Interrupt Enable register\n  logic write_enable_reg_10;             // Write enable for Interrupt Type register\n  logic write_enable_reg_14;             // Write enable for Interrupt Polarity register\n  logic write_enable_reg_18;             // Write enable for Interrupt State register\n  logic [GPIO_WIDTH-1:0] read_mux;       // Read data multiplexer\n  logic [GPIO_WIDTH-1:0] read_mux_d1;    // Registered read data\n\n  // Control Registers\n  logic [GPIO_WIDTH-1:0] reg_dout;       // Data Output register\n  logic [GPIO_WIDTH-1:0] reg_dout_en;    // Output Enable register\n  logic [GPIO_WIDTH-1:0] reg_int_en;     // Interrupt Enable register\n  logic [GPIO_WIDTH-1:0] reg_int_type;   // Interrupt Type register\n  logic [GPIO_WIDTH-1:0] reg_int_pol;    // Interrupt Polarity register\n  logic [GPIO_WIDTH-1:0] reg_int_state;  // Interrupt State register\n\n  // I/O Signal Path and Interrupt Logic\n  logic [GPIO_WIDTH-1:0] data_in_sync1;            // First stage of input synchronization\n  logic [GPIO_WIDTH-1:0] data_in_sync2;            // Second stage of input synchronization\n  logic [GPIO_WIDTH-1:0] data_in_pol_adjusted;     // Polarity-adjusted input data\n  logic [GPIO_WIDTH-1:0] data_in_pol_adjusted_dly; // Delayed version of polarity-adjusted input data\n  logic [GPIO_WIDTH-1:0] edge_detect;              // Edge detection signals\n  logic [GPIO_WIDTH-1:0] raw_int;                  // Raw interrupt signals\n  logic [GPIO_WIDTH-1:0] int_masked;               // Masked interrupt signals\n  logic [GPIO_WIDTH-1:0] clear_interrupt;          // Clear interrupt signals\n\n  // Read and Write Control Signals\n  assign read_enable = psel & (~pwrite); // Read enable\n  assign write_enable = psel & (~penable) & pwrite; // Write enable\n\n  // Write Enable Signals for Specific Registers\n  assign write_enable_reg_04 = write_enable & (paddr[7:2] == 6'd1); // Address 0x04\n  assign write_enable_reg_08 = write_enable & (paddr[7:2] == 6'd2); // Address 0x08\n  assign write_enable_reg_0C = write_enable & (paddr[7:2] == 6'd3); // Address 0x0C\n  assign write_enable_reg_10 = write_enable & (paddr[7:2] == 6'd4); // Address 0x10\n  assign write_enable_reg_14 = write_enable & (paddr[7:2] == 6'd5); // Address 0x14\n  assign write_enable_reg_18 = write_enable & (paddr[7:2] == 6'd6); // Address 0x18\n\n  // Write Operations for Control Registers\n\n  // Data Output Register (reg_dout)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      reg_dout <= {GPIO_WIDTH{1'b0}};\n    else if (write_enable_reg_04)\n      reg_dout <= pwdata[(GPIO_WIDTH-1):0];\n  end\n\n  // Output Enable Register (reg_dout_en)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      reg_dout_en <= {GPIO_WIDTH{1'b0}};\n    else if (write_enable_reg_08)\n      reg_dout_en <= pwdata[(GPIO_WIDTH-1):0];\n  end\n\n  // Interrupt Enable Register (reg_int_en)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      reg_int_en <= {GPIO_WIDTH{1'b0}};\n    else if (write_enable_reg_0C)\n      reg_int_en <= pwdata[(GPIO_WIDTH-1):0];\n  end\n\n  // Interrupt Type Register (reg_int_type)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      reg_int_type <= {GPIO_WIDTH{1'b0}};\n    else if (write_enable_reg_10)\n      reg_int_type <= pwdata[(GPIO_WIDTH-1):0];\n  end\n\n  // Interrupt Polarity Register (reg_int_pol)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      reg_int_pol <= {GPIO_WIDTH{1'b0}};\n    else if (write_enable_reg_14)\n      reg_int_pol <= pwdata[(GPIO_WIDTH-1):0];\n  end\n\n  // Read Operation: Multiplexing Register Data Based on Address\n  always_comb begin\n    case (paddr[7:2])\n      6'd0: read_mux = data_in_sync2;   // Input Data Register at address 0x00\n      6'd1: read_mux = reg_dout;        // Data Output Register at address 0x04\n      6'd2: read_mux = reg_dout_en;     // Output Enable Register at address 0x08\n      6'd3: read_mux = reg_int_en;      // Interrupt Enable Register at address 0x0C\n      6'd4: read_mux = reg_int_type;    // Interrupt Type Register at address 0x10\n      6'd5: read_mux = reg_int_pol;     // Interrupt Polarity Register at address 0x14\n      6'd6: read_mux = reg_int_state;   // Interrupt State Register at address 0x18\n      default: read_mux = {GPIO_WIDTH{1'b0}}; // Default to zeros if address is invalid\n    endcase\n  end\n\n  // Registering Read Data for Timing Alignment\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      read_mux_d1 <= {GPIO_WIDTH{1'b0}};\n    else\n      read_mux_d1 <= read_mux;\n  end\n\n  // Output Read Data to APB Interface\n  assign prdata = (read_enable) ? {{(32-GPIO_WIDTH){1'b0}}, read_mux_d1} : {32{1'b0}};\n  assign pready = 1'b1; // Always ready\n  assign pslverr = 1'b0; // No error\n\n  // Driving GPIO Outputs and Output Enables\n  assign gpio_enable = reg_dout_en; // Output enable signals\n  assign gpio_out = reg_dout;       // Output data signals\n\n  // Input Synchronization to Avoid Metastability\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n) begin\n      data_in_sync1 <= {GPIO_WIDTH{1'b0}};\n      data_in_sync2 <= {GPIO_WIDTH{1'b0}};\n    end else begin\n      data_in_sync1 <= gpio_in;\n      data_in_sync2 <= data_in_sync1;\n    end\n  end\n\n  // Interrupt Logic\n\n  // Adjusting Input Data Based on Interrupt Polarity\n  assign data_in_pol_adjusted = data_in_sync2 ^ reg_int_pol; // Polarity adjustment\n\n  // Registering Polarity-Adjusted Input Data and Delaying for Edge Detection\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n) begin\n      data_in_pol_adjusted_dly <= {GPIO_WIDTH{1'b0}};\n    end else begin\n      data_in_pol_adjusted_dly <= data_in_pol_adjusted;\n    end\n  end\n\n  // Edge Detection Logic for Interrupts\n  assign edge_detect = data_in_pol_adjusted & (~data_in_pol_adjusted_dly); // Rising edge detection\n\n  // Selecting Interrupt Type (Edge or Level-Triggered)\n  assign raw_int = (reg_int_type & edge_detect) | (~reg_int_type & data_in_pol_adjusted); // Interrupt source\n\n  // Applying Interrupt Enable Mask\n  assign int_masked = raw_int & reg_int_en; // Masked interrupts\n\n  // Clear Interrupt Signals\n  assign clear_interrupt = pwdata[GPIO_WIDTH-1:0] & {GPIO_WIDTH{write_enable_reg_18}};\n\n  // Updating Interrupt State Register (Corrected Logic)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n) begin\n      reg_int_state <= {GPIO_WIDTH{1'b0}};\n    end else begin\n      integer i;\n      for (i = 0; i < GPIO_WIDTH; i = i + 1) begin\n        if (reg_int_type[i]) begin\n          // Edge-triggered interrupt\n          if (clear_interrupt[i]) begin\n            reg_int_state[i] <= 1'b0;\n          end else if (int_masked[i]) begin\n            reg_int_state[i] <= 1'b1;\n          end\n        end else begin\n          // Level-triggered interrupt\n          reg_int_state[i] <= int_masked[i];\n        end\n      end\n    end\n  end\n\n  // Connecting Interrupt Outputs\n  assign gpio_int = reg_int_state;     // Individual interrupt outputs\n  assign comb_int = |reg_int_state;    // Combined interrupt output\n\nendmodule"}, "output": {"rtl/cvdp_copilot_apb_gpio.sv": "module cvdp_copilot_apb_gpio #(\n  parameter GPIO_WIDTH = 8\n)(\n  // Clock and Reset Signals\n  input logic pclk,       // Clock signal\n  input logic preset_n,   // Active-low reset signal\n\n  // APB Interface Inputs\n  input logic psel,           // Peripheral select\n  input logic [7:2] paddr,    // APB address bus (bits [7:2])\n  input logic penable,        // Transfer control signal\n  input logic pwrite,         // Write control signal\n  input logic [31:0] pwdata,  // Write data bus\n\n  // APB Interface Outputs\n  output logic [31:0] prdata, // Read data bus\n  output logic pready,        // Device ready signal\n  output logic pslverr,       // Device error response\n\n  // GPIO Interface Inputs and Outputs\n  input logic [GPIO_WIDTH-1:0] gpio_in,     // GPIO input signals\n  output logic [GPIO_WIDTH-1:0] gpio_out,   // GPIO output signals\n  output logic [GPIO_WIDTH-1:0] gpio_enable, // GPIO output enable signals\n\n  // Interrupt Outputs\n  output logic [GPIO_WIDTH-1:0] gpio_int, // Individual interrupt outputs\n  output logic comb_int                   // Combined interrupt output\n);\n\n  // Signals for Read/Write Controls\n  logic read_enable;                     // Read enable signal\n  logic write_enable;                    // Write enable signal\n  logic write_enable_reg_04;             // Write enable for Data Output register\n  logic write_enable_reg_08;             // Write enable for Output Enable register\n  logic write_enable_reg_0C;             // Write enable for Interrupt Enable register\n  logic write_enable_reg_10;             // Write enable for Interrupt Type register\n  logic write_enable_reg_14;             // Write enable for Interrupt Polarity register\n  logic write_enable_reg_18;             // Write enable for Interrupt State register\n  logic [GPIO_WIDTH-1:0] read_mux;       // Read data multiplexer\n  logic [GPIO_WIDTH-1:0] read_mux_d1;    // Registered read data\n\n  // Control Registers\n  logic [GPIO_WIDTH-1:0] reg_dout;       // Data Output register\n  logic [GPIO_WIDTH-1:0] reg_dout_en;    // Output Enable register\n  logic [GPIO_WIDTH-1:0] reg_int_en;     // Interrupt Enable register\n  logic [GPIO_WIDTH-1:0] reg_int_type;   // Interrupt Type register\n  logic [GPIO_WIDTH-1:0] reg_int_pol;    // Interrupt Polarity register\n  logic [GPIO_WIDTH-1:0] reg_int_state;  // Interrupt State register\n\n  // I/O Signal Path and Interrupt Logic\n  logic [GPIO_WIDTH-1:0] data_in_sync1;            // First stage of input synchronization\n  logic [GPIO_WIDTH-1:0] data_in_sync2;            // Second stage of input synchronization\n  logic [GPIO_WIDTH-1:0] data_in_pol_adjusted;     // Polarity-adjusted input data\n  logic [GPIO_WIDTH-1:0] data_in_pol_adjusted_dly; // Delayed version of polarity-adjusted input data\n  logic [GPIO_WIDTH-1:0] edge_detect;              // Edge detection signals\n  logic [GPIO_WIDTH-1:0] raw_int;                  // Raw interrupt signals\n  logic [GPIO_WIDTH-1:0] int_masked;               // Masked interrupt signals\n  logic [GPIO_WIDTH-1:0] clear_interrupt;          // Clear interrupt signals\n\n  // Read and Write Control Signals\n  assign read_enable = psel & (~pwrite); // Read enable\n  assign write_enable = psel & (~penable) & pwrite; // Write enable\n\n  // Write Enable Signals for Specific Registers\n  assign write_enable_reg_04 = write_enable & (paddr[7:2] == 6'd1); // Address 0x04\n  assign write_enable_reg_08 = write_enable & (paddr[7:2] == 6'd2); // Address 0x08\n  assign write_enable_reg_0C = write_enable & (paddr[7:2] == 6'd3); // Address 0x0C\n  assign write_enable_reg_10 = write_enable & (paddr[7:2] == 6'd4); // Address 0x10\n  assign write_enable_reg_14 = write_enable & (paddr[7:2] == 6'd5); // Address 0x14\n  assign write_enable_reg_18 = write_enable & (paddr[7:2] == 6'd6); // Address 0x18\n\n  // Write Operations for Control Registers\n\n  // Data Output Register (reg_dout)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      reg_dout <= {GPIO_WIDTH{1'b0}};\n    else if (write_enable_reg_04)\n      reg_dout <= pwdata[(GPIO_WIDTH-1):0];\n  end\n\n  // Output Enable Register (reg_dout_en)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      reg_dout_en <= {GPIO_WIDTH{1'b0}};\n    else if (write_enable_reg_08)\n      reg_dout_en <= pwdata[(GPIO_WIDTH-1):0];\n  end\n\n  // Interrupt Enable Register (reg_int_en)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      reg_int_en <= {GPIO_WIDTH{1'b0}};\n    else if (write_enable_reg_0C)\n      reg_int_en <= pwdata[(GPIO_WIDTH-1):0];\n  end\n\n  // Interrupt Type Register (reg_int_type)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      reg_int_type <= {GPIO_WIDTH{1'b0}};\n    else if (write_enable_reg_10)\n      reg_int_type <= pwdata[(GPIO_WIDTH-1):0];\n  end\n\n  // Interrupt Polarity Register (reg_int_pol)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      reg_int_pol <= {GPIO_WIDTH{1'b0}};\n    else if (write_enable_reg_14)\n      reg_int_pol <= pwdata[(GPIO_WIDTH-1):0];\n  end\n\n  // Read Operation: Multiplexing Register Data Based on Address\n  always_comb begin\n    case (paddr[7:2])\n      6'd0: read_mux = data_in_sync2;   // Input Data Register at address 0x00\n      6'd1: read_mux = reg_dout;        // Data Output Register at address 0x04\n      6'd2: read_mux = reg_dout_en;     // Output Enable Register at address 0x08\n      6'd3: read_mux = reg_int_en;      // Interrupt Enable Register at address 0x0C\n      6'd4: read_mux = reg_int_type;    // Interrupt Type Register at address 0x10\n      6'd5: read_mux = reg_int_pol;     // Interrupt Polarity Register at address 0x14\n      6'd6: read_mux = reg_int_state;   // Interrupt State Register at address 0x18\n      default: read_mux = {GPIO_WIDTH{1'b0}}; // Default to zeros if address is invalid\n    endcase\n  end\n\n  // Registering Read Data for Timing Alignment\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n)\n      read_mux_d1 <= {GPIO_WIDTH{1'b0}};\n    else\n      read_mux_d1 <= read_mux;\n  end\n\n  // Output Read Data to APB Interface\n  assign prdata = (read_enable) ? {{(32-GPIO_WIDTH){1'b0}}, read_mux_d1} : {32{1'b0}};\n  assign pready = 1'b1; // Always ready\n  assign pslverr = 1'b0; // No error\n\n  // Driving GPIO Outputs and Output Enables\n  assign gpio_enable = reg_dout_en; // Output enable signals\n  assign gpio_out = reg_dout;       // Output data signals\n\n  // Input Synchronization to Avoid Metastability\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n) begin\n      data_in_sync1 <= {GPIO_WIDTH{1'b0}};\n      data_in_sync2 <= {GPIO_WIDTH{1'b0}};\n    end else begin\n      data_in_sync1 <= gpio_in;\n      data_in_sync2 <= data_in_sync1;\n    end\n  end\n\n  // Interrupt Logic\n\n  // Adjusting Input Data Based on Interrupt Polarity\n  assign data_in_pol_adjusted = data_in_sync2 ^ reg_int_pol; // Polarity adjustment\n\n  // Registering Polarity-Adjusted Input Data and Delaying for Edge Detection\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n) begin\n      data_in_pol_adjusted_dly <= {GPIO_WIDTH{1'b0}};\n    end else begin\n      data_in_pol_adjusted_dly <= data_in_pol_adjusted;\n    end\n  end\n\n  // Edge Detection Logic for Interrupts\n  assign edge_detect = data_in_pol_adjusted & (~data_in_pol_adjusted_dly); // Rising edge detection\n\n  // Selecting Interrupt Type (Edge or Level-Triggered)\n  assign raw_int = (reg_int_type & edge_detect) | (~reg_int_type & data_in_pol_adjusted); // Interrupt source\n\n  // Applying Interrupt Enable Mask\n  assign int_masked = raw_int & reg_int_en; // Masked interrupts\n\n  // Clear Interrupt Signals\n  assign clear_interrupt = pwdata[GPIO_WIDTH-1:0] & {GPIO_WIDTH{write_enable_reg_18}};\n\n  // Updating Interrupt State Register (Corrected Logic)\n  always_ff @(posedge pclk or negedge preset_n) begin\n    if (~preset_n) begin\n      reg_int_state <= {GPIO_WIDTH{1'b0}};\n    end else begin\n      integer i;\n      for (i = 0; i < GPIO_WIDTH; i = i + 1) begin\n        if (reg_int_type[i]) begin\n          // Edge-triggered interrupt\n          if (clear_interrupt[i]) begin\n            reg_int_state[i] <= 1'b0;\n          end else if (int_masked[i]) begin\n            reg_int_state[i] <= 1'b1;\n          end\n        end else begin\n          // Level-triggered interrupt\n          reg_int_state[i] <= int_masked[i];\n        end\n      end\n    end\n  end\n\n  // Connecting Interrupt Outputs\n  assign gpio_int = reg_int_state;     // Individual interrupt outputs\n  assign comb_int = |reg_int_state;    // Combined interrupt output\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_apb_history_shift_register_0001": {"input": {}, "output": {"rtl/APBGlobalHistoryRegister.v": ""}, "obj": true}}
{"cvdp_copilot_arithmetic_progression_generator_0003": {"input": {}, "output": {"rtl/arithmetic_progression_generator.sv": ""}, "obj": true}}
{"cvdp_copilot_arithmetic_progression_generator_0015": {"input": {"rtl/arithmetic_progression_generator.sv": "module arithmetic_progression_generator #(\n    parameter DATA_WIDTH = 16,  // Width of the input data\n    parameter SEQUENCE_LENGTH = 10 // Number of terms in the progression\n)(\n    clk,\n    resetn,\n    enable,\n    start_val,\n    step_size,\n    out_val,\n    done\n);\n  // ----------------------------------------\n  // - Local parameter definition\n  // ----------------------------------------\n\n    localparam WIDTH_OUT_VAL = $clog2(SEQUENCE_LENGTH) + DATA_WIDTH; // Bit width of out_val to prevent overflow\n\n  // ----------------------------------------\n  // - Interface Definitions\n  // ----------------------------------------\n    input logic clk;                          // Clock signal\n    input logic resetn;                       // Active-low reset\n    input logic enable;                       // Enable signal for the generator\n    input logic [DATA_WIDTH-1:0] start_val;   // Start value of the sequence\n    input logic [DATA_WIDTH-1:0] step_size;   // Step size of the sequence\n    output logic [WIDTH_OUT_VAL-1:0] out_val; // Current value of the sequence\n    output logic done;                        // High when sequence generation is complete\n\n\n  // ----------------------------------------\n  // - Internal signals\n  // ----------------------------------------\n    logic [WIDTH_OUT_VAL-1:0] current_val;  // Register to hold the current value\n    logic [$clog2(SEQUENCE_LENGTH)-1:0] counter;  // Counter to track sequence length\n\n  // ----------------------------------------\n  // - Procedural block\n  // ----------------------------------------\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            current_val <= 0;\n            counter <= 0;\n            done <= 1'b0;\n        end else if (enable) begin\n            if (!done) begin\n                if (counter == 0) begin\n                    current_val <= start_val; // Initialize with start value\n                end else begin\n                    current_val <= current_val + step_size; // Compute next term\n                end\n\n                if (counter < SEQUENCE_LENGTH - 1) begin\n                    counter <= counter + 1; // Increment counter\n                end else begin\n                    done <= 1'b1; // Mark completion\n                end\n            end\n        end\n    end\n\n  // ----------------------------------------\n  // - Combinational Assignments\n  // ----------------------------------------\n    assign out_val = current_val;\n\nendmodule"}, "output": {"rtl/arithmetic_progression_generator.sv": "module arithmetic_progression_generator #(\n    parameter DATA_WIDTH = 16,  // Width of the input data\n    parameter SEQUENCE_LENGTH = 10 // Number of terms in the progression\n)(\n    clk,\n    resetn,\n    enable,\n    start_val,\n    step_size,\n    out_val,\n    done\n);\n  // ----------------------------------------\n  // - Local parameter definition\n  // ----------------------------------------\n\n    localparam WIDTH_OUT_VAL = $clog2(SEQUENCE_LENGTH) + DATA_WIDTH; // Bit width of out_val to prevent overflow\n\n  // ----------------------------------------\n  // - Interface Definitions\n  // ----------------------------------------\n    input logic clk;                          // Clock signal\n    input logic resetn;                       // Active-low reset\n    input logic enable;                       // Enable signal for the generator\n    input logic [DATA_WIDTH-1:0] start_val;   // Start value of the sequence\n    input logic [DATA_WIDTH-1:0] step_size;   // Step size of the sequence\n    output logic [WIDTH_OUT_VAL-1:0] out_val; // Current value of the sequence\n    output logic done;                        // High when sequence generation is complete\n\n\n  // ----------------------------------------\n  // - Internal signals\n  // ----------------------------------------\n    logic [WIDTH_OUT_VAL-1:0] current_val;  // Register to hold the current value\n    logic [$clog2(SEQUENCE_LENGTH)-1:0] counter;  // Counter to track sequence length\n\n  // ----------------------------------------\n  // - Procedural block\n  // ----------------------------------------\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            current_val <= 0;\n            counter <= 0;\n            done <= 1'b0;\n        end else if (enable) begin\n            if (!done) begin\n                if (counter == 0) begin\n                    current_val <= start_val; // Initialize with start value\n                end else begin\n                    current_val <= current_val + step_size; // Compute next term\n                end\n\n                if (counter < SEQUENCE_LENGTH - 1) begin\n                    counter <= counter + 1; // Increment counter\n                end else begin\n                    done <= 1'b1; // Mark completion\n                end\n            end\n        end\n    end\n\n  // ----------------------------------------\n  // - Combinational Assignments\n  // ----------------------------------------\n    assign out_val = current_val;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_async_filo_0001": {"input": {}, "output": {"rtl/async_filo.sv": ""}, "obj": true}}
{"cvdp_copilot_async_filo_0025": {"input": {"rtl/async_filo.sv": "`timescale 1ns / 1ps\n\nmodule async_filo #(\n    parameter DATA_WIDTH = 16,\n    parameter DEPTH      = 8\n) (\n    input                         w_clk,    // Write clock\n    input                         w_rst,    // Write reset\n    input                         push,     // Push signal\n    input                         r_rst,    // Read reset\n    input                         r_clk,    // Read clock\n    input                         pop,      // Pop signal\n    input        [DATA_WIDTH-1:0] w_data,   // Data input for push\n    output logic [DATA_WIDTH-1:0] r_data,   // Data output for pop\n    output logic                  r_empty,  // Empty flag\n    output logic                  w_full    // Full flag\n);\n\n  // Address width\n  localparam ADDR_WIDTH = $clog2(DEPTH);\n\n  // Address pointers\n  logic [ADDR_WIDTH:0] w_ptr;\n  logic [ADDR_WIDTH:0] r_ptr;\n  logic [ADDR_WIDTH:0] w_ptr_next;\n  logic [ADDR_WIDTH:0] r_ptr_next;\n\n  logic [DATA_WIDTH-1:0] mem[0:DEPTH-1];\n  wire [ADDR_WIDTH-1:0] w_addr;\n  wire [ADDR_WIDTH-1:0] r_addr;\n\n\n  logic w_full_d1;\n\n  logic [ADDR_WIDTH:0] w_ptr_b1;\n\n  logic r_ptr_1;\n  always @(posedge w_clk) begin\n    w_ptr <= r_ptr_1;\n  end\n\n  always @(posedge w_clk) begin\n    w_ptr <= w_ptr + 1;\n  end\n\n  always @(*) begin\n    if (push) w_full_d1 = 1;\n  end\n\n  logic [ADDR_WIDTH+1:0] w_full_f1;\n  always @(posedge w_clk) begin\n    w_full_f1 <= w_count_next_bin;\n  end\n\n  always @(posedge w_rst) begin\n    w_ptr_b1 <= w_count_bin;\n  end\n\n  always @(posedge w_clk) begin\n    if (push && !w_full) w_addr = w_addr + 1;\n  end\n\n  always @(posedge w_clk) begin\n    if (push && !w_full) mem[w_addr] <= w_data;\n  end\n\n  assign r_data = mem[r_addr];\n\n  logic [ADDR_WIDTH:0] wq1_rptr, wq2_rptr;\n  logic [ADDR_WIDTH:0] rq1_wptr, rq2_wptr;\n\n  always @(posedge w_clk, posedge w_rst) begin\n    if (w_rst) begin\n      wq1_rptr <= 0;\n      wq2_rptr <= 0;\n    end else begin\n      wq1_rptr <= r_ptr;\n      wq2_rptr <= wq1_rptr;\n    end\n  end\n\n  always @(posedge r_clk, posedge r_rst) begin\n    if (r_rst) begin\n      rq1_wptr <= 0;\n      rq2_wptr <= 0;\n    end else begin\n      rq1_wptr <= w_ptr;\n      rq2_wptr <= rq1_wptr;\n    end\n  end\n\n  always @(posedge w_clk) begin\n    if (push && !w_full) w_addr = w_addr + 1;\n  end\n\n  function automatic [ADDR_WIDTH:0] bin2gray(input [ADDR_WIDTH:0] bin);\n    bin2gray = bin ^ (bin >> 1);\n  endfunction\n\n  function automatic [ADDR_WIDTH:0] gray2bin(input [ADDR_WIDTH:0] gray);\n    gray2bin = gray;\n    for (int i = 1; i <= ADDR_WIDTH; i++) gray2bin[i] = gray2bin[i] ^ gray2bin[i-1];\n  endfunction\n\n  logic [ADDR_WIDTH:0] w_count_bin, r_count_bin;\n  wire [ADDR_WIDTH:0] w_count_next_bin, r_count_next_bin;\n  wire [ADDR_WIDTH:0] wq2_rptr_bin;\n\n  always @(posedge w_clk, posedge w_rst) begin\n    if (w_rst) begin\n      w_count_bin <= 0;\n      w_ptr       <= 0;\n    end else begin\n      w_count_bin <= w_count_next_bin;\n      w_ptr       <= w_ptr_next;\n    end\n  end\n\n  assign w_count_next_bin = w_count_bin + ({(ADDR_WIDTH+1){push}} & ~{(ADDR_WIDTH+1){w_full}});\n  assign w_ptr_next = bin2gray(w_count_next_bin);\n  assign wq2_rptr_bin = gray2bin(wq2_rptr);\n\n  always @(posedge r_clk, posedge r_rst) begin\n    if (r_rst) begin\n      r_count_bin <= 0;\n      r_ptr       <= 0;\n    end else begin\n      r_count_bin <= r_count_next_bin;\n      r_ptr       <= r_ptr_next;\n    end\n  end\n\n  assign r_count_next_bin = r_count_bin + ({(ADDR_WIDTH+1){pop}} & ~{(ADDR_WIDTH+1){r_empty}});\n  assign r_ptr_next = bin2gray(r_count_next_bin);\n\n  assign w_addr = w_count_bin[ADDR_WIDTH-1:0];\n  assign r_addr = r_count_bin[ADDR_WIDTH-1:0];\n\n  always @(posedge r_clk or posedge r_rst) begin\n    if (r_rst) begin\n      r_empty <= 1;\n    end else begin\n      r_empty <= (r_ptr_next == rq2_wptr);\n    end\n  end\n\n  always @(posedge w_clk) begin\n    case (w_ptr)\n      5'b00000: w_full_d1 <= 1;\n      5'b11111: w_full_d1 <= 0;\n      default:  w_full_d1 <= 2;\n    endcase\n  end\n  always @(posedge w_clk or posedge w_rst) begin\n    if (w_rst) begin\n      w_full <= 0;\n    end else begin\n      w_full <= (w_count_next_bin[ADDR_WIDTH] != wq2_rptr_bin[ADDR_WIDTH]) && \n                  (w_count_next_bin[ADDR_WIDTH-1:0] == wq2_rptr_bin[ADDR_WIDTH-1:0]);\n    end\n  end\n\nendmodule"}, "output": {"rtl/async_filo.sv": ""}, "obj": true}}
{"cvdp_copilot_axi_alu_0001": {"input": {"rtl/axi_alu.sv": "module axi_alu (\n    input  wire        axi_clk_in,\n    input  wire        fast_clk_in,\n    input  wire        reset_in,\n    \n    // AXI Interface\n    input  wire        axi_awvalid_i,\n    input  wire        axi_wvalid_i,\n    input  wire        axi_bready_i,\n    input  wire        axi_arvalid_i,\n    input  wire        axi_rready_i,\n    \n    output wire        axi_awready_o,\n    output wire        axi_wready_o,\n    output wire        axi_bvalid_o,\n    output wire        axi_arready_o,\n    output wire        axi_rvalid_o,\n    \n    input  wire [31:0] axi_awaddr_i,\n    input  wire [31:0] axi_wdata_i,\n    input  wire [31:0] axi_araddr_i,\n    \n    input  wire [3:0]  axi_wstrb_i,\n    output wire [31:0] axi_rdata_o,\n    output wire [63:0] result_o\n);\n    \n    wire        clk;\n    wire [31:0] operand_a, operand_b, operand_c;\n    wire [1:0]  op_select;\n    wire        start, clock_control;\n    wire [31:0] data_a;\n    wire [31:0] data_b;\n    wire [31:0] data_c;\n    \n    wire [31:0] operand_a_cdc, operand_b_cdc, operand_c_cdc;\n    wire [1:0]  op_select_cdc;\n    wire        start_cdc;\n    wire [31:0] operand_a_sync, operand_b_sync, operand_c_sync;\n    wire [1:0]  op_select_sync;\n    wire        start_sync;\n\n    clock_control u_clock_control (\n        .axi_clk_in  (axi_clk_in),\n        .fast_clk_in (fast_clk_in),\n        .clk_ctrl    (clock_control),\n        .clk         (clk)\n    );\n\n    axi_csr_block u_axi_csr_block (\n        .axi_aclk_i    (axi_clk_in),\n        .axi_areset_i  (reset_in),\n        .axi_awvalid_i   (axi_awvalid_i),\n        .axi_awready_o   (axi_awready_o),\n        .axi_awaddr_i    (axi_awaddr_i),\n        .axi_wvalid_i    (axi_wvalid_i),\n        .axi_wready_o    (axi_wready_o),\n        .axi_wdata_i     (axi_wdata_i),\n        .axi_wstrb_i     (axi_wstrb_i),\n        .axi_bvalid_o    (axi_bvalid_o),\n        .axi_bready_i    (axi_bready_i),\n        .axi_arvalid_i   (axi_arvalid_i),\n        .axi_arready_o   (axi_arready_o),\n        .axi_araddr_i    (axi_araddr_i),\n        .axi_rvalid_o    (axi_rvalid_o),\n        .axi_rready_i    (axi_rready_i),\n        .axi_rdata_o     (axi_rdata_o),\n        .operand_a     (operand_a_cdc),\n        .operand_b     (operand_b_cdc),\n        .operand_c     (operand_c_cdc),\n        .op_select     (op_select_cdc),\n        .start         (start_cdc),\n        .clock_control (clock_control)\n    );\n\n    // CDC logic is only active when clock_control is HIGH\n    assign operand_a = (clock_control) ? operand_a_sync : operand_a_cdc;\n    assign operand_b = (clock_control) ? operand_b_sync : operand_b_cdc;\n    assign operand_c = (clock_control) ? operand_c_sync : operand_c_cdc;\n    assign op_select = (clock_control) ? op_select_sync : op_select_cdc;\n    assign start     = (clock_control) ? start_sync : start_cdc;\n\n    // CDC Synchronizers (only used when fast_clk is selected)\n    cdc_synchronizer #(.WIDTH(32)) u_cdc_operand_a (.clk_src(axi_clk_in), .clk_dst(clk), .reset_in(reset_in), .data_in(operand_a_cdc), .data_out(operand_a_sync));\n    cdc_synchronizer #(.WIDTH(32)) u_cdc_operand_b (.clk_src(axi_clk_in), .clk_dst(clk), .reset_in(reset_in), .data_in(operand_b_cdc), .data_out(operand_b_sync));\n    cdc_synchronizer #(.WIDTH(32)) u_cdc_operand_c (.clk_src(axi_clk_in), .clk_dst(clk), .reset_in(reset_in), .data_in(operand_c_cdc), .data_out(operand_c_sync));\n    cdc_synchronizer #(.WIDTH(2))  u_cdc_op_select  (.clk_src(axi_clk_in), .clk_dst(clk), .reset_in(reset_in), .data_in(op_select_cdc), .data_out(op_select_sync));\n    cdc_synchronizer #(.WIDTH(1))  u_cdc_start      (.clk_src(axi_clk_in), .clk_dst(clk), .reset_in(reset_in), .data_in(start_cdc), .data_out(start_sync));\n\n    memory_block u_memory_block (\n        .clk        (clk),\n        .reset_in   (reset_in),\n        .address_a  (operand_a[5:0]),\n        .address_b  (operand_b[5:0]),\n        .address_c  (operand_c[5:0]),\n        .data_a     (data_a),\n        .data_b     (data_b),\n        .data_c     (data_c)\n    );\n\n    dsp_block u_dsp_block (\n        .clk        (clk),\n        .reset_in   (reset_in),\n        .operand_a  (data_a),\n        .operand_b  (data_b),\n        .operand_c  (data_c),\n        .op_select  (op_select),\n        .start      (start),\n        .result     (result_o)\n    );\n\nendmodule\n\n// ------------------------------------------------------------------\n// CDC Synchronizer Module (Double Flop Synchronization)\n// ------------------------------------------------------------------\nmodule cdc_synchronizer #(parameter WIDTH = 1) (\n    input wire clk_src,  // Source clock\n    input wire clk_dst,  // Destination clock\n    input wire reset_in, // Reset signal\n    input wire [WIDTH-1:0] data_in,  // Data from source domain\n    output reg [WIDTH-1:0] data_out  // Synchronized data in destination domain\n);\n    reg [WIDTH-1:0] data_sync_1, data_sync_2;\n\n    always @(posedge clk_dst or posedge reset_in) begin\n        if (reset_in) begin\n            data_sync_1 <= {WIDTH{1'b0}};\n            data_sync_2 <= {WIDTH{1'b0}};\n            data_out    <= {WIDTH{1'b0}};\n        end else begin\n            data_sync_1 <= data_in;   // First stage\n            data_sync_2 <= data_sync_1; // Second stage\n            data_out    <= data_sync_2; // Stable output\n        end\n    end\nendmodule\n\n// ------------------------------------------------------------------\n// Clock Control Module\n// ------------------------------------------------------------------\nmodule clock_control (\n    input  wire axi_clk_in,\n    input  wire fast_clk_in,\n    input  wire clk_ctrl,\n    output wire clk\n);\n    assign clk = clk_ctrl ? fast_clk_in : axi_clk_in;\nendmodule\n\n// ------------------------------------------------------------------\n// AXI-to-CSR Register Block (With Write Response Handling)\n// ------------------------------------------------------------------\nmodule axi_csr_block (\n    input  wire        axi_aclk_i,\n    input  wire        axi_areset_i,\n    \n    // AXI Write Address Channel\n    input  wire        axi_awvalid_i,\n    output reg         axi_awready_o,\n    input  wire [31:0] axi_awaddr_i,\n    \n    // AXI Write Data Channel\n    input  wire        axi_wvalid_i,\n    output reg         axi_wready_o,\n    input  wire [31:0] axi_wdata_i,\n    input  wire [3:0]  axi_wstrb_i,\n    \n    // AXI Write Response Channel (FIXED)\n    output reg         axi_bvalid_o,\n    input  wire        axi_bready_i,\n    \n    // AXI Read Address Channel\n    input  wire        axi_arvalid_i,\n    output reg         axi_arready_o,\n    input  wire [31:0] axi_araddr_i,\n    \n    // AXI Read Data Channel\n    output reg         axi_rvalid_o,\n    input  wire        axi_rready_i,\n    output reg  [31:0] axi_rdata_o,\n    \n    // CSR Outputs\n    output reg  [31:0] operand_a,\n    output reg  [31:0] operand_b,\n    output reg  [31:0] operand_c,\n    output reg  [1:0]  op_select,\n    output reg         start,\n    output reg         clock_control\n);\n    reg [31:0] csr_reg [0:4];\n\n    always @(posedge axi_aclk_i or posedge axi_areset_i) begin\n        if (axi_areset_i) begin\n            operand_a     <= 32'd0;\n            operand_b     <= 32'd0;\n            operand_c     <= 32'd0;\n            op_select     <= 2'd0;\n            start         <= 1'b0;\n            clock_control <= 1'b0;\n            axi_awready_o <= 0;\n            axi_wready_o  <= 0;\n            axi_bvalid_o  <= 0; // Set response valid\n            axi_arready_o <= 0;\n            axi_rvalid_o  <= 0;\n            axi_rdata_o   <= 32'd0;\n            csr_reg[0]    <= 32'd0;\n            csr_reg[1]    <= 32'd0;\n            csr_reg[2]    <= 32'd0;\n            csr_reg[3]    <= 32'd0;\n            csr_reg[4]    <= 32'd0;\n        end else begin\n            // Handle AXI Write\n            if (axi_awvalid_i && axi_wvalid_i) begin\n                csr_reg[axi_awaddr_i[4:2]] <= axi_wdata_i;\n                axi_awready_o <= 1;\n                axi_wready_o  <= 1;\n                axi_bvalid_o  <= 1; // Set response valid\n            end else begin\n                axi_awready_o <= 0;\n                axi_wready_o  <= 0;\n                axi_bvalid_o  <= 0; // Set response valid\n            end\n\n            // Handle Write Response\n            if (axi_bvalid_o && axi_bready_i) begin\n                axi_bvalid_o <= 0; // Clear response once acknowledged\n            end\n\n            // Handle AXI Read\n            if (axi_arvalid_i) begin\n                axi_arready_o <= 1;\n                axi_rvalid_o  <= 1;\n                axi_rdata_o    <= csr_reg[axi_araddr_i[4:2]];\n            end else begin\n                axi_arready_o <= 0;\n                axi_rvalid_o  <= 0;\n            end\n\n            // Update CSR Registers\n            operand_a     <= csr_reg[0];\n            operand_b     <= csr_reg[1];\n            operand_c     <= csr_reg[2];\n            op_select     <= csr_reg[3][1:0];\n            start         <= csr_reg[3][2];\n            clock_control <= csr_reg[4][0];\n        end\n    end\nendmodule\n\n// ------------------------------------------------------------------\n// Memory Block (ROM)\n// ------------------------------------------------------------------\nmodule memory_block (\n    input  wire        clk,\n    input  wire        reset_in,\n    input  wire [5:0]  address_a,\n    input  wire [5:0]  address_b,\n    input  wire [5:0]  address_c,\n    output wire [31:0] data_a,\n    output wire [31:0] data_b,\n    output wire [31:0] data_c\n);\n    reg [31:0] rom [0:63];\n\n    initial begin\n        $readmemh(\"../rom_data.mem\", rom);\n    end\n\n    assign data_a = (reset_in) ? 32'd0 : rom[address_a];\n    assign data_b = (reset_in) ? 32'd0 : rom[address_b];\n    assign data_c = (reset_in) ? 32'd0 : rom[address_c];\nendmodule\n\n// ------------------------------------------------------------------\n// DSP Processing Block\n// ------------------------------------------------------------------\nmodule dsp_block (\n    input  wire        clk,\n    input  wire        reset_in,\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    input  wire [31:0] operand_c,\n    input  wire [1:0]  op_select,\n    input  wire        start,\n    output reg  [63:0] result\n);\n    always @(posedge clk or posedge reset_in) begin\n        if (reset_in)\n            result <= 64'd0;\n        else begin\n            if (start) begin\n                case (op_select)\n                    2'b00: result <= (operand_a + operand_b) * operand_c;    // MAC\n                    2'b01: result <= operand_a * operand_b;    // Multiplication\n                    2'b10: result <= operand_a >> operand_b[4:0]; // Shift Right\n                    2'b11: result <= operand_b ? operand_a / operand_b : 64'hDEADDEAD; // Division (handle divide by zero)\n                endcase\n            end\n        end\n    end\nendmodule"}, "output": {"rtl/axi_alu.sv": ""}, "obj": true}}
{"cvdp_copilot_axi_register_0001": {"input": {}, "output": {"rtl/axi_register.sv": ""}, "obj": true}}
{"cvdp_copilot_axi_stream_downscale_0001": {"input": {}, "output": {"rtl/axis_resize.sv": ""}, "obj": true}}
{"cvdp_copilot_axi_stream_upscale_0001": {"input": {}, "output": {"rtl/axis_upscale.sv": ""}, "obj": true}}
{"cvdp_copilot_axi_tap_0001": {"input": {}, "output": {"rtl/axi_tap.sv": ""}, "obj": true}}
{"cvdp_copilot_axi_tap_0009": {"input": {"rtl/axi_tap.sv": "\nmodule axi_tap #(\n    parameter ADDR_WIDTH = 32, // Width of AXI4-Lite Address\n    parameter DATA_WIDTH = 32  // Width of AXI4-Lite Data\n)(\n    // Global Ports\n    input           clk_i,\n    input           rst_i,\n\n    // Master Write Address Channel (AW)\n    input           inport_awvalid_i,\n    input  [ADDR_WIDTH-1:0]   inport_awaddr_i,\n    output          inport_awready_o,\n    // Master Write Data Channel (W)\n    input           inport_wvalid_i,\n    input  [DATA_WIDTH-1:0]   inport_wdata_i,\n    input  [3:0]    inport_wstrb_i,\n    output          inport_wready_o,\n    // Master Write Response Channel (B)\n    input           inport_bready_i,\n    output          inport_bvalid_o,\n    output [1:0]    inport_bresp_o,\n    // Master Read Address Channel (AR)\n    input           inport_arvalid_i,\n    input  [ADDR_WIDTH-1:0]   inport_araddr_i,\n    output          inport_arready_o,\n    // Master Read Data Channel (R)\n    input           inport_rready_i,\n    output          inport_rvalid_o,\n    output [DATA_WIDTH-1:0]   inport_rdata_o,\n    output [1:0]    inport_rresp_o,\n\n    // Default AXI outport\n    // Write Address Channel (AW)\n    input           outport_awready_i,\n    output          outport_awvalid_o,\n    output [ADDR_WIDTH-1:0]   outport_awaddr_o,\n    // Write Data Channel (W)\n    input           outport_wready_i,\n    output          outport_wvalid_o,\n    output [DATA_WIDTH-1:0]   outport_wdata_o,\n    output [3:0]    outport_wstrb_o,\n    // Write Response Channel (B)\n    input           outport_bvalid_i,\n    input  [1:0]    outport_bresp_i,\n    output          outport_bready_o,\n    // Read Address Channel (AR)\n    input           outport_arready_i,\n    output          outport_arvalid_o,\n    output [ADDR_WIDTH-1:0]   outport_araddr_o,\n    // Read Data Channel (R)\n    input           outport_rvalid_i,\n    input  [DATA_WIDTH-1:0]   outport_rdata_i,\n    input  [1:0]    outport_rresp_i,\n    output          outport_rready_o,\n\n    // Peripheral 0 interface\n    // Write Address Channel (AW)\n    input           outport_peripheral0_awready_i,\n    output          outport_peripheral0_awvalid_o,\n    output [ADDR_WIDTH-1:0]   outport_peripheral0_awaddr_o,\n    // Write Data Channel (W)\n    input           outport_peripheral0_wready_i,\n    output          outport_peripheral0_wvalid_o,\n    output [DATA_WIDTH-1:0]   outport_peripheral0_wdata_o,\n    output [3:0]    outport_peripheral0_wstrb_o,\n    // Write Response Channel (B)\n    input  [1:0]    outport_peripheral0_bresp_i,\n    input           outport_peripheral0_bvalid_i,\n    output          outport_peripheral0_bready_o,\n    // Read Address Channel (AR)\n    input           outport_peripheral0_arready_i,\n    output          outport_peripheral0_arvalid_o,\n    output [ADDR_WIDTH-1:0]   outport_peripheral0_araddr_o,\n    // Read Data Channel (R)\n    input  [1:0]    outport_peripheral0_rresp_i,\n    input           outport_peripheral0_rvalid_i,\n    input  [DATA_WIDTH-1:0]   outport_peripheral0_rdata_i,\n    output          outport_peripheral0_rready_o\n);\n\n`define ADDR_SEL_W           1\n`define PERIPH0_ADDR         32'h80000000\n`define PERIPH0_MASK         32'h80000000\n\n//-----------------------------------------------------------------\n// AXI: Read\n//-----------------------------------------------------------------\nreg [3:0]              read_pending_q;\nreg [3:0]              read_pending_r;\nreg [`ADDR_SEL_W-1:0]  read_port_q;\nreg [`ADDR_SEL_W-1:0]  read_port_r;\n\nalways @ *\nbegin\n    read_port_r = `ADDR_SEL_W'b0;\n    if ((inport_araddr_i & `PERIPH0_MASK) == `PERIPH0_ADDR) read_port_r = `ADDR_SEL_W'd1;\nend\n\nwire read_incr_w = (inport_arvalid_i && inport_arready_o);\nwire read_decr_w = (inport_rvalid_o && inport_rready_i);\n\nalways @ *\nbegin\n    read_pending_r = read_pending_q;\n\n    if (read_incr_w && !read_decr_w)\n        read_pending_r = read_pending_r + 4'd1;\n    else if (!read_incr_w && read_decr_w)\n        read_pending_r = read_pending_r - 4'd1;\nend\n\nalways @ (posedge clk_i )\nif (rst_i)\nbegin\n    read_pending_q <= 4'b0;\n    read_port_q    <= `ADDR_SEL_W'b0;\nend\nelse \nbegin\n    read_pending_q <= read_pending_r;\n\n    // Read command accepted\n    if (inport_arvalid_i && inport_arready_o)\n    begin\n        read_port_q <= read_port_r;\n    end\nend\n\nwire read_accept_w       = (read_port_q == read_port_r && read_pending_q != 4'hF) || (read_pending_q == 4'h0);\n\nassign outport_arvalid_o = inport_arvalid_i & read_accept_w & (read_port_r == `ADDR_SEL_W'd0);\nassign outport_araddr_o  = inport_araddr_i;\nassign outport_rready_o  = inport_rready_i;\n\nassign outport_peripheral0_arvalid_o = inport_arvalid_i & read_accept_w & (read_port_r == `ADDR_SEL_W'd1);\nassign outport_peripheral0_araddr_o  = inport_araddr_i;\nassign outport_peripheral0_rready_o  = inport_rready_i;\n\nreg        outport_rvalid_r;\nreg [DATA_WIDTH-1:0] outport_rdata_r;\nreg [1:0]  outport_rresp_r;\n\nalways @ *\nbegin\n    case (read_port_q)\n    `ADDR_SEL_W'd1:\n    begin\n        outport_rvalid_r = outport_peripheral0_rvalid_i;\n        outport_rdata_r  = outport_peripheral0_rdata_i;\n        outport_rresp_r  = outport_peripheral0_rresp_i;\n    end\n    default:\n    begin\n        outport_rvalid_r = outport_rvalid_i;\n        outport_rdata_r  = outport_rdata_i;\n        outport_rresp_r  = outport_rresp_i;\n    end\n    endcase\nend\n\nassign inport_rvalid_o  = outport_rvalid_r;\nassign inport_rdata_o   = outport_rdata_r;\nassign inport_rresp_o   = outport_rresp_r;\n\nreg inport_arready_r;\nalways @ *\nbegin\n    case (read_port_r)\n    `ADDR_SEL_W'd1:\n        inport_arready_r = outport_peripheral0_arready_i;\n    default:\n        inport_arready_r = outport_arready_i;\n    endcase\nend\n\nassign inport_arready_o = read_accept_w & inport_arready_r;\n\n//-------------------------------------------------------------\n// Write Request\n//-------------------------------------------------------------\nreg awvalid_q;\nreg wvalid_q;\n\nwire wr_cmd_accepted_w  = (inport_awvalid_i && inport_awready_o) || awvalid_q;\nwire wr_data_accepted_w = (inport_wvalid_i  && inport_wready_o)  || wvalid_q;\n\nalways @ (posedge clk_i )\nif (rst_i)\n    awvalid_q <= 1'b0;\nelse if (inport_awvalid_i && inport_awready_o && (!wr_data_accepted_w))\n    awvalid_q <= 1'b1;\nelse if (wr_data_accepted_w)\n    awvalid_q <= 1'b0;\n\nalways @ (posedge clk_i )\nif (rst_i)\n    wvalid_q <= 1'b0;\nelse if (inport_wvalid_i && inport_wready_o && !wr_cmd_accepted_w)\n    wvalid_q <= 1'b1;\nelse if (wr_cmd_accepted_w)\n    wvalid_q <= 1'b0;\n\n//-----------------------------------------------------------------\n// AXI: Write\n//-----------------------------------------------------------------\nreg [3:0]              write_pending_q;\nreg [3:0]              write_pending_r;\nreg [`ADDR_SEL_W-1:0]  write_port_q;\nreg [`ADDR_SEL_W-1:0]  write_port_r;\n\nalways @ *\nbegin    \n    if (inport_awvalid_i & ~awvalid_q)\n    begin\n        write_port_r = `ADDR_SEL_W'b0;\n        if ((inport_awaddr_i & `PERIPH0_MASK) == `PERIPH0_ADDR) write_port_r = `ADDR_SEL_W'd1;\n    end\n    else\n        write_port_r = write_port_q;\nend\n\nwire write_incr_w = (inport_awvalid_i && inport_awready_o);\nwire write_decr_w = (inport_bvalid_o  && inport_bready_i);\n\nalways @ *\nbegin\n    write_pending_r = write_pending_q;\n\n    if (write_incr_w && !write_decr_w)\n        write_pending_r = write_pending_r + 4'd1;\n    else if (!write_incr_w && write_decr_w)\n        write_pending_r = write_pending_r - 4'd1;\nend\n\nalways @ (posedge clk_i )\nif (rst_i)\nbegin\n    write_pending_q <= 4'b0;\n    write_port_q    <= `ADDR_SEL_W'b0;\nend\nelse \nbegin\n    write_pending_q <= write_pending_r;\n\n    // Write command accepted\n    if (inport_awvalid_i && inport_awready_o)\n    begin\n        write_port_q <= write_port_r;\n    end\nend\n\nwire write_accept_w      = (write_port_q == write_port_r && write_pending_q != 4'hF) || (write_pending_q == 4'h0);\n\nassign outport_awvalid_o = inport_awvalid_i & ~awvalid_q & write_accept_w & (write_port_r == `ADDR_SEL_W'd0);\nassign outport_awaddr_o  = inport_awaddr_i;\nassign outport_wvalid_o  = inport_wvalid_i & ~wvalid_q & (inport_awvalid_i || awvalid_q) & (write_port_r == `ADDR_SEL_W'd0);\nassign outport_wdata_o   = inport_wdata_i;\nassign outport_wstrb_o   = inport_wstrb_i;\nassign outport_bready_o  = inport_bready_i;\n\nassign outport_peripheral0_awvalid_o = inport_awvalid_i & ~awvalid_q & write_accept_w & (write_port_r == `ADDR_SEL_W'd1);\nassign outport_peripheral0_awaddr_o  = inport_awaddr_i;\nassign outport_peripheral0_wvalid_o  = inport_wvalid_i & ~wvalid_q & ((inport_awvalid_i && write_accept_w) || awvalid_q) & (write_port_r == `ADDR_SEL_W'd1);\nassign outport_peripheral0_wdata_o   = inport_wdata_i;\nassign outport_peripheral0_wstrb_o   = inport_wstrb_i;\nassign outport_peripheral0_bready_o  = inport_bready_i;\n\nreg        outport_bvalid_r;\nreg [1:0]  outport_bresp_r;\n\nalways @ *\nbegin\n    case (write_port_q)\n    `ADDR_SEL_W'd1:\n    begin\n        outport_bvalid_r = outport_peripheral0_bvalid_i;\n        outport_bresp_r  = outport_peripheral0_bresp_i;\n    end\n    default:\n    begin\n        outport_bvalid_r = outport_bvalid_i;\n        outport_bresp_r  = outport_bresp_i;\n    end\n    endcase\nend\n\nassign inport_bvalid_o  = outport_bvalid_r;\nassign inport_bresp_o   = outport_bresp_r;\n\nreg inport_awready_r;\nreg inport_wready_r;\n\nalways @ *\nbegin\n    case (write_port_r)\n    `ADDR_SEL_W'd1:\n    begin\n        inport_awready_r = outport_peripheral0_awready_i;\n        inport_wready_r  = outport_peripheral0_wready_i;\n    end\n    default:\n    begin\n        inport_awready_r = outport_awready_i;\n        inport_wready_r  = outport_wready_i;\n    end        \n    endcase\nend\n\nassign inport_awready_o = write_accept_w & ~awvalid_q & inport_awready_r;\nassign inport_wready_o  = write_accept_w & ~wvalid_q & inport_wready_r;\n\n\nendmodule"}, "output": {"rtl/axi_tap.sv": "\nmodule axi_tap #(\n    parameter ADDR_WIDTH = 32, // Width of AXI4-Lite Address\n    parameter DATA_WIDTH = 32  // Width of AXI4-Lite Data\n)(\n    // Global Ports\n    input           clk_i,\n    input           rst_i,\n\n    // Master Write Address Channel (AW)\n    input           inport_awvalid_i,\n    input  [ADDR_WIDTH-1:0]   inport_awaddr_i,\n    output          inport_awready_o,\n    // Master Write Data Channel (W)\n    input           inport_wvalid_i,\n    input  [DATA_WIDTH-1:0]   inport_wdata_i,\n    input  [3:0]    inport_wstrb_i,\n    output          inport_wready_o,\n    // Master Write Response Channel (B)\n    input           inport_bready_i,\n    output          inport_bvalid_o,\n    output [1:0]    inport_bresp_o,\n    // Master Read Address Channel (AR)\n    input           inport_arvalid_i,\n    input  [ADDR_WIDTH-1:0]   inport_araddr_i,\n    output          inport_arready_o,\n    // Master Read Data Channel (R)\n    input           inport_rready_i,\n    output          inport_rvalid_o,\n    output [DATA_WIDTH-1:0]   inport_rdata_o,\n    output [1:0]    inport_rresp_o,\n\n    // Default AXI outport\n    // Write Address Channel (AW)\n    input           outport_awready_i,\n    output          outport_awvalid_o,\n    output [ADDR_WIDTH-1:0]   outport_awaddr_o,\n    // Write Data Channel (W)\n    input           outport_wready_i,\n    output          outport_wvalid_o,\n    output [DATA_WIDTH-1:0]   outport_wdata_o,\n    output [3:0]    outport_wstrb_o,\n    // Write Response Channel (B)\n    input           outport_bvalid_i,\n    input  [1:0]    outport_bresp_i,\n    output          outport_bready_o,\n    // Read Address Channel (AR)\n    input           outport_arready_i,\n    output          outport_arvalid_o,\n    output [ADDR_WIDTH-1:0]   outport_araddr_o,\n    // Read Data Channel (R)\n    input           outport_rvalid_i,\n    input  [DATA_WIDTH-1:0]   outport_rdata_i,\n    input  [1:0]    outport_rresp_i,\n    output          outport_rready_o,\n\n    // Peripheral 0 interface\n    // Write Address Channel (AW)\n    input           outport_peripheral0_awready_i,\n    output          outport_peripheral0_awvalid_o,\n    output [ADDR_WIDTH-1:0]   outport_peripheral0_awaddr_o,\n    // Write Data Channel (W)\n    input           outport_peripheral0_wready_i,\n    output          outport_peripheral0_wvalid_o,\n    output [DATA_WIDTH-1:0]   outport_peripheral0_wdata_o,\n    output [3:0]    outport_peripheral0_wstrb_o,\n    // Write Response Channel (B)\n    input  [1:0]    outport_peripheral0_bresp_i,\n    input           outport_peripheral0_bvalid_i,\n    output          outport_peripheral0_bready_o,\n    // Read Address Channel (AR)\n    input           outport_peripheral0_arready_i,\n    output          outport_peripheral0_arvalid_o,\n    output [ADDR_WIDTH-1:0]   outport_peripheral0_araddr_o,\n    // Read Data Channel (R)\n    input  [1:0]    outport_peripheral0_rresp_i,\n    input           outport_peripheral0_rvalid_i,\n    input  [DATA_WIDTH-1:0]   outport_peripheral0_rdata_i,\n    output          outport_peripheral0_rready_o\n);\n\n`define ADDR_SEL_W           1\n`define PERIPH0_ADDR         32'h80000000\n`define PERIPH0_MASK         32'h80000000\n\n//-----------------------------------------------------------------\n// AXI: Read\n//-----------------------------------------------------------------\nreg [3:0]              read_pending_q;\nreg [3:0]              read_pending_r;\nreg [`ADDR_SEL_W-1:0]  read_port_q;\nreg [`ADDR_SEL_W-1:0]  read_port_r;\n\nalways @ *\nbegin\n    read_port_r = `ADDR_SEL_W'b0;\n    if ((inport_araddr_i & `PERIPH0_MASK) == `PERIPH0_ADDR) read_port_r = `ADDR_SEL_W'd1;\nend\n\nwire read_incr_w = (inport_arvalid_i && inport_arready_o);\nwire read_decr_w = (inport_rvalid_o && inport_rready_i);\n\nalways @ *\nbegin\n    read_pending_r = read_pending_q;\n\n    if (read_incr_w && !read_decr_w)\n        read_pending_r = read_pending_r + 4'd1;\n    else if (!read_incr_w && read_decr_w)\n        read_pending_r = read_pending_r - 4'd1;\nend\n\nalways @ (posedge clk_i )\nif (rst_i)\nbegin\n    read_pending_q <= 4'b0;\n    read_port_q    <= `ADDR_SEL_W'b0;\nend\nelse \nbegin\n    read_pending_q <= read_pending_r;\n\n    // Read command accepted\n    if (inport_arvalid_i && inport_arready_o)\n    begin\n        read_port_q <= read_port_r;\n    end\nend\n\nwire read_accept_w       = (read_port_q == read_port_r && read_pending_q != 4'hF) || (read_pending_q == 4'h0);\n\nassign outport_arvalid_o = inport_arvalid_i & read_accept_w & (read_port_r == `ADDR_SEL_W'd0);\nassign outport_araddr_o  = inport_araddr_i;\nassign outport_rready_o  = inport_rready_i;\n\nassign outport_peripheral0_arvalid_o = inport_arvalid_i & read_accept_w & (read_port_r == `ADDR_SEL_W'd1);\nassign outport_peripheral0_araddr_o  = inport_araddr_i;\nassign outport_peripheral0_rready_o  = inport_rready_i;\n\nreg        outport_rvalid_r;\nreg [DATA_WIDTH-1:0] outport_rdata_r;\nreg [1:0]  outport_rresp_r;\n\nalways @ *\nbegin\n    case (read_port_q)\n    `ADDR_SEL_W'd1:\n    begin\n        outport_rvalid_r = outport_peripheral0_rvalid_i;\n        outport_rdata_r  = outport_peripheral0_rdata_i;\n        outport_rresp_r  = outport_peripheral0_rresp_i;\n    end\n    default:\n    begin\n        outport_rvalid_r = outport_rvalid_i;\n        outport_rdata_r  = outport_rdata_i;\n        outport_rresp_r  = outport_rresp_i;\n    end\n    endcase\nend\n\nassign inport_rvalid_o  = outport_rvalid_r;\nassign inport_rdata_o   = outport_rdata_r;\nassign inport_rresp_o   = outport_rresp_r;\n\nreg inport_arready_r;\nalways @ *\nbegin\n    case (read_port_r)\n    `ADDR_SEL_W'd1:\n        inport_arready_r = outport_peripheral0_arready_i;\n    default:\n        inport_arready_r = outport_arready_i;\n    endcase\nend\n\nassign inport_arready_o = read_accept_w & inport_arready_r;\n\n//-------------------------------------------------------------\n// Write Request\n//-------------------------------------------------------------\nreg awvalid_q;\nreg wvalid_q;\n\nwire wr_cmd_accepted_w  = (inport_awvalid_i && inport_awready_o) || awvalid_q;\nwire wr_data_accepted_w = (inport_wvalid_i  && inport_wready_o)  || wvalid_q;\n\nalways @ (posedge clk_i )\nif (rst_i)\n    awvalid_q <= 1'b0;\nelse if (inport_awvalid_i && inport_awready_o && (!wr_data_accepted_w))\n    awvalid_q <= 1'b1;\nelse if (wr_data_accepted_w)\n    awvalid_q <= 1'b0;\n\nalways @ (posedge clk_i )\nif (rst_i)\n    wvalid_q <= 1'b0;\nelse if (inport_wvalid_i && inport_wready_o && !wr_cmd_accepted_w)\n    wvalid_q <= 1'b1;\nelse if (wr_cmd_accepted_w)\n    wvalid_q <= 1'b0;\n\n//-----------------------------------------------------------------\n// AXI: Write\n//-----------------------------------------------------------------\nreg [3:0]              write_pending_q;\nreg [3:0]              write_pending_r;\nreg [`ADDR_SEL_W-1:0]  write_port_q;\nreg [`ADDR_SEL_W-1:0]  write_port_r;\n\nalways @ *\nbegin    \n    if (inport_awvalid_i & ~awvalid_q)\n    begin\n        write_port_r = `ADDR_SEL_W'b0;\n        if ((inport_awaddr_i & `PERIPH0_MASK) == `PERIPH0_ADDR) write_port_r = `ADDR_SEL_W'd1;\n    end\n    else\n        write_port_r = write_port_q;\nend\n\nwire write_incr_w = (inport_awvalid_i && inport_awready_o);\nwire write_decr_w = (inport_bvalid_o  && inport_bready_i);\n\nalways @ *\nbegin\n    write_pending_r = write_pending_q;\n\n    if (write_incr_w && !write_decr_w)\n        write_pending_r = write_pending_r + 4'd1;\n    else if (!write_incr_w && write_decr_w)\n        write_pending_r = write_pending_r - 4'd1;\nend\n\nalways @ (posedge clk_i )\nif (rst_i)\nbegin\n    write_pending_q <= 4'b0;\n    write_port_q    <= `ADDR_SEL_W'b0;\nend\nelse \nbegin\n    write_pending_q <= write_pending_r;\n\n    // Write command accepted\n    if (inport_awvalid_i && inport_awready_o)\n    begin\n        write_port_q <= write_port_r;\n    end\nend\n\nwire write_accept_w      = (write_port_q == write_port_r && write_pending_q != 4'hF) || (write_pending_q == 4'h0);\n\nassign outport_awvalid_o = inport_awvalid_i & ~awvalid_q & write_accept_w & (write_port_r == `ADDR_SEL_W'd0);\nassign outport_awaddr_o  = inport_awaddr_i;\nassign outport_wvalid_o  = inport_wvalid_i & ~wvalid_q & (inport_awvalid_i || awvalid_q) & (write_port_r == `ADDR_SEL_W'd0);\nassign outport_wdata_o   = inport_wdata_i;\nassign outport_wstrb_o   = inport_wstrb_i;\nassign outport_bready_o  = inport_bready_i;\n\nassign outport_peripheral0_awvalid_o = inport_awvalid_i & ~awvalid_q & write_accept_w & (write_port_r == `ADDR_SEL_W'd1);\nassign outport_peripheral0_awaddr_o  = inport_awaddr_i;\nassign outport_peripheral0_wvalid_o  = inport_wvalid_i & ~wvalid_q & ((inport_awvalid_i && write_accept_w) || awvalid_q) & (write_port_r == `ADDR_SEL_W'd1);\nassign outport_peripheral0_wdata_o   = inport_wdata_i;\nassign outport_peripheral0_wstrb_o   = inport_wstrb_i;\nassign outport_peripheral0_bready_o  = inport_bready_i;\n\nreg        outport_bvalid_r;\nreg [1:0]  outport_bresp_r;\n\nalways @ *\nbegin\n    case (write_port_q)\n    `ADDR_SEL_W'd1:\n    begin\n        outport_bvalid_r = outport_peripheral0_bvalid_i;\n        outport_bresp_r  = outport_peripheral0_bresp_i;\n    end\n    default:\n    begin\n        outport_bvalid_r = outport_bvalid_i;\n        outport_bresp_r  = outport_bresp_i;\n    end\n    endcase\nend\n\nassign inport_bvalid_o  = outport_bvalid_r;\nassign inport_bresp_o   = outport_bresp_r;\n\nreg inport_awready_r;\nreg inport_wready_r;\n\nalways @ *\nbegin\n    case (write_port_r)\n    `ADDR_SEL_W'd1:\n    begin\n        inport_awready_r = outport_peripheral0_awready_i;\n        inport_wready_r  = outport_peripheral0_wready_i;\n    end\n    default:\n    begin\n        inport_awready_r = outport_awready_i;\n        inport_wready_r  = outport_wready_i;\n    end        \n    endcase\nend\n\nassign inport_awready_o = write_accept_w & ~awvalid_q & inport_awready_r;\nassign inport_wready_o  = write_accept_w & ~wvalid_q & inport_wready_r;\n\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_axil_precision_counter_0001": {"input": {}, "output": {"rtl/precision_counter_axi.sv": ""}, "obj": true}}
{"cvdp_copilot_axis_border_gen_0001": {"input": {}, "output": {"rtl/axis_image_border_gen.sv": ""}, "obj": true}}
{"cvdp_copilot_axis_border_gen_0014": {"input": {}, "output": {"rtl/axis_border_gen_with_resize.sv": "", "rtl/axis_image_border_gen.sv": "", "rtl/axis_image_resizer.sv": ""}, "obj": true}}
{"cvdp_copilot_axis_joiner_0001": {"input": {}, "output": {"rtl/axis_joiner.sv": ""}, "obj": true}}
{"cvdp_copilot_axis_mux_0001": {"input": {}, "output": {"rtl/axis_mux.sv": ""}, "obj": true}}
{"cvdp_copilot_barrel_shifter_0001": {"input": {}, "output": {"rtl/barrel_shifter_8bit.sv": ""}, "obj": true}}
{"cvdp_copilot_barrel_shifter_0037": {"input": {"rtl/barrel_shifter_8bit.sv": "module barrel_shifter_8bit(input [7:0]data_in,input [2:0] shift_bits, input left_right, output [7:0]data_out);\nassign data_out = left_right ? (data_in << shift_bits) : (data_in >> shift_bits);\nendmodule\n  "}, "output": {"rtl/barrel_shifter.sv": ""}, "obj": true}}
{"cvdp_copilot_barrel_shifter_0054": {"input": {"rtl/barrel_shifter.sv": "module barrel_shifter #(\n    parameter data_width = 16,      // Change data_width to 16\n    parameter shift_bits_width = 4  // Update shift_bits_width to handle shifts for 16-bit width\n)(\n    input [data_width-1:0] data_in,\n    input [shift_bits_width-1:0] shift_bits,\n    input left_right,               // 1: left shift, 0: right shift\n    input rotate_left_right,        // 1: rotate, 0: shift\n    input arithmetic_shift,         // 1: arithmetic shift, 0: logical shift\n    output reg [data_width-1:0] data_out\n);\n\nalways @(*) begin\n    if (rotate_left_right) begin\n        // Rotation logic\n        if (left_right)\n            data_out = (data_in << shift_bits) | (data_in >> (data_width - shift_bits)); // Rotate left\n        else\n            data_out = (data_in >> shift_bits) | (data_in << (data_width - shift_bits)); // Rotate right\n    end else begin\n        // Shift logic\n        if (left_right)\n            data_out = data_in << shift_bits;  // Left shift\n        else if (arithmetic_shift)\n            // Arithmetic right shift: explicitly sign-extend data_in to ensure the MSB (sign bit) is preserved\n            data_out = $signed(data_in) >>> shift_bits;\n        else\n            data_out = data_in >> shift_bits;  // Logical right shift\n    end\nend\n\nendmodule"}, "output": {"rtl/barrel_shifter.sv": "module barrel_shifter #(\n    parameter data_width = 16,      // Change data_width to 16\n    parameter shift_bits_width = 4  // Update shift_bits_width to handle shifts for 16-bit width\n)(\n    input [data_width-1:0] data_in,\n    input [shift_bits_width-1:0] shift_bits,\n    input left_right,               // 1: left shift, 0: right shift\n    input rotate_left_right,        // 1: rotate, 0: shift\n    input arithmetic_shift,         // 1: arithmetic shift, 0: logical shift\n    output reg [data_width-1:0] data_out\n);\n\nalways @(*) begin\n    if (rotate_left_right) begin\n        // Rotation logic\n        if (left_right)\n            data_out = (data_in << shift_bits) | (data_in >> (data_width - shift_bits)); // Rotate left\n        else\n            data_out = (data_in >> shift_bits) | (data_in << (data_width - shift_bits)); // Rotate right\n    end else begin\n        // Shift logic\n        if (left_right)\n            data_out = data_in << shift_bits;  // Left shift\n        else if (arithmetic_shift)\n            // Arithmetic right shift: explicitly sign-extend data_in to ensure the MSB (sign bit) is preserved\n            data_out = $signed(data_in) >>> shift_bits;\n        else\n            data_out = data_in >> shift_bits;  // Logical right shift\n    end\nend\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_barrel_shifter_0058": {"input": {"rtl/barrel_shifter.sv": "module barrel_shifter #(\n    parameter data_width = 16,     \n    parameter shift_bits_width = 4  \n)(\n    input [data_width-1:0] data_in,\n    input [shift_bits_width-1:0] shift_bits,\n    input [2:0] mode,               \n    input left_right,              \n    input [data_width-1:0] mask,   \n    output reg [data_width-1:0] data_out,\n    output reg error                \n);\n\nalways @(*) begin\n    error = 0;  \n    case (mode)\n        3'b000: begin\n            if (left_right)\n                data_out = data_in << shift_bits;  \n            else\n                data_out = data_in >> shift_bits; \n        end\n        3'b001: begin\n            if (left_right) \n                data_out = data_in << shift_bits; \n            else\n                data_out = $signed(data_in) >>> shift_bits; \n        end\n        3'b010: begin\n            if (left_right)\n                data_out = (data_in << shift_bits) | (data_in >> (data_width - shift_bits)); \n            else\n                data_out = (data_in >> shift_bits) | (data_in << (data_width - shift_bits));  \n        end\n        3'b011: begin\n            if (left_right)\n                data_out = (data_in << shift_bits) & mask;  \n            else\n                data_out = (data_in >> shift_bits) & mask; \n        end\n        3'b100: begin\n            if (left_right)\n                data_out = (data_in << shift_bits) ^ mask; \n            else\n                data_out = (data_in >> shift_bits) ^ mask; \n        end\n        default: begin\n            data_out = {data_width{1'b0}}; \n            error = 1; \n        end\n    endcase\nend\n\nendmodule"}, "output": {"rtl/barrel_shifter.sv": "module barrel_shifter #(\n    parameter data_width = 16,     \n    parameter shift_bits_width = 4  \n)(\n    input [data_width-1:0] data_in,\n    input [shift_bits_width-1:0] shift_bits,\n    input [2:0] mode,               \n    input left_right,              \n    input [data_width-1:0] mask,   \n    output reg [data_width-1:0] data_out,\n    output reg error                \n);\n\nalways @(*) begin\n    error = 0;  \n    case (mode)\n        3'b000: begin\n            if (left_right)\n                data_out = data_in << shift_bits;  \n            else\n                data_out = data_in >> shift_bits; \n        end\n        3'b001: begin\n            if (left_right) \n                data_out = data_in << shift_bits; \n            else\n                data_out = $signed(data_in) >>> shift_bits; \n        end\n        3'b010: begin\n            if (left_right)\n                data_out = (data_in << shift_bits) | (data_in >> (data_width - shift_bits)); \n            else\n                data_out = (data_in >> shift_bits) | (data_in << (data_width - shift_bits));  \n        end\n        3'b011: begin\n            if (left_right)\n                data_out = (data_in << shift_bits) & mask;  \n            else\n                data_out = (data_in >> shift_bits) & mask; \n        end\n        3'b100: begin\n            if (left_right)\n                data_out = (data_in << shift_bits) ^ mask; \n            else\n                data_out = (data_in >> shift_bits) ^ mask; \n        end\n        default: begin\n            data_out = {data_width{1'b0}}; \n            error = 1; \n        end\n    endcase\nend\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_barrel_shifter_0064": {"input": {"rtl/barrel_shifter.sv": "module barrel_shifter #(\n    parameter data_width = 16,     \n    parameter shift_bits_width = 4  \n)(\n    input [data_width-1:0] data_in,\n    input [shift_bits_width-1:0] shift_bits,\n    input [2:0] mode,             \n    input left_right,              \n    input [data_width-1:0] mask,   \n    input enable,                  \n    input enable_parity,           \n    output reg [data_width-1:0] data_out,\n    output reg parity_out,        \n    output reg error               \n);\n\nalways @(*) begin\n    if (!enable) begin\n        data_out = data_out;  \n        error = 0;      \n        parity_out = 0;      \n    end else begin\n        error = 0;  \n        case (mode)\n            3'b000: begin  \n                if (shift_bits >= data_width) begin\n                    error = 1;  \n                    data_out = {data_width{1'b0}};\n                end else if (left_right) begin\n                    data_out = data_in << shift_bits;  \n                end else begin\n                    data_out = data_in >> shift_bits;  \n                end\n            end\n            3'b001: begin  \n                if (shift_bits >= data_width) begin\n                    error = 1;  \n                    data_out = {data_width{1'b0}};\n                end else if (left_right) begin\n                    data_out = data_in << shift_bits;  \n                end else begin\n                    data_out = $signed(data_in) >>> shift_bits; \n                end\n            end\n            3'b010: begin \n                if (shift_bits >= data_width) begin\n                    error = 1;  \n                    data_out = {data_width{1'b0}};\n                end else if (left_right) begin\n                    data_out = (data_in << shift_bits) | (data_in >> (data_width - shift_bits)); \n                end else begin\n                    data_out = (data_in >> shift_bits) | (data_in << (data_width - shift_bits));  \n                end\n            end\n            3'b011: begin  \n                if (shift_bits >= data_width) begin\n                    error = 1;  \n                    data_out = {data_width{1'b0}};\n                end else if (left_right) begin\n                    data_out = (data_in << shift_bits) & mask;  \n                end else begin\n                    data_out = (data_in >> shift_bits) & mask;  \n                end\n            end\n            3'b100: begin \n                if (left_right) begin\n                    data_out = data_in + shift_bits;  \n                end else begin\n                    data_out = data_in - shift_bits;  \n                end\n            end\n            3'b101: begin  \n                data_out = 0;\n                for (int i = data_width-1; i >= 0; i = i - 1) begin\n                    if (data_in[i] == 1 && data_out == 0) begin\n                        data_out = i;  \n                    end\n                end\n            end\n            3'b110: begin \n                if (left_right) begin\n                    data_out = (data_in + shift_bits) % data_width; \n                end else begin\n                    data_out = (data_in - shift_bits) % data_width; \n                end\n            end\n            default: begin\n                data_out = {data_width{1'b0}}; \n                error = 1;  \n            end\n        endcase\n    end\n\n    if (enable_parity) begin\n        parity_out = ^data_out; \n    end else begin\n        parity_out = 0;        \n    end\nend\n\nendmodule"}, "output": {"rtl/barrel_shifter.sv": "module barrel_shifter #(\n    parameter data_width = 16,     \n    parameter shift_bits_width = 4  \n)(\n    input [data_width-1:0] data_in,\n    input [shift_bits_width-1:0] shift_bits,\n    input [2:0] mode,             \n    input left_right,              \n    input [data_width-1:0] mask,   \n    input enable,                  \n    input enable_parity,           \n    output reg [data_width-1:0] data_out,\n    output reg parity_out,        \n    output reg error               \n);\n\nalways @(*) begin\n    if (!enable) begin\n        data_out = data_out;  \n        error = 0;      \n        parity_out = 0;      \n    end else begin\n        error = 0;  \n        case (mode)\n            3'b000: begin  \n                if (shift_bits >= data_width) begin\n                    error = 1;  \n                    data_out = {data_width{1'b0}};\n                end else if (left_right) begin\n                    data_out = data_in << shift_bits;  \n                end else begin\n                    data_out = data_in >> shift_bits;  \n                end\n            end\n            3'b001: begin  \n                if (shift_bits >= data_width) begin\n                    error = 1;  \n                    data_out = {data_width{1'b0}};\n                end else if (left_right) begin\n                    data_out = data_in << shift_bits;  \n                end else begin\n                    data_out = $signed(data_in) >>> shift_bits; \n                end\n            end\n            3'b010: begin \n                if (shift_bits >= data_width) begin\n                    error = 1;  \n                    data_out = {data_width{1'b0}};\n                end else if (left_right) begin\n                    data_out = (data_in << shift_bits) | (data_in >> (data_width - shift_bits)); \n                end else begin\n                    data_out = (data_in >> shift_bits) | (data_in << (data_width - shift_bits));  \n                end\n            end\n            3'b011: begin  \n                if (shift_bits >= data_width) begin\n                    error = 1;  \n                    data_out = {data_width{1'b0}};\n                end else if (left_right) begin\n                    data_out = (data_in << shift_bits) & mask;  \n                end else begin\n                    data_out = (data_in >> shift_bits) & mask;  \n                end\n            end\n            3'b100: begin \n                if (left_right) begin\n                    data_out = data_in + shift_bits;  \n                end else begin\n                    data_out = data_in - shift_bits;  \n                end\n            end\n            3'b101: begin  \n                data_out = 0;\n                for (int i = data_width-1; i >= 0; i = i - 1) begin\n                    if (data_in[i] == 1 && data_out == 0) begin\n                        data_out = i;  \n                    end\n                end\n            end\n            3'b110: begin \n                if (left_right) begin\n                    data_out = (data_in + shift_bits) % data_width; \n                end else begin\n                    data_out = (data_in - shift_bits) % data_width; \n                end\n            end\n            default: begin\n                data_out = {data_width{1'b0}}; \n                error = 1;  \n            end\n        endcase\n    end\n\n    if (enable_parity) begin\n        parity_out = ^data_out; \n    end else begin\n        parity_out = 0;        \n    end\nend\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_bcd_adder_0001": {"input": {}, "output": {"rtl/bcd_adder.sv": ""}, "obj": true}}
{"cvdp_copilot_bcd_counter_0001": {"input": {}, "output": {"rtl/bcd_counter.sv": ""}, "obj": true}}
{"cvdp_copilot_bcd_to_excess_3_0001": {"input": {}, "output": {"rtl/bcd_to_excess_3.sv": ""}, "obj": true}}
{"cvdp_copilot_bcd_to_excess_3_0008": {"input": {"docs/bcd_to_excess_3_Doc.md": "# BCD to Excess-3 Code Converter Documentation\n## Overview\nThis document provides the specifications and details for the Verilog module `bcd_to_excess_3`, which converts a 4-bit Binary-Coded Decimal (BCD) input into its corresponding 4-bit Excess-3 code. The module also includes an error flag to indicate invalid inputs, specifically for non-BCD values.\n\n## Module Details\n\n### Module Name\n`bcd_to_excess_3`\n\n### Description\nThe `bcd_to_excess_3` module takes a 4-bit BCD input and outputs a 4-bit Excess-3 code. For invalid inputs (BCD values outside the range 0000 to 1001), the output is set to `0000`, and an error flag is raised to `1`. This module operates combinationally and updates its output whenever the BCD input changes.\n\n## Interface\n\n### Port Definitions\n- **Input**\n  - `bcd` (4 bits): A 4-bit input representing a Binary-Coded Decimal (BCD) number. Valid values range from 0000 to 1001.\n  \n- **Outputs**\n  - `excess3` (4 bits): A 4-bit output representing the Excess-3 code equivalent of the input BCD number.\n  - `error` (1 bit): A flag that indicates if the input BCD value is invalid. Set to `1` for values outside the valid BCD range.\n\n## Functional Behavior\n\n### Conversion Table\nThe module maps each valid 4-bit BCD input to its corresponding Excess-3 code as follows:\n\n| BCD Input (bcd) | Excess-3 Output (excess3) |\n|-----------------|---------------------------|\n| 0000            | 0011                      |\n| 0001            | 0100                      |\n| 0010            | 0101                      |\n| 0011            | 0110                      |\n| 0100            | 0111                      |\n| 0101            | 1000                      |\n| 0110            | 1001                      |\n| 0111            | 1010                      |\n| 1000            | 1011                      |\n| 1001            | 1100                      |\n\nFor inputs outside the valid BCD range (1010 to 1111):\n- `excess3` output is set to `0000`.\n- `error` flag is set to `1` to indicate an invalid input.\n\n### Timing and Sensitivity\nThis module is purely combinational and updates the output in response to any changes in the `bcd` input. It does not rely on a clock signal.\n\n## Conclusion\nThe `bcd_to_excess_3` module provides an efficient and reliable way to convert BCD numbers into their Excess-3 representation while handling invalid inputs through an error flag. Designed to operate as a purely combinational module, it instantly reflects any change in the input through the output without the need for a clock signal. This design ensures correct mapping for valid BCD values and robust error handling for out-of-range inputs, making it suitable for applications requiring straightforward BCD-to-Excess-3 conversions.", "rtl/bcd_to_excess_3.sv": "`timescale 1ns / 1ps\nmodule bcd_to_excess_3(\n    input [3:0] bcd,          // 4-bit BCD input\n    output reg [3:0] excess3, // 4-bit Excess-3 output\n    output reg error          // Error flag to indicate invalid input\n);\n\n// The always block triggers on any change to the BCD input.\nalways @(bcd)\nbegin\n    error = 1'b0; \n    case(bcd)\n        4'b0000: excess3 = 4'b0011;  \n        4'b0001: excess3 = 4'b0100;  \n        4'b0010: excess3 = 4'b0101;  \n        4'b0011: excess3 = 4'b0110;  \n        4'b0100: excess3 = 4'b0111;  \n        4'b0101: excess3 = 4'b1000;  \n        4'b0110: excess3 = 4'b1001;  \n        4'b0111: excess3 = 4'b1010;  \n        4'b1000: excess3 = 4'b1011;  \n        4'b1001: excess3 = 4'b1100;  \n        default: begin\n            excess3 = 4'b0000;   // Set output to 0 on invalid input.\n            error = 1'b1;        // Set error flag to 1 to indicate an invalid input was received.\n        end\n    endcase\nend\nendmodule\n"}, "output": {"rtl/bcd_to_excess_3.sv": "`timescale 1ns / 1ps\nmodule bcd_to_excess_3(\n    input [3:0] bcd,          // 4-bit BCD input\n    output reg [3:0] excess3, // 4-bit Excess-3 output\n    output reg error          // Error flag to indicate invalid input\n);\n\n// The always block triggers on any change to the BCD input.\nalways @(bcd)\nbegin\n    error = 1'b0; \n    case(bcd)\n        4'b0000: excess3 = 4'b0011;  \n        4'b0001: excess3 = 4'b0100;  \n        4'b0010: excess3 = 4'b0101;  \n        4'b0011: excess3 = 4'b0110;  \n        4'b0100: excess3 = 4'b0111;  \n        4'b0101: excess3 = 4'b1000;  \n        4'b0110: excess3 = 4'b1001;  \n        4'b0111: excess3 = 4'b1010;  \n        4'b1000: excess3 = 4'b1011;  \n        4'b1001: excess3 = 4'b1100;  \n        default: begin\n            excess3 = 4'b0000;   // Set output to 0 on invalid input.\n            error = 1'b1;        // Set error flag to 1 to indicate an invalid input was received.\n        end\n    endcase\nend\nendmodule\n"}, "obj": true}}
{"cvdp_copilot_binary_multiplier_0012": {"input": {"rtl/binary_multiplier.sv": "module binary_multiplier #(\n    parameter WIDTH = 32  // Set the width of inputs\n)(\n    input  logic [WIDTH-1:0]   A,          // Input A\n    input  logic [WIDTH-1:0]   B,          // Input B\n    input  logic               valid_in,   // Indicates when inputs are valid\n    output logic [2*WIDTH-1:0] Product,    // Output Product\n    output logic               valid_out   // Output valid\n);\n\ninteger i;\nlogic [2*WIDTH-1:0] sum;  // Intermediate sum for unsigned multiplication\n\nalways @(*) begin\n    sum = 0;  // Initialize sum to zero\n    if (valid_in) begin\n        for (i = 0; i < WIDTH; i = i + 1) begin\n            if (A[i]) begin\n                sum = sum + (B << i);  // Add shifted value of B\n            end\n        end\n      \n        Product = sum;  // Assign the final sum as the product\n        valid_out = 1'b1;\n    end else begin\n        Product = 0;  // When valid_in is deasserted, output should be zero\n        valid_out = 1'b0;\n    end\nend\n\nendmodule"}, "output": {"rtl/binary_multiplier.sv": "module binary_multiplier #(\n    parameter WIDTH = 32  // Set the width of inputs\n)(\n    input  logic [WIDTH-1:0]   A,          // Input A\n    input  logic [WIDTH-1:0]   B,          // Input B\n    input  logic               valid_in,   // Indicates when inputs are valid\n    output logic [2*WIDTH-1:0] Product,    // Output Product\n    output logic               valid_out   // Output valid\n);\n\ninteger i;\nlogic [2*WIDTH-1:0] sum;  // Intermediate sum for unsigned multiplication\n\nalways @(*) begin\n    sum = 0;  // Initialize sum to zero\n    if (valid_in) begin\n        for (i = 0; i < WIDTH; i = i + 1) begin\n            if (A[i]) begin\n                sum = sum + (B << i);  // Add shifted value of B\n            end\n        end\n      \n        Product = sum;  // Assign the final sum as the product\n        valid_out = 1'b1;\n    end else begin\n        Product = 0;  // When valid_in is deasserted, output should be zero\n        valid_out = 1'b0;\n    end\nend\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_binary_search_tree_sorting_0001": {"input": {}, "output": {"rtl/binary_search_tree_sort.sv": ""}, "obj": true}}
{"cvdp_copilot_binary_search_tree_sorting_0014": {"input": {}, "output": {"rtl/search_binary_search_tree.sv": ""}, "obj": true}}
{"cvdp_copilot_binary_to_BCD_0001": {"input": {}, "output": {"rtl/binary_to_bcd.sv": ""}, "obj": true}}
{"cvdp_copilot_binary_to_BCD_0010": {"input": {"rtl/binary_to_bcd.sv": "module binary_to_bcd (\n    input logic [7:0] binary_in,  // 8-bit binary input\n    output logic [11:0] bcd_out  // 12-bit BCD output (3 digits)\n);\n\n  // Intermediate shift register to hold binary and BCD values\n  logic [19:0] shift_reg;  // 20-bit register: 12 for BCD and 8 for binary input\n  integer i;\n\n  always_comb begin\n    // Step 1: Initialize the shift register\n    shift_reg = {12'd0, binary_in};  // Concatenate 12 zeros and binary input\n\n    // Step 2: Perform the Double Dabble process\n    for (i = 0; i < 8; i = i + 1) begin\n      // Check if each BCD digit is 5 or greater; if so, add 3\n      if (shift_reg[11:8] >= 5) shift_reg[11:8] = shift_reg[11:8] + 3;\n      if (shift_reg[15:12] >= 5) shift_reg[15:12] = shift_reg[15:12] + 3;\n      if (shift_reg[19:16] >= 5) shift_reg[19:16] = shift_reg[19:16] + 3;\n\n      // Shift the entire register left by 1 bit\n      shift_reg = shift_reg << 1;\n    end\n\n    // Step 3: Assign the upper 12 bits of the shift register to BCD output\n    bcd_out = shift_reg[19:8];\n  end\n\nendmodule"}, "output": {"rtl/binary_bcd_converter_twoway.sv": ""}, "obj": true}}
{"cvdp_copilot_binary_to_BCD_0036": {"input": {"rtl/binary_to_bcd.sv": "module binary_to_bcd (\n    input  logic [ 7:0] binary_in,\n    output logic [11:0] bcd_out\n);\n  logic [23:0] shift_reg;\n  logic [19:0] shift_reg_temp;\n  integer i;\n\n  always @* begin\n    shift_reg = {12'd0, binary_in};\n    for (i = 0; i < 8; i = i + 1) begin\n      if (shift_reg[11:8] >= 5) shift_reg[11:8] = shift_reg[11:8] + 3;\n      if (shift_reg[15:12] >= 5) shift_reg[15:12] = shift_reg[15:12] + 3;\n      if (shift_reg[19:16] >= 5) shift_reg[19:16] = shift_reg[19:16] + 3;\n      shift_reg = shift_reg << 1;\n    end\n    bcd_out = shift_reg[19:8];\n  end\nendmodule"}, "output": {"rtl/binary_to_bcd.sv": "module binary_to_bcd (\n    input  logic [ 7:0] binary_in,\n    output logic [11:0] bcd_out\n);\n  logic [23:0] shift_reg;\n  logic [19:0] shift_reg_temp;\n  integer i;\n\n  always @* begin\n    shift_reg = {12'd0, binary_in};\n    for (i = 0; i < 8; i = i + 1) begin\n      if (shift_reg[11:8] >= 5) shift_reg[11:8] = shift_reg[11:8] + 3;\n      if (shift_reg[15:12] >= 5) shift_reg[15:12] = shift_reg[15:12] + 3;\n      if (shift_reg[19:16] >= 5) shift_reg[19:16] = shift_reg[19:16] + 3;\n      shift_reg = shift_reg << 1;\n    end\n    bcd_out = shift_reg[19:8];\n  end\nendmodule"}, "obj": true}}
{"cvdp_copilot_binary_to_gray_0001": {"input": {}, "output": {"rtl/binary_to_gray.sv": ""}, "obj": true}}
{"cvdp_copilot_binary_to_gray_0013": {"input": {"rtl/binary_to_gray.sv": "module binary_to_gray #(\n    parameter WIDTH = 6\n) (\n    input  wire [WIDTH-1:0] binary_in,\n    output wire [WIDTH-1:0] gray_out\n);\n\n  logic gray_out_d1;  \n\n  assign gray_out[WIDTH-1] = binary_in[WIDTH-1];\n\n  generate\n    genvar i;\n    for (i = 0; i < WIDTH - 1; i = i + 1) begin\n      assign gray_out[i] = binary_in[i+1] ^ binary_in[i];\n    end\n  endgenerate\n\n  always_ff @(posedge binary_in[0]) begin  \n    gray_out = binary_in;  \n  end\n\nendmodule"}, "output": {"rtl/binary_to_gray.sv": ""}, "obj": true}}
{"cvdp_copilot_binary_to_one_hot_decoder_0001": {"input": {}, "output": {"rtl/binary_to_one_hot_decoder.v": ""}, "obj": true}}
{"cvdp_copilot_bit_synchronizer_0001": {"input": {}, "output": {"rtl/bit_sync.sv": ""}, "obj": true}}
{"cvdp_copilot_bus_arbiter_0001": {"input": {}, "output": {"rtl/cvdp_copilot_bus_arbiter.sv": ""}, "obj": true}}
{"cvdp_copilot_bus_arbiter_0004": {"input": {"rtl/cvdp_copilot_bus_arbiter.sv": "module cvdp_copilot_bus_arbiter (\n    input reset,\n    input clk,\n    input req1,\n    input req2,\n    output reg grant1,\n    output reg grant2\n    );\n  \n// State Encoding\nlocalparam IDLE        = 3'b000,\n            GRANT_1     = 3'b001,\n            GRANT_2     = 3'b010,\n            MASTER1_PRI = 3'b011,\n            CLEAR       = 3'b100;\n  \n// STATE REGISTERS\nreg [2:0] state;      // Current state\nreg [2:0] next_state; // Next state\n\n// State Transition\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// Next State Logic\nalways @(*) begin\n    next_state = state; // Default assignment\n    case (state)\n        IDLE: begin\n            if (req2)\n                next_state = GRANT_2;\n            else if (req1)\n                next_state = GRANT_1;\n        end\n        GRANT_2: begin\n            if (!req2 && !req1)\n                next_state = IDLE; // Both requests deasserted\n            else if (!req2 && req1)\n                next_state = GRANT_1; // Switch to GRANT_1 if req1 is still asserted\n        end\n        GRANT_1: begin\n            if (!req1 && !req2)\n                next_state = IDLE; // Both requests deasserted\n            else if (req2)\n                next_state = GRANT_2; // req2 has priority\n        end\n        MASTER1_PRI: begin\n            if (req2)\n                next_state = GRANT_2; // Grant Master 2 if req2 is asserted\n            else if (req1)\n                next_state = GRANT_1; // Grant Master 1 if only req1 is asserted\n            else\n                next_state = IDLE; // No requests, transition to IDLE\n        end\n        CLEAR: begin\n            if (req2)\n                next_state = GRANT_2;\n            else if (req1)\n                next_state = GRANT_1;\n            else\n                next_state = IDLE; // Default to IDLE if no requests\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output Logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        grant1 <= 1'b0;\n        grant2 <= 1'b0;\n    end else begin\n        case (next_state)\n            IDLE: begin\n                grant1 <= 1'b0;\n                grant2 <= 1'b0;\n            end\n            GRANT_1: begin\n                grant1 <= 1'b1;\n                grant2 <= 1'b0;\n            end\n            GRANT_2: begin\n                grant1 <= 1'b0;\n                grant2 <= 1'b1;\n            end\n            MASTER1_PRI: begin\n                grant1 <= 1'b0; // During this state, neither master is granted\n                grant2 <= 1'b0;\n            end\n            CLEAR: begin\n                grant1 <= 1'b0;\n                grant2 <= 1'b0;\n            end\n        endcase\n    end\nend\n  \nendmodule"}, "output": {"rtl/cvdp_copilot_bus_arbiter.sv": ""}, "obj": true}}
{"cvdp_copilot_cache_lru_0001": {"input": {}, "output": {"rtl/pseudo_lru_nmru_policy.sv": ""}, "obj": true}}
{"cvdp_copilot_cache_lru_0008": {"input": {}, "output": {"rtl/lru_counter_policy.sv": ""}, "obj": true}}
{"cvdp_copilot_cache_lru_0011": {"input": {}, "output": {"rtl/mru_counter_policy.sv": ""}, "obj": true}}
{"cvdp_copilot_cache_lru_0016": {"input": {}, "output": {"rtl/lfu_counter_policy.sv": ""}, "obj": true}}
{"cvdp_copilot_cache_lru_0019": {"input": {}, "output": {"rtl/pseudo_lru_tree_policy.sv": ""}, "obj": true}}
{"cvdp_copilot_cache_lru_0022": {"input": {"rtl/fifo_policy.sv": "module fifo_policy #(\n    parameter NWAYS = 4,\n    parameter NINDEXES = 32\n)(\n    input clock,\n    input reset,\n    input [$clog2(NINDEXES)-1:0] index,\n    input [$clog2(NWAYS)-1:0] way_select,\n    input access,\n    input hit,\n    output [$clog2(NWAYS)-1:0] way_replace\n);\n\n    // FIFO array to track next way to be replaced\n    reg [$clog2(NWAYS)-1:0] fifo_array [NINDEXES-1:0];\n\n    integer i;\n\n    // Sequential logic for reset and fifo_array updates\n    always_ff @ (posedge clock or posedge reset) begin\n        if (reset) begin\n            for (i = 0; i < NINDEXES; i++) begin\n                fifo_array[i] <= $clog2(NWAYS)'(0);\n            end\n        end else begin\n            if (access) begin\n                // Set the fifo_array position for the next replacement\n                fifo_array[index] <= fifo_array[index] + $clog2(NWAYS)'(1);\n            end\n        end\n    end\n\n    assign way_replace = fifo_array[index];\n\nendmodule : fifo_policy"}, "output": {"rtl/fifo_policy.sv": ""}, "obj": true}}
{"cvdp_copilot_caesar_cipher_0001": {"input": {}, "output": {"rtl/caesar_cipher.sv": ""}, "obj": true}}
{"cvdp_copilot_caesar_cipher_0024": {"input": {"rtl/caesar_cipher.sv": "module caesar_cipher #(\n    parameter PHRASE_WIDTH = 32,  // e.g., enough for 4 chars (4\u00d78=32)\n    parameter PHRASE_LEN   = PHRASE_WIDTH / 8\n)(\n    input  wire [PHRASE_WIDTH-1:0]       input_phrase,\n    input  wire [(PHRASE_LEN * 5) - 1:0] key_phrase,\n    input  wire                          decrypt,\n    output reg  [PHRASE_WIDTH-1:0]       output_phrase\n);\n\n    integer i;\n    reg [7:0] current_char;\n    reg [4:0] current_key;\n\n    always @(*) begin\n        // Initialize output to zero\n        output_phrase = {PHRASE_WIDTH{1'b0}};\n\n        \n        if (PHRASE_LEN > 0) begin\n            for (i = 0; i < PHRASE_LEN; i = i + 1) begin\n                // Extract current character & key\n                current_char = input_phrase[i * 8 +: 8];\n                current_key  = key_phrase[i * 5 +: 5];\n\n             \n                if (decrypt) begin\n                    if (current_char >= \"A\" && current_char <= \"Z\") begin\n                        output_phrase[i * 8 +: 8]\n                            = ((current_char - \"A\" + current_key + 26) % 26) + \"A\";\n                    end\n                    else if (current_char >= \"a\" && current_char <= \"z\") begin\n                        output_phrase[i * 8 +: 8]\n                            = ((current_char - \"a\" - current_key + 26) % 26) + \"a\";\n                    end\n                    else begin\n                        output_phrase[i * 8 +: 8] = current_char - current_key;\n                    end\n                end\n\n                else begin\n                    if (current_char >= \"A\" && current_char <= \"Z\") begin\n                        output_phrase[i * 8 +: 8]\n                            = current_char + current_key;\n                    end\n                    else if (current_char >= \"a\" && current_char <= \"z\") begin\n                        output_phrase[i * 8 +: 8]\n                            = ((current_char - \"a\" + current_key) % 26) + \"a\";\n                    end\n                    else begin\n                        if (current_key == 0) begin\n                            output_phrase[i * 8 +: 8] = current_char + 1;\n                        end\n                        else begin\n                            output_phrase[i * 8 +: 8] = current_char - current_key;\n                        end\n                    end\n                end\n            end\n        end\n    end\n\nendmodule"}, "output": {"rtl/caesar_cipher.sv": "module caesar_cipher #(\n    parameter PHRASE_WIDTH = 32,  // e.g., enough for 4 chars (4\u00d78=32)\n    parameter PHRASE_LEN   = PHRASE_WIDTH / 8\n)(\n    input  wire [PHRASE_WIDTH-1:0]       input_phrase,\n    input  wire [(PHRASE_LEN * 5) - 1:0] key_phrase,\n    input  wire                          decrypt,\n    output reg  [PHRASE_WIDTH-1:0]       output_phrase\n);\n\n    integer i;\n    reg [7:0] current_char;\n    reg [4:0] current_key;\n\n    always @(*) begin\n        // Initialize output to zero\n        output_phrase = {PHRASE_WIDTH{1'b0}};\n\n        \n        if (PHRASE_LEN > 0) begin\n            for (i = 0; i < PHRASE_LEN; i = i + 1) begin\n                // Extract current character & key\n                current_char = input_phrase[i * 8 +: 8];\n                current_key  = key_phrase[i * 5 +: 5];\n\n             \n                if (decrypt) begin\n                    if (current_char >= \"A\" && current_char <= \"Z\") begin\n                        output_phrase[i * 8 +: 8]\n                            = ((current_char - \"A\" + current_key + 26) % 26) + \"A\";\n                    end\n                    else if (current_char >= \"a\" && current_char <= \"z\") begin\n                        output_phrase[i * 8 +: 8]\n                            = ((current_char - \"a\" - current_key + 26) % 26) + \"a\";\n                    end\n                    else begin\n                        output_phrase[i * 8 +: 8] = current_char - current_key;\n                    end\n                end\n\n                else begin\n                    if (current_char >= \"A\" && current_char <= \"Z\") begin\n                        output_phrase[i * 8 +: 8]\n                            = current_char + current_key;\n                    end\n                    else if (current_char >= \"a\" && current_char <= \"z\") begin\n                        output_phrase[i * 8 +: 8]\n                            = ((current_char - \"a\" + current_key) % 26) + \"a\";\n                    end\n                    else begin\n                        if (current_key == 0) begin\n                            output_phrase[i * 8 +: 8] = current_char + 1;\n                        end\n                        else begin\n                            output_phrase[i * 8 +: 8] = current_char - current_key;\n                        end\n                    end\n                end\n            end\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_caesar_cipher_0038": {"input": {"rtl/caesar_cipher.sv": "module caesar_cipher(\n    input wire [7:0] input_char, // 8-bit ASCII character\n    input wire [3:0] key,        // 4-bit shift key\n    output reg [7:0] output_char // 8-bit shifted output character\n);\n\nalways @(*) begin\n    if (input_char >= \"A\" && input_char <= \"Z\") begin\n        output_char = ((input_char - \"A\" + key) % 26) + \"A\";\n    end\n    else if (input_char >= \"a\" && input_char <= \"z\") begin\n        output_char = ((input_char - \"a\" + key) % 26) + \"a\";\n    end\n    else begin\n        output_char = input_char;\n    end\nend\n\nendmodule"}, "output": {"rtl/caesar_cipher.sv": "module caesar_cipher(\n    input wire [7:0] input_char, // 8-bit ASCII character\n    input wire [3:0] key,        // 4-bit shift key\n    output reg [7:0] output_char // 8-bit shifted output character\n);\n\nalways @(*) begin\n    if (input_char >= \"A\" && input_char <= \"Z\") begin\n        output_char = ((input_char - \"A\" + key) % 26) + \"A\";\n    end\n    else if (input_char >= \"a\" && input_char <= \"z\") begin\n        output_char = ((input_char - \"a\" + key) % 26) + \"a\";\n    end\n    else begin\n        output_char = input_char;\n    end\nend\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_car_parking_management_0001": {"input": {}, "output": {"rtl/car_parking_system.sv": ""}, "obj": true}}
{"cvdp_copilot_car_parking_management_0015": {"input": {"rtl/car_parking_system.sv": "// This module implements a car parking management system\n// - Uses an FSM to handle different states: `IDLE`, `ENTRY_PROCESSING`, `EXIT_PROCESSING`, and `FULL`.\n\nmodule car_parking_system #(\n    parameter TOTAL_SPACES = 12\n)(\n    input wire clk,\n    input wire reset,\n    input wire vehicle_entry_sensor,\n    input wire vehicle_exit_sensor,\n    output reg [$clog2(TOTAL_SPACES)-1:0] available_spaces,\n    output reg [$clog2(TOTAL_SPACES)-1:0] count_car,\n    output reg led_status,\n    output reg [6:0] seven_seg_display_available_tens,\n    output reg [6:0] seven_seg_display_available_units,\n    output reg [6:0] seven_seg_display_count_tens,\n    output reg [6:0] seven_seg_display_count_units\n);\n\n    // Local parameters for FSM states\n    localparam IDLE            = 2'b00,\n               ENTRY_PROCESSING = 2'b01,\n               EXIT_PROCESSING  = 2'b10,\n               FULL            = 2'b11;\n\n    // Internal signals\n    reg [1:0] state, next_state;\n\n    // Seven-segment encoding\n    function [6:0] seven_segment_encoding;\n        input [3:0] digit;\n        begin\n            case (digit)\n                4'd0: seven_segment_encoding = 7'b1111110; // 0\n                4'd1: seven_segment_encoding = 7'b0110000; // 1\n                4'd2: seven_segment_encoding = 7'b1101101; // 2\n                4'd3: seven_segment_encoding = 7'b1111001; // 3\n                4'd4: seven_segment_encoding = 7'b0110011; // 4\n                4'd5: seven_segment_encoding = 7'b1011011; // 5\n                4'd6: seven_segment_encoding = 7'b1011111; // 6\n                4'd7: seven_segment_encoding = 7'b1110000; // 7\n                4'd8: seven_segment_encoding = 7'b1111111; // 8\n                4'd9: seven_segment_encoding = 7'b1111011; // 9\n                default: seven_segment_encoding = 7'b0000000; // Blank display\n            endcase\n        end\n    endfunction\n\n    // Reset logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic and outputs\n    always @(*) begin\n        // Defaults\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (vehicle_entry_sensor && available_spaces > 0) begin\n                    next_state = ENTRY_PROCESSING;\n                end else if (vehicle_exit_sensor && count_car > 0) begin\n                    next_state = EXIT_PROCESSING;\n                end else if (available_spaces == 0) begin\n                    next_state = FULL;\n                end\n            end\n            ENTRY_PROCESSING: begin\n                if (available_spaces > 0) begin\n                    next_state = IDLE;\n                end\n            end\n            EXIT_PROCESSING: begin\n                if (count_car > 0) begin\n                    next_state = IDLE;\n                end\n            end\n            FULL: begin\n                if (vehicle_exit_sensor) begin\n                    next_state = EXIT_PROCESSING;\n                end\n            end\n        endcase\n    end\n\n    always@(*)begin\n        if(state == FULL) begin\n            led_status = 1'b0;\n        end else begin\n            led_status = 1'b1;\n        end\n    end\n\n    // Space and count management\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            available_spaces <= TOTAL_SPACES;\n            count_car <= 0;\n        end else begin\n            if (state == ENTRY_PROCESSING) begin\n                available_spaces <= available_spaces - 1;\n                count_car <= count_car + 1;\n            end else if (state == EXIT_PROCESSING) begin\n                available_spaces <= available_spaces + 1;\n                count_car <= count_car - 1;\n            end else begin\n                available_spaces <= available_spaces;\n                count_car <= count_car;\n            end\n        end\n    end\n\n\n    // Seven-segment display update\n    always @(*) begin\n        seven_seg_display_available_tens = seven_segment_encoding(available_spaces / 10);\n        seven_seg_display_available_units = seven_segment_encoding(available_spaces % 10);\n        seven_seg_display_count_tens = seven_segment_encoding(count_car / 10);\n        seven_seg_display_count_units = seven_segment_encoding(count_car % 10);\n    end\n\nendmodule"}, "output": {"rtl/car_parking_system.sv": "// This module implements a car parking management system\n// - Uses an FSM to handle different states: `IDLE`, `ENTRY_PROCESSING`, `EXIT_PROCESSING`, and `FULL`.\n\nmodule car_parking_system #(\n    parameter TOTAL_SPACES = 12\n)(\n    input wire clk,\n    input wire reset,\n    input wire vehicle_entry_sensor,\n    input wire vehicle_exit_sensor,\n    output reg [$clog2(TOTAL_SPACES)-1:0] available_spaces,\n    output reg [$clog2(TOTAL_SPACES)-1:0] count_car,\n    output reg led_status,\n    output reg [6:0] seven_seg_display_available_tens,\n    output reg [6:0] seven_seg_display_available_units,\n    output reg [6:0] seven_seg_display_count_tens,\n    output reg [6:0] seven_seg_display_count_units\n);\n\n    // Local parameters for FSM states\n    localparam IDLE            = 2'b00,\n               ENTRY_PROCESSING = 2'b01,\n               EXIT_PROCESSING  = 2'b10,\n               FULL            = 2'b11;\n\n    // Internal signals\n    reg [1:0] state, next_state;\n\n    // Seven-segment encoding\n    function [6:0] seven_segment_encoding;\n        input [3:0] digit;\n        begin\n            case (digit)\n                4'd0: seven_segment_encoding = 7'b1111110; // 0\n                4'd1: seven_segment_encoding = 7'b0110000; // 1\n                4'd2: seven_segment_encoding = 7'b1101101; // 2\n                4'd3: seven_segment_encoding = 7'b1111001; // 3\n                4'd4: seven_segment_encoding = 7'b0110011; // 4\n                4'd5: seven_segment_encoding = 7'b1011011; // 5\n                4'd6: seven_segment_encoding = 7'b1011111; // 6\n                4'd7: seven_segment_encoding = 7'b1110000; // 7\n                4'd8: seven_segment_encoding = 7'b1111111; // 8\n                4'd9: seven_segment_encoding = 7'b1111011; // 9\n                default: seven_segment_encoding = 7'b0000000; // Blank display\n            endcase\n        end\n    endfunction\n\n    // Reset logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic and outputs\n    always @(*) begin\n        // Defaults\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (vehicle_entry_sensor && available_spaces > 0) begin\n                    next_state = ENTRY_PROCESSING;\n                end else if (vehicle_exit_sensor && count_car > 0) begin\n                    next_state = EXIT_PROCESSING;\n                end else if (available_spaces == 0) begin\n                    next_state = FULL;\n                end\n            end\n            ENTRY_PROCESSING: begin\n                if (available_spaces > 0) begin\n                    next_state = IDLE;\n                end\n            end\n            EXIT_PROCESSING: begin\n                if (count_car > 0) begin\n                    next_state = IDLE;\n                end\n            end\n            FULL: begin\n                if (vehicle_exit_sensor) begin\n                    next_state = EXIT_PROCESSING;\n                end\n            end\n        endcase\n    end\n\n    always@(*)begin\n        if(state == FULL) begin\n            led_status = 1'b0;\n        end else begin\n            led_status = 1'b1;\n        end\n    end\n\n    // Space and count management\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            available_spaces <= TOTAL_SPACES;\n            count_car <= 0;\n        end else begin\n            if (state == ENTRY_PROCESSING) begin\n                available_spaces <= available_spaces - 1;\n                count_car <= count_car + 1;\n            end else if (state == EXIT_PROCESSING) begin\n                available_spaces <= available_spaces + 1;\n                count_car <= count_car - 1;\n            end else begin\n                available_spaces <= available_spaces;\n                count_car <= count_car;\n            end\n        end\n    end\n\n\n    // Seven-segment display update\n    always @(*) begin\n        seven_seg_display_available_tens = seven_segment_encoding(available_spaces / 10);\n        seven_seg_display_available_units = seven_segment_encoding(available_spaces % 10);\n        seven_seg_display_count_tens = seven_segment_encoding(count_car / 10);\n        seven_seg_display_count_units = seven_segment_encoding(count_car % 10);\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_car_parking_management_0018": {"input": {}, "output": {"rtl/car_parking_system.sv": ""}, "obj": true}}
{"cvdp_copilot_car_parking_management_0031": {"input": {"rtl/car_parking_system.sv": "// This module implements a car parking management system\n// - Uses an FSM to handle different states: `IDLE`, `ENTRY_PROCESSING`, `EXIT_PROCESSING`, and `FULL`.\n\nmodule car_parking_system #(\n    parameter TOTAL_SPACES = 12,\n    parameter PARKING_FEE_VALUE = 50,\n    parameter MAX_DAILY_FEE = 500,\n    parameter WARNING_LIMIT = 12 * 3600, // 12 hours in seconds\n    parameter OVERSTAY_LIMIT = 24 * 3600 // 24 hours in seconds\n)(\n    input wire clk,\n    input wire reset,\n    input wire clear,\n    input wire vehicle_entry_sensor,\n    input wire vehicle_exit_sensor,\n    input wire [31:0] current_time, // Current time in seconds\n    input wire [$clog2(TOTAL_SPACES)-1:0] current_slot, // Slot number for the vehicle\n    input wire [4:0] hour_of_day, // Current hour of the day (0-23), provided externally\n    output reg [$clog2(TOTAL_SPACES)-1:0] available_spaces,\n    output reg [$clog2(TOTAL_SPACES)-1:0] count_car,\n    output reg led_status,\n    output reg [6:0] seven_seg_display_available_tens,\n    output reg [6:0] seven_seg_display_available_units,\n    output reg [6:0] seven_seg_display_count_tens,\n    output reg [6:0] seven_seg_display_count_units,\n    output reg [15:0] parking_fee, // Total parking fee for the vehicle exiting\n    output reg fee_ready,          // Indicates that the parking fee is ready\n    output reg [127:0] qr_code, // QR code data for parking fee payment\n    output time_warning_alert, // Alert if parked beyond WARNING_LIMIT\n    output reg led_warning // Blinking LED for warning\n);\n\n    // Local parameters for FSM states\n    localparam IDLE            = 2'b00,\n               ENTRY_PROCESSING = 2'b01,\n               EXIT_PROCESSING  = 2'b10,\n               FULL            = 2'b11;\n\n    // Internal signals\n    reg [1:0] state, next_state;\n    reg [31:0] entry_time [TOTAL_SPACES-1:0]; // Array to store entry times for each parking space\n    integer i;\n\n    wire time_warning_alert_internal;\n\n    reg fee_ready_internal;\n\n    reg [15:0] dynamic_parking_fee;\n\n    // Seven-segment encoding\n    function [6:0] seven_segment_encoding;\n        input [3:0] digit;\n        begin\n            case (digit)\n                4'd0: seven_segment_encoding = 7'b1111110; // 0\n                4'd1: seven_segment_encoding = 7'b0110000; // 1\n                4'd2: seven_segment_encoding = 7'b1101101; // 2\n                4'd3: seven_segment_encoding = 7'b1111001; // 3\n                4'd4: seven_segment_encoding = 7'b0110011; // 4\n                4'd5: seven_segment_encoding = 7'b1011011; // 5\n                4'd6: seven_segment_encoding = 7'b1011111; // 6\n                4'd7: seven_segment_encoding = 7'b1110000; // 7\n                4'd8: seven_segment_encoding = 7'b1111111; // 8\n                4'd9: seven_segment_encoding = 7'b1111011; // 9\n                default: seven_segment_encoding = 7'b0000000; // Blank display\n            endcase\n        end\n    endfunction\n\n    //reg [31:0] hours = 0;\n\n    // Fee calculation function\n    function [15:0] calculate_fee;\n        input [31:0] parked_time; // Total parked time in seconds\n        input [15:0] fee_per_hour;\n        begin\n                    // Convert seconds to hours\n            if (parked_time % 3600 > 0) begin\n                calculate_fee = ((parked_time / 3600) + 1)*fee_per_hour; // Round up to the next hour if there's a remainder\n            end else begin\n                calculate_fee = ((parked_time / 3600))*fee_per_hour;\n            end\n        end\n    endfunction\n\n    // QR code generation function\n    function [127:0] generate_qr_code;\n        input [15:0] fee;\n        input [$clog2(TOTAL_SPACES)-1:0] slot;\n        input [31:0] time_spent;\n        begin\n            \n            // Concatenate slot, fee, and time spent for QR data\n            generate_qr_code = {slot, fee, time_spent, {128- ($clog2(TOTAL_SPACES) + 16 + 32){1'b0}}}; // Include time spent in the lower bits\n        end\n    endfunction\n\n    // Reset logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Dynamic fee adjustment based on hour of day\n    always @(*) begin\n        if (hour_of_day >= 8 && hour_of_day <= 18) begin\n            dynamic_parking_fee = PARKING_FEE_VALUE * 2; // Peak hours: double the fee\n        end else begin\n            dynamic_parking_fee = PARKING_FEE_VALUE; // Regular hours\n        end\n    end\n\n    // Next state logic and outputs\n    always @(*) begin\n        // Defaults\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (vehicle_entry_sensor && available_spaces > 0) begin\n                    next_state = ENTRY_PROCESSING;\n                end else if (vehicle_exit_sensor && count_car > 0) begin\n                    next_state = EXIT_PROCESSING;\n                end else if (available_spaces == 0) begin\n                    next_state = FULL;\n                end\n            end\n            ENTRY_PROCESSING: begin\n                next_state = IDLE;\n            end\n            EXIT_PROCESSING: begin\n                if(clear)\n                    next_state <= IDLE;\n                else if(time_warning_alert == 1'b1)\n                    next_state <= EXIT_PROCESSING;\n                else\n                    next_state = IDLE;\n            end\n            FULL: begin\n                next_state = (vehicle_exit_sensor) ? EXIT_PROCESSING : FULL;\n            end\n        endcase\n    end\n\n    // LED Status Control\n    always @(*) begin\n        led_status <= (state != FULL);\n    end\n\n    // Space and count management\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            available_spaces <= TOTAL_SPACES;\n            count_car <= 0;\n            for (i = 0; i < TOTAL_SPACES; i = i + 1) begin\n                entry_time[i] <= 0;\n            end\n        end else begin\n            if (state == ENTRY_PROCESSING) begin\n                entry_time[current_slot] <= current_time; // Store the entry time based on slot\n                available_spaces <= available_spaces - 1;\n                count_car <= count_car + 1;\n            end else if (state == EXIT_PROCESSING) begin\n                    entry_time[current_slot] <= 0; // Clear the slot\n                available_spaces <= available_spaces + 1;\n                count_car <= count_car - 1;\n            end else begin\n                available_spaces <= available_spaces;\n                count_car <= count_car;\n            end\n        end\n    end\n\nassign time_warning_alert = ((current_time - entry_time[current_slot]) > WARNING_LIMIT && (current_time - entry_time[current_slot]) < OVERSTAY_LIMIT) & !clear ? 1'b1 : 1'b0;\n\nalways @(posedge clk) begin\n    if (state == EXIT_PROCESSING) begin\n        // If parked time exceeds WARNING_LIMIT but is less than OVERSTAY_LIMIT, trigger alert\n        if(time_warning_alert == 1)begin\n            #5 led_warning <= ~led_warning;\n        end else begin\n            led_warning <= 0;\n        end\n    end else begin\n        led_warning <= 0;\n    end\nend\n\n\n\n    always@(posedge clk) begin\n        if(state == EXIT_PROCESSING) begin\n            if (calculate_fee(current_time - entry_time[current_slot], dynamic_parking_fee) > MAX_DAILY_FEE) begin\n                parking_fee <= MAX_DAILY_FEE; // Cap fee at maximum daily value\n                qr_code <= generate_qr_code(MAX_DAILY_FEE, current_slot, current_time - entry_time[current_slot]); // Generate QR code with time spent\n            end else begin\n                parking_fee <= calculate_fee(current_time - entry_time[current_slot], dynamic_parking_fee); // Calculate fee\n                qr_code <= generate_qr_code(calculate_fee(current_time - entry_time[current_slot], dynamic_parking_fee), current_slot, current_time - entry_time[current_slot]); // Generate QR code with time spent\n            end\n        end else begin\n            parking_fee <= 0;\n            qr_code <= 128'b0; // Clear QR code data\n        end\n    end\n\n    always@(posedge clk) begin\n        fee_ready <= (state == EXIT_PROCESSING);\n    end\n\n    // Seven-segment display update\n    always @(*) begin\n        seven_seg_display_available_tens = seven_segment_encoding(available_spaces / 10);\n        seven_seg_display_available_units = seven_segment_encoding(available_spaces % 10);\n        seven_seg_display_count_tens = seven_segment_encoding(count_car / 10);\n        seven_seg_display_count_units = seven_segment_encoding(count_car % 10);\n    end\n\nendmodule"}, "output": {"rtl/car_parking_system.sv": "// This module implements a car parking management system\n// - Uses an FSM to handle different states: `IDLE`, `ENTRY_PROCESSING`, `EXIT_PROCESSING`, and `FULL`.\n\nmodule car_parking_system #(\n    parameter TOTAL_SPACES = 12,\n    parameter PARKING_FEE_VALUE = 50,\n    parameter MAX_DAILY_FEE = 500,\n    parameter WARNING_LIMIT = 12 * 3600, // 12 hours in seconds\n    parameter OVERSTAY_LIMIT = 24 * 3600 // 24 hours in seconds\n)(\n    input wire clk,\n    input wire reset,\n    input wire clear,\n    input wire vehicle_entry_sensor,\n    input wire vehicle_exit_sensor,\n    input wire [31:0] current_time, // Current time in seconds\n    input wire [$clog2(TOTAL_SPACES)-1:0] current_slot, // Slot number for the vehicle\n    input wire [4:0] hour_of_day, // Current hour of the day (0-23), provided externally\n    output reg [$clog2(TOTAL_SPACES)-1:0] available_spaces,\n    output reg [$clog2(TOTAL_SPACES)-1:0] count_car,\n    output reg led_status,\n    output reg [6:0] seven_seg_display_available_tens,\n    output reg [6:0] seven_seg_display_available_units,\n    output reg [6:0] seven_seg_display_count_tens,\n    output reg [6:0] seven_seg_display_count_units,\n    output reg [15:0] parking_fee, // Total parking fee for the vehicle exiting\n    output reg fee_ready,          // Indicates that the parking fee is ready\n    output reg [127:0] qr_code, // QR code data for parking fee payment\n    output time_warning_alert, // Alert if parked beyond WARNING_LIMIT\n    output reg led_warning // Blinking LED for warning\n);\n\n    // Local parameters for FSM states\n    localparam IDLE            = 2'b00,\n               ENTRY_PROCESSING = 2'b01,\n               EXIT_PROCESSING  = 2'b10,\n               FULL            = 2'b11;\n\n    // Internal signals\n    reg [1:0] state, next_state;\n    reg [31:0] entry_time [TOTAL_SPACES-1:0]; // Array to store entry times for each parking space\n    integer i;\n\n    wire time_warning_alert_internal;\n\n    reg fee_ready_internal;\n\n    reg [15:0] dynamic_parking_fee;\n\n    // Seven-segment encoding\n    function [6:0] seven_segment_encoding;\n        input [3:0] digit;\n        begin\n            case (digit)\n                4'd0: seven_segment_encoding = 7'b1111110; // 0\n                4'd1: seven_segment_encoding = 7'b0110000; // 1\n                4'd2: seven_segment_encoding = 7'b1101101; // 2\n                4'd3: seven_segment_encoding = 7'b1111001; // 3\n                4'd4: seven_segment_encoding = 7'b0110011; // 4\n                4'd5: seven_segment_encoding = 7'b1011011; // 5\n                4'd6: seven_segment_encoding = 7'b1011111; // 6\n                4'd7: seven_segment_encoding = 7'b1110000; // 7\n                4'd8: seven_segment_encoding = 7'b1111111; // 8\n                4'd9: seven_segment_encoding = 7'b1111011; // 9\n                default: seven_segment_encoding = 7'b0000000; // Blank display\n            endcase\n        end\n    endfunction\n\n    //reg [31:0] hours = 0;\n\n    // Fee calculation function\n    function [15:0] calculate_fee;\n        input [31:0] parked_time; // Total parked time in seconds\n        input [15:0] fee_per_hour;\n        begin\n                    // Convert seconds to hours\n            if (parked_time % 3600 > 0) begin\n                calculate_fee = ((parked_time / 3600) + 1)*fee_per_hour; // Round up to the next hour if there's a remainder\n            end else begin\n                calculate_fee = ((parked_time / 3600))*fee_per_hour;\n            end\n        end\n    endfunction\n\n    // QR code generation function\n    function [127:0] generate_qr_code;\n        input [15:0] fee;\n        input [$clog2(TOTAL_SPACES)-1:0] slot;\n        input [31:0] time_spent;\n        begin\n            \n            // Concatenate slot, fee, and time spent for QR data\n            generate_qr_code = {slot, fee, time_spent, {128- ($clog2(TOTAL_SPACES) + 16 + 32){1'b0}}}; // Include time spent in the lower bits\n        end\n    endfunction\n\n    // Reset logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Dynamic fee adjustment based on hour of day\n    always @(*) begin\n        if (hour_of_day >= 8 && hour_of_day <= 18) begin\n            dynamic_parking_fee = PARKING_FEE_VALUE * 2; // Peak hours: double the fee\n        end else begin\n            dynamic_parking_fee = PARKING_FEE_VALUE; // Regular hours\n        end\n    end\n\n    // Next state logic and outputs\n    always @(*) begin\n        // Defaults\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (vehicle_entry_sensor && available_spaces > 0) begin\n                    next_state = ENTRY_PROCESSING;\n                end else if (vehicle_exit_sensor && count_car > 0) begin\n                    next_state = EXIT_PROCESSING;\n                end else if (available_spaces == 0) begin\n                    next_state = FULL;\n                end\n            end\n            ENTRY_PROCESSING: begin\n                next_state = IDLE;\n            end\n            EXIT_PROCESSING: begin\n                if(clear)\n                    next_state <= IDLE;\n                else if(time_warning_alert == 1'b1)\n                    next_state <= EXIT_PROCESSING;\n                else\n                    next_state = IDLE;\n            end\n            FULL: begin\n                next_state = (vehicle_exit_sensor) ? EXIT_PROCESSING : FULL;\n            end\n        endcase\n    end\n\n    // LED Status Control\n    always @(*) begin\n        led_status <= (state != FULL);\n    end\n\n    // Space and count management\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            available_spaces <= TOTAL_SPACES;\n            count_car <= 0;\n            for (i = 0; i < TOTAL_SPACES; i = i + 1) begin\n                entry_time[i] <= 0;\n            end\n        end else begin\n            if (state == ENTRY_PROCESSING) begin\n                entry_time[current_slot] <= current_time; // Store the entry time based on slot\n                available_spaces <= available_spaces - 1;\n                count_car <= count_car + 1;\n            end else if (state == EXIT_PROCESSING) begin\n                    entry_time[current_slot] <= 0; // Clear the slot\n                available_spaces <= available_spaces + 1;\n                count_car <= count_car - 1;\n            end else begin\n                available_spaces <= available_spaces;\n                count_car <= count_car;\n            end\n        end\n    end\n\nassign time_warning_alert = ((current_time - entry_time[current_slot]) > WARNING_LIMIT && (current_time - entry_time[current_slot]) < OVERSTAY_LIMIT) & !clear ? 1'b1 : 1'b0;\n\nalways @(posedge clk) begin\n    if (state == EXIT_PROCESSING) begin\n        // If parked time exceeds WARNING_LIMIT but is less than OVERSTAY_LIMIT, trigger alert\n        if(time_warning_alert == 1)begin\n            #5 led_warning <= ~led_warning;\n        end else begin\n            led_warning <= 0;\n        end\n    end else begin\n        led_warning <= 0;\n    end\nend\n\n\n\n    always@(posedge clk) begin\n        if(state == EXIT_PROCESSING) begin\n            if (calculate_fee(current_time - entry_time[current_slot], dynamic_parking_fee) > MAX_DAILY_FEE) begin\n                parking_fee <= MAX_DAILY_FEE; // Cap fee at maximum daily value\n                qr_code <= generate_qr_code(MAX_DAILY_FEE, current_slot, current_time - entry_time[current_slot]); // Generate QR code with time spent\n            end else begin\n                parking_fee <= calculate_fee(current_time - entry_time[current_slot], dynamic_parking_fee); // Calculate fee\n                qr_code <= generate_qr_code(calculate_fee(current_time - entry_time[current_slot], dynamic_parking_fee), current_slot, current_time - entry_time[current_slot]); // Generate QR code with time spent\n            end\n        end else begin\n            parking_fee <= 0;\n            qr_code <= 128'b0; // Clear QR code data\n        end\n    end\n\n    always@(posedge clk) begin\n        fee_ready <= (state == EXIT_PROCESSING);\n    end\n\n    // Seven-segment display update\n    always @(*) begin\n        seven_seg_display_available_tens = seven_segment_encoding(available_spaces / 10);\n        seven_seg_display_available_units = seven_segment_encoding(available_spaces % 10);\n        seven_seg_display_count_tens = seven_segment_encoding(count_car / 10);\n        seven_seg_display_count_units = seven_segment_encoding(count_car % 10);\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_cascaded_adder_0001": {"input": {}, "output": {"rtl/cascaded_adder.sv": ""}, "obj": true}}
{"cvdp_copilot_cascaded_adder_0025": {"input": {}, "output": {"rtl/cascaded_adder.sv": ""}, "obj": true}}
{"cvdp_copilot_cdc_pulse_synchronizer_0004": {"input": {"rtl/cdc_pulse_synchronizer.sv": "module cdc_pulse_synchronizer (\n    input  logic src_clock,   // Source Clock Domain\n    input  logic des_clock,   // Destination Clock Domain\n    input  logic rst_in,      // Reset\n    input  logic src_pulse,   // Source Pulse\n    output logic des_pulse    // Destination Pulse\n);\n\n    logic pls_toggle;      \n    logic pls_toggle_synca;\n    logic pls_toggle_syncc;\n\n    //--------------------------------------------------\n    //   Toggle Flop Circuit\n    //---------------------------------------------------\n\n    always_ff @(posedge src_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle <= 1'b0;\n        end else if (src_pulse) begin\n            pls_toggle <= ~pls_toggle;\n        end else begin\n            pls_toggle <= 1'b0;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Double Flop Bit Synchronizer\n    //---------------------------------------------------\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_synca <= 1'b0;\n        end else begin\n            pls_toggle_synca <= pls_toggle;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Delay Logic of Output signal\n    //---------------------------------------------------\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_syncc <= 1'b0;\n        end else begin\n            pls_toggle_syncc <= pls_toggle_synca;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Assign Statement for posedge and negedge detection\n    //---------------------------------------------------\n\n    assign des_pulse = pls_toggle_syncc ^ pls_toggle_synca; \nendmodule"}, "output": {"rtl/cdc_pulse_synchronizer.sv": "module cdc_pulse_synchronizer (\n    input  logic src_clock,   // Source Clock Domain\n    input  logic des_clock,   // Destination Clock Domain\n    input  logic rst_in,      // Reset\n    input  logic src_pulse,   // Source Pulse\n    output logic des_pulse    // Destination Pulse\n);\n\n    logic pls_toggle;      \n    logic pls_toggle_synca;\n    logic pls_toggle_syncc;\n\n    //--------------------------------------------------\n    //   Toggle Flop Circuit\n    //---------------------------------------------------\n\n    always_ff @(posedge src_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle <= 1'b0;\n        end else if (src_pulse) begin\n            pls_toggle <= ~pls_toggle;\n        end else begin\n            pls_toggle <= 1'b0;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Double Flop Bit Synchronizer\n    //---------------------------------------------------\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_synca <= 1'b0;\n        end else begin\n            pls_toggle_synca <= pls_toggle;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Delay Logic of Output signal\n    //---------------------------------------------------\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            pls_toggle_syncc <= 1'b0;\n        end else begin\n            pls_toggle_syncc <= pls_toggle_synca;\n        end\n    end\n\n    //--------------------------------------------------\n    //   Assign Statement for posedge and negedge detection\n    //---------------------------------------------------\n\n    assign des_pulse = pls_toggle_syncc ^ pls_toggle_synca; \nendmodule"}, "obj": true}}
{"cvdp_copilot_cdc_pulse_synchronizer_0013": {"input": {"rtl/cdc_pulse_synchronizer.sv": "module cdc_pulse_synchronizer (\n    input  logic src_clock,       // Source Clock Domain\n    input  logic des_clock,       // Destination Clock Domain\n    input  logic rst_in,          // Asynchronous Active-High Reset\n    input  logic src_pulse,       // Source Pulse\n    output logic des_pulse        // Destination Pulse\n);\n\n    logic pls_toggle;      \n    logic pls_toggle_synca, pls_toggle_syncb, pls_toggle_syncc;\n    logic rst_src_sync;\n    logic rst_des_sync;\n    logic rst_src_synca, rst_src_syncb;\n    logic rst_des_synca, rst_des_syncb;\n\n    always_ff @(posedge src_clock or posedge rst_in) begin\n        if (rst_in) begin\n            rst_src_synca <= 1'b1;\n            rst_src_syncb <= 1'b1;\n        end else begin\n            rst_src_synca <= 1'b0;\n            rst_src_syncb <= rst_src_synca;\n        end\n    end\n\n    assign rst_src_sync = rst_src_syncb;\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            rst_des_synca <= 1'b1;\n            rst_des_syncb <= 1'b1;\n        end else begin\n            rst_des_synca <= 1'b0;\n            rst_des_syncb <= rst_des_synca;\n        end\n    end\n\n    assign rst_des_sync = rst_des_syncb;\n\n    always_ff @(posedge src_clock or posedge rst_src_sync) begin\n        if (rst_src_sync) begin\n            pls_toggle <= 1'b0;\n        end else if (src_pulse) begin\n            pls_toggle <= ~pls_toggle;\n        end\n    end\n\n    always_ff @(posedge des_clock or posedge rst_des_sync) begin\n        if (rst_des_sync) begin\n            pls_toggle_synca <= 1'b0;\n            pls_toggle_syncb <= 1'b0;\n        end else begin\n            pls_toggle_synca <= pls_toggle;\n            pls_toggle_syncb <= pls_toggle_synca;\n        end\n    end\n\n    always_ff @(posedge des_clock or posedge rst_des_sync) begin\n        if (rst_des_sync) begin\n            pls_toggle_syncc <= 1'b0;\n        end else begin\n            pls_toggle_syncc <= pls_toggle_syncb;\n        end\n    end\n\n    assign des_pulse = pls_toggle_syncc ^ pls_toggle_syncb;\n\nendmodule"}, "output": {"rtl/cdc_pulse_synchronizer.sv": "module cdc_pulse_synchronizer (\n    input  logic src_clock,       // Source Clock Domain\n    input  logic des_clock,       // Destination Clock Domain\n    input  logic rst_in,          // Asynchronous Active-High Reset\n    input  logic src_pulse,       // Source Pulse\n    output logic des_pulse        // Destination Pulse\n);\n\n    logic pls_toggle;      \n    logic pls_toggle_synca, pls_toggle_syncb, pls_toggle_syncc;\n    logic rst_src_sync;\n    logic rst_des_sync;\n    logic rst_src_synca, rst_src_syncb;\n    logic rst_des_synca, rst_des_syncb;\n\n    always_ff @(posedge src_clock or posedge rst_in) begin\n        if (rst_in) begin\n            rst_src_synca <= 1'b1;\n            rst_src_syncb <= 1'b1;\n        end else begin\n            rst_src_synca <= 1'b0;\n            rst_src_syncb <= rst_src_synca;\n        end\n    end\n\n    assign rst_src_sync = rst_src_syncb;\n\n    always_ff @(posedge des_clock or posedge rst_in) begin\n        if (rst_in) begin\n            rst_des_synca <= 1'b1;\n            rst_des_syncb <= 1'b1;\n        end else begin\n            rst_des_synca <= 1'b0;\n            rst_des_syncb <= rst_des_synca;\n        end\n    end\n\n    assign rst_des_sync = rst_des_syncb;\n\n    always_ff @(posedge src_clock or posedge rst_src_sync) begin\n        if (rst_src_sync) begin\n            pls_toggle <= 1'b0;\n        end else if (src_pulse) begin\n            pls_toggle <= ~pls_toggle;\n        end\n    end\n\n    always_ff @(posedge des_clock or posedge rst_des_sync) begin\n        if (rst_des_sync) begin\n            pls_toggle_synca <= 1'b0;\n            pls_toggle_syncb <= 1'b0;\n        end else begin\n            pls_toggle_synca <= pls_toggle;\n            pls_toggle_syncb <= pls_toggle_synca;\n        end\n    end\n\n    always_ff @(posedge des_clock or posedge rst_des_sync) begin\n        if (rst_des_sync) begin\n            pls_toggle_syncc <= 1'b0;\n        end else begin\n            pls_toggle_syncc <= pls_toggle_syncb;\n        end\n    end\n\n    assign des_pulse = pls_toggle_syncc ^ pls_toggle_syncb;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_cellular_automata_0001": {"input": {}, "output": {"rtl/pseudoRandGenerator_ca.sv": ""}, "obj": true}}
{"cvdp_copilot_cellular_automata_0017": {"input": {"rtl/pseudoRandGenerator_ca.sv": "module pseudoRandGenerator_ca (\n    input  logic       clock,    // Clock input\n    input  logic       reset,    // Active-high synchronous Reset\n    input  logic [15:0] CA_seed,  // 16-bit Cellular Automata seed\n    output logic [15:0] CA_out    // 16-bit Cellular Automata output\n);\n\n    logic q1, q2, q3, q4, q5, q6, q7, q8;\n    logic q9, q10, q11, q12, q13, q14, q15, q16;\n\n    assign q1  = CA_out[14];                             \n    assign q2  = CA_out[15] ^ CA_out[13];                \n    assign q3  = CA_out[14] ^ CA_out[13] ^ CA_out[12];   \n    assign q4  = CA_out[13] ^ CA_out[11];                \n    assign q5  = CA_out[12] ^ CA_out[11] ^ CA_out[10];   \n    assign q6  = CA_out[11] ^ CA_out[9];                 \n    assign q7  = CA_out[10] ^ CA_out[9] ^ CA_out[8];     \n    assign q8  = CA_out[9] ^ CA_out[7];                  \n    assign q9  = CA_out[8] ^ CA_out[7] ^ CA_out[6];      \n    assign q10 = CA_out[7] ^ CA_out[5];                  \n    assign q11 = CA_out[6] ^ CA_out[5] ^ CA_out[4];      \n    assign q12 = CA_out[5] ^ CA_out[3];                  \n    assign q13 = CA_out[4] ^ CA_out[3] ^ CA_out[2];      \n    assign q14 = CA_out[3] ^ CA_out[1];                  \n    assign q15 = CA_out[2] ^ CA_out[1] ^ CA_out[0];      \n    assign q16 = CA_out[1];                              \n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            CA_out <= CA_seed;\n        end else begin\n            CA_out[20] <= q6;\n            CA_out[19] <= q5;\n            CA_out[18] <= q4;\n            CA_out[17] <= q3;\n            CA_out[16] <= q2;\n            CA_out[15] <= q1;\n            CA_out[14] <= q2;\n            CA_out[13] <= q3;\n            CA_out[12] <= q4;\n            CA_out[11] <= q5;\n            CA_out[10] <= q6;\n            CA_out[9]  <= q7;\n            CA_out[8]  <= q8;\n            CA_out[7]  <= q9;\n            CA_out[6]  <= q10;\n            CA_out[5]  <= q11;\n            CA_out[4]  <= q12;\n            CA_out[3]  <= q13;\n            CA_out[2]  <= q14;\n            CA_out[1]  <= q15;\n            CA_out[0]  <= q16;\n        end\n    end\n\nendmodule"}, "output": {"rtl/pseudoRandGenerator_ca.sv": "module pseudoRandGenerator_ca (\n    input  logic       clock,    // Clock input\n    input  logic       reset,    // Active-high synchronous Reset\n    input  logic [15:0] CA_seed,  // 16-bit Cellular Automata seed\n    output logic [15:0] CA_out    // 16-bit Cellular Automata output\n);\n\n    logic q1, q2, q3, q4, q5, q6, q7, q8;\n    logic q9, q10, q11, q12, q13, q14, q15, q16;\n\n    assign q1  = CA_out[14];                             \n    assign q2  = CA_out[15] ^ CA_out[13];                \n    assign q3  = CA_out[14] ^ CA_out[13] ^ CA_out[12];   \n    assign q4  = CA_out[13] ^ CA_out[11];                \n    assign q5  = CA_out[12] ^ CA_out[11] ^ CA_out[10];   \n    assign q6  = CA_out[11] ^ CA_out[9];                 \n    assign q7  = CA_out[10] ^ CA_out[9] ^ CA_out[8];     \n    assign q8  = CA_out[9] ^ CA_out[7];                  \n    assign q9  = CA_out[8] ^ CA_out[7] ^ CA_out[6];      \n    assign q10 = CA_out[7] ^ CA_out[5];                  \n    assign q11 = CA_out[6] ^ CA_out[5] ^ CA_out[4];      \n    assign q12 = CA_out[5] ^ CA_out[3];                  \n    assign q13 = CA_out[4] ^ CA_out[3] ^ CA_out[2];      \n    assign q14 = CA_out[3] ^ CA_out[1];                  \n    assign q15 = CA_out[2] ^ CA_out[1] ^ CA_out[0];      \n    assign q16 = CA_out[1];                              \n\n    always_ff @(posedge clock) begin\n        if (reset) begin\n            CA_out <= CA_seed;\n        end else begin\n            CA_out[20] <= q6;\n            CA_out[19] <= q5;\n            CA_out[18] <= q4;\n            CA_out[17] <= q3;\n            CA_out[16] <= q2;\n            CA_out[15] <= q1;\n            CA_out[14] <= q2;\n            CA_out[13] <= q3;\n            CA_out[12] <= q4;\n            CA_out[11] <= q5;\n            CA_out[10] <= q6;\n            CA_out[9]  <= q7;\n            CA_out[8]  <= q8;\n            CA_out[7]  <= q9;\n            CA_out[6]  <= q10;\n            CA_out[5]  <= q11;\n            CA_out[4]  <= q12;\n            CA_out[3]  <= q13;\n            CA_out[2]  <= q14;\n            CA_out[1]  <= q15;\n            CA_out[0]  <= q16;\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_clock_divider_0003": {"input": {}, "output": {"rtl/clock_divider.sv": ""}, "obj": true}}
{"cvdp_copilot_clock_jitter_detection_module_0003": {"input": {}, "output": {"rtl/clock_jitter_detection_module.sv": ""}, "obj": true}}
{"cvdp_copilot_coffee_machine_0001": {"input": {"rtl/coffee_machine.sv": "module coffee_machine #(\n    parameter NBW_DLY    = 'd5,\n    parameter NBW_BEANS  = 'd2,\n    parameter NS_BEANS   = 'd4,\n    parameter NS_OP      = 'd3, // Fixed\n    parameter NS_SENSOR  = 'd4  // Fixed\n) (\n    input  logic                 clk,\n    input  logic                 rst_async_n,\n    input  logic [NBW_DLY-1:0]   i_grind_delay,\n    input  logic [NBW_DLY-1:0]   i_heat_delay,\n    input  logic [NBW_DLY-1:0]   i_pour_delay,\n    input  logic [NBW_BEANS-1:0] i_bean_sel,\n    input  logic [NS_OP-1:0]     i_operation_sel,\n    input  logic                 i_start,\n    input  logic [NS_SENSOR-1:0] i_sensor,\n    output logic [NS_BEANS-1:0]  o_bean_sel,\n    output logic                 o_grind_beans,\n    output logic                 o_use_powder,\n    output logic                 o_heat_water,\n    output logic                 o_pour_coffee,\n    output logic                 o_error\n);\n\n// Fixed delays (bean selection and powder usage)\nlocalparam SEL_CYCLES    = 'd3;\nlocalparam POWDER_CYCLES = 'd2;\n\ntypedef enum logic [2:0] {\n    IDLE     = 3'b000,\n    BEAN_SEL = 3'b001,\n    GRIND    = 3'b011,\n    POWDER   = 3'b111,\n    HEAT     = 3'b110,\n    POUR     = 3'b100\n} state_t;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nstate_t state_ff, state_nx;\nlogic [NBW_DLY:0]     counter_ff, counter_nx;\nlogic [NBW_DLY-1:0]   grind_delay_ff, heat_delay_ff, pour_delay_ff;\nlogic [NS_OP-1:0]     operation_sel_ff;\nlogic [NBW_BEANS-1:0] bean_sel_in_ff;\nlogic                 start_ff;\n\n// Output assignment (error conditions)\nalways_comb begin : error_logic\n    if(state_ff == IDLE) begin\n        o_error = (i_sensor[0] | i_sensor[3]) | (&i_operation_sel[2:1]) | (i_operation_sel[1] & i_sensor[1]) | ((i_operation_sel[2] || i_operation_sel[0]) & i_sensor[2]);\n    end else begin\n        o_error = i_sensor[3];\n    end\nend\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk) begin : data_regs\n    start_ff <= i_start & ~(i_sensor[0] | i_sensor[3]) & (|i_operation_sel[2:1]) & ~(i_operation_sel[1] & i_sensor[1]) & ~((i_operation_sel == 3'b100 || i_operation_sel == 3'b001) & i_sensor[2]);\n\n    if(i_start && state_ff == IDLE) begin\n        operation_sel_ff <= i_operation_sel;\n        grind_delay_ff   <= i_grind_delay;\n        heat_delay_ff    <= i_heat_delay;\n        pour_delay_ff    <= i_pour_delay;\n        bean_sel_in_ff   <= i_bean_sel;\n    end\n\n    counter_ff      <= counter_nx;\nend\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        state_ff <= IDLE;\n    end else begin\n        state_ff <= state_nx;\n    end\nend\n\n// ----------------------------------------\n// - FSM update\n// ----------------------------------------\nalways_comb begin\n    case(state_ff)\n        IDLE: begin\n            counter_nx = 0;\n\n            if(start_ff) begin\n                if(~(|i_operation_sel[2:1])) begin\n                    state_nx = HEAT;\n                end else if(i_operation_sel[1]) begin\n                    state_nx = BEAN_SEL;\n                end else if(i_operation_sel[0]) begin\n                    state_nx = POUR;\n                end else begin\n                    state_nx = POWDER;\n                end\n            end else begin\n                state_nx = IDLE;\n            end\n        end\n        BEAN_SEL: begin\n            if(counter_ff >= SEL_CYCLES) begin\n                counter_nx = 0;\n                state_nx   = GRIND;\n            end else begin\n                counter_nx = counter_ff + 1'b1;\n                state_nx   = BEAN_SEL;\n            end\n        end\n        GRIND: begin\n            if(counter_ff >= grind_delay_ff) begin\n                counter_nx = 0;\n                if(operation_sel_ff[0]) begin\n                    state_nx = POWDER;\n                end else begin\n                    state_nx = HEAT;\n                end\n            end else begin\n                counter_nx = counter_ff + 1'b1;\n                state_nx   = GRIND;\n            end\n        end\n        POWDER: begin\n            if(counter_ff >= POWDER_CYCLES) begin\n                counter_nx = 0;\n                state_nx   = POUR;\n            end else begin\n                counter_nx = counter_ff + 1'b1;\n                state_nx   = POUR;\n            end\n        end\n        HEAT: begin\n            if(counter_ff >= heat_delay_ff) begin\n                counter_nx = 0;\n                if(|operation_sel_ff[1:0]) begin\n                    state_nx = POWDER;\n                end else begin\n                    state_nx = POUR;\n                end\n            end else begin\n                counter_nx = counter_ff + 1'b1;\n                state_nx   = HEAT;\n            end\n        end\n        POUR: begin\n            if(counter_ff >= pour_delay_ff) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                counter_nx = counter_ff + 1'b1;\n                state_nx   = POUR;\n            end\n        end\n        default: begin\n            counter_nx = 0;\n            state_nx   = IDLE;\n        end\n    endcase\nend\n\n// ----------------------------------------\n// - Controller outputs\n// ----------------------------------------\nalways_comb begin\n    case(state_ff)\n        IDLE: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_use_powder    = 1'b0;\n            o_grind_beans   = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n        end\n        BEAN_SEL: begin\n            o_bean_sel                      = 1'b0; // Set all bits to 0\n            o_bean_sel[bean_sel_in_ff]      = 1'b1; // Only the position of bean_sel_ff should be 1\n            o_grind_beans                   = 1'b0;\n            o_use_powder                    = 1'b0;\n            o_heat_water                    = 1'b0;\n            o_pour_coffee                   = 1'b0;\n        end\n        GRIND: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b1;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n        end\n        POWDER: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b1;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n        end\n        HEAT: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b1;\n            o_pour_coffee   = 1'b0;\n        end\n        POUR: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b1;\n        end\n        default: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n        end\n    endcase\nend\n \nendmodule : coffee_machine"}, "output": {"rtl/coffee_machine.sv": "module coffee_machine #(\n    parameter NBW_DLY    = 'd5,\n    parameter NBW_BEANS  = 'd2,\n    parameter NS_BEANS   = 'd4,\n    parameter NS_OP      = 'd3, // Fixed\n    parameter NS_SENSOR  = 'd4  // Fixed\n) (\n    input  logic                 clk,\n    input  logic                 rst_async_n,\n    input  logic [NBW_DLY-1:0]   i_grind_delay,\n    input  logic [NBW_DLY-1:0]   i_heat_delay,\n    input  logic [NBW_DLY-1:0]   i_pour_delay,\n    input  logic [NBW_BEANS-1:0] i_bean_sel,\n    input  logic [NS_OP-1:0]     i_operation_sel,\n    input  logic                 i_start,\n    input  logic [NS_SENSOR-1:0] i_sensor,\n    output logic [NS_BEANS-1:0]  o_bean_sel,\n    output logic                 o_grind_beans,\n    output logic                 o_use_powder,\n    output logic                 o_heat_water,\n    output logic                 o_pour_coffee,\n    output logic                 o_error\n);\n\n// Fixed delays (bean selection and powder usage)\nlocalparam SEL_CYCLES    = 'd3;\nlocalparam POWDER_CYCLES = 'd2;\n\ntypedef enum logic [2:0] {\n    IDLE     = 3'b000,\n    BEAN_SEL = 3'b001,\n    GRIND    = 3'b011,\n    POWDER   = 3'b111,\n    HEAT     = 3'b110,\n    POUR     = 3'b100\n} state_t;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nstate_t state_ff, state_nx;\nlogic [NBW_DLY:0]     counter_ff, counter_nx;\nlogic [NBW_DLY-1:0]   grind_delay_ff, heat_delay_ff, pour_delay_ff;\nlogic [NS_OP-1:0]     operation_sel_ff;\nlogic [NBW_BEANS-1:0] bean_sel_in_ff;\nlogic                 start_ff;\n\n// Output assignment (error conditions)\nalways_comb begin : error_logic\n    if(state_ff == IDLE) begin\n        o_error = (i_sensor[0] | i_sensor[3]) | (&i_operation_sel[2:1]) | (i_operation_sel[1] & i_sensor[1]) | ((i_operation_sel[2] || i_operation_sel[0]) & i_sensor[2]);\n    end else begin\n        o_error = i_sensor[3];\n    end\nend\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\nalways_ff @(posedge clk) begin : data_regs\n    start_ff <= i_start & ~(i_sensor[0] | i_sensor[3]) & (|i_operation_sel[2:1]) & ~(i_operation_sel[1] & i_sensor[1]) & ~((i_operation_sel == 3'b100 || i_operation_sel == 3'b001) & i_sensor[2]);\n\n    if(i_start && state_ff == IDLE) begin\n        operation_sel_ff <= i_operation_sel;\n        grind_delay_ff   <= i_grind_delay;\n        heat_delay_ff    <= i_heat_delay;\n        pour_delay_ff    <= i_pour_delay;\n        bean_sel_in_ff   <= i_bean_sel;\n    end\n\n    counter_ff      <= counter_nx;\nend\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        state_ff <= IDLE;\n    end else begin\n        state_ff <= state_nx;\n    end\nend\n\n// ----------------------------------------\n// - FSM update\n// ----------------------------------------\nalways_comb begin\n    case(state_ff)\n        IDLE: begin\n            counter_nx = 0;\n\n            if(start_ff) begin\n                if(~(|i_operation_sel[2:1])) begin\n                    state_nx = HEAT;\n                end else if(i_operation_sel[1]) begin\n                    state_nx = BEAN_SEL;\n                end else if(i_operation_sel[0]) begin\n                    state_nx = POUR;\n                end else begin\n                    state_nx = POWDER;\n                end\n            end else begin\n                state_nx = IDLE;\n            end\n        end\n        BEAN_SEL: begin\n            if(counter_ff >= SEL_CYCLES) begin\n                counter_nx = 0;\n                state_nx   = GRIND;\n            end else begin\n                counter_nx = counter_ff + 1'b1;\n                state_nx   = BEAN_SEL;\n            end\n        end\n        GRIND: begin\n            if(counter_ff >= grind_delay_ff) begin\n                counter_nx = 0;\n                if(operation_sel_ff[0]) begin\n                    state_nx = POWDER;\n                end else begin\n                    state_nx = HEAT;\n                end\n            end else begin\n                counter_nx = counter_ff + 1'b1;\n                state_nx   = GRIND;\n            end\n        end\n        POWDER: begin\n            if(counter_ff >= POWDER_CYCLES) begin\n                counter_nx = 0;\n                state_nx   = POUR;\n            end else begin\n                counter_nx = counter_ff + 1'b1;\n                state_nx   = POUR;\n            end\n        end\n        HEAT: begin\n            if(counter_ff >= heat_delay_ff) begin\n                counter_nx = 0;\n                if(|operation_sel_ff[1:0]) begin\n                    state_nx = POWDER;\n                end else begin\n                    state_nx = POUR;\n                end\n            end else begin\n                counter_nx = counter_ff + 1'b1;\n                state_nx   = HEAT;\n            end\n        end\n        POUR: begin\n            if(counter_ff >= pour_delay_ff) begin\n                counter_nx = 0;\n                state_nx   = IDLE;\n            end else begin\n                counter_nx = counter_ff + 1'b1;\n                state_nx   = POUR;\n            end\n        end\n        default: begin\n            counter_nx = 0;\n            state_nx   = IDLE;\n        end\n    endcase\nend\n\n// ----------------------------------------\n// - Controller outputs\n// ----------------------------------------\nalways_comb begin\n    case(state_ff)\n        IDLE: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_use_powder    = 1'b0;\n            o_grind_beans   = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n        end\n        BEAN_SEL: begin\n            o_bean_sel                      = 1'b0; // Set all bits to 0\n            o_bean_sel[bean_sel_in_ff]      = 1'b1; // Only the position of bean_sel_ff should be 1\n            o_grind_beans                   = 1'b0;\n            o_use_powder                    = 1'b0;\n            o_heat_water                    = 1'b0;\n            o_pour_coffee                   = 1'b0;\n        end\n        GRIND: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b1;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n        end\n        POWDER: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b1;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n        end\n        HEAT: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b1;\n            o_pour_coffee   = 1'b0;\n        end\n        POUR: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b1;\n        end\n        default: begin\n            o_bean_sel      = {NS_BEANS{1'b0}};\n            o_grind_beans   = 1'b0;\n            o_use_powder    = 1'b0;\n            o_heat_water    = 1'b0;\n            o_pour_coffee   = 1'b0;\n        end\n    endcase\nend\n \nendmodule : coffee_machine"}, "obj": true}}
{"cvdp_copilot_comparator_0001": {"input": {}, "output": {"rtl/signed_comparator.sv": ""}, "obj": true}}
{"cvdp_copilot_complex_multiplier_0001": {"input": {}, "output": {"rtl/complex_multiplier.sv": ""}, "obj": true}}
{"cvdp_copilot_compression_engine_0001": {"input": {}, "output": {"rtl/compression_engine.sv": ""}, "obj": true}}
{"cvdp_copilot_concatenate_0001": {"input": {}, "output": {"rtl/enhanced_fsm_signal_processor.v": ""}, "obj": true}}
{"cvdp_copilot_configurable_digital_low_pass_filter_0001": {"input": {}, "output": {"rtl/low_pass_filter.sv": ""}, "obj": true}}
{"cvdp_copilot_configurable_digital_low_pass_filter_0004": {"input": {}, "output": {"rtl/decimator_and_peak_detector.sv": ""}, "obj": true}}
{"cvdp_copilot_configurable_digital_low_pass_filter_0011": {"input": {}, "output": {"rtl/sgd_linear_regression.sv": ""}, "obj": true}}
{"cvdp_copilot_configurable_digital_low_pass_filter_0014": {"input": {}, "output": {"rtl/fsm_linear_reg.sv": ""}, "obj": true}}
{"cvdp_copilot_cont_adder_0006": {"input": {"rtl/cont_adder_top.sv": "module continuous_adder (\n    input logic         clk,         // Clock signal\n    input logic         reset,       // Reset signal, Active high and Synchronous\n    input logic [7:0]   data_in,     // Input data stream (8-bit)\n    input logic         data_valid,  // Input data valid signal\n    output logic [7:0]  sum_out,     // Output the accumulated sum\n    output logic        sum_ready    // Signal to indicate sum is output and accumulator is reset\n);\n\n    logic [7:0] sum_accum;          // Internal accumulator to store the running sum\n\n    // Sequential logic for sum accumulation\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            // On reset, clear the accumulator, reset sum_out and sum_ready\n            sum_accum         <= 8'd0;\n            sum_ready         <= 1'b0;\n        end\n        else begin\n            if (data_valid) begin\n                // Add input data to the accumulator\n                sum_accum     <= sum_accum + data_in;\n\n                // Check if the accumulated sum is >= 100\n                if (sum_accum + data_in >= 8'd100) begin\n                    // Output the current sum and reset the accumulator\n                    sum_out   <= sum_accum + data_in; // Output the accumulated sum\n                    sum_ready <= 1'b1;                // Indicate that the sum is ready\n                    sum_accum <= 8'd0;                // Reset the accumulator\n                end\n                else begin\n                    // Continue accumulating, but no output until the sum reaches 100\n                    sum_ready <= 1'b0;                // No output yet\n                end\n            end\n        end\n    end\n\nendmodule"}, "output": {"rtl/cont_adder_top.sv": ""}, "obj": true}}
{"cvdp_copilot_cont_adder_0023": {"input": {"rtl/cont_adder_top.sv": "module continuous_adder #(\n    parameter DATA_WIDTH = 32,                  // Parameter for data width, default is 32 bits\n    parameter THRESHOLD_VALUE = 100,            // Parameter for threshold value, default is 100\n    parameter SIGNED_INPUTS = 1                 // Parameter to enable signed inputs (1 = signed, 0 = unsigned)\n) (\n    input logic                          clk,        // Clock signal\n    input logic                          reset,      // Reset signal, Active high and Synchronous\n    input logic signed [DATA_WIDTH-1:0]  data_in,    // Signed or unsigned input data stream, parameterized width\n    input logic                          data_valid, // Input data valid signal\n    output logic signed [DATA_WIDTH-1:0] sum_out,    // Signed or unsigned output, parameterized width\n    output logic                         sum_ready   // Signal to indicate sum is output and accumulator is reset\n);\n\n    logic signed [DATA_WIDTH-1:0] sum_accum;    // Internal accumulator to store the running sum\n\n    // Sequential logic for sum accumulation\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            // On reset, clear the accumulator, reset sum_out and sum_ready\n            sum_accum         <= {DATA_WIDTH{1'b0}};\n            sum_ready         <= 1'b0;\n            sum_out           <= {DATA_WIDTH{1'b0}};\n        end\n        else begin\n            if (data_valid) begin\n                // Add input data to the accumulator\n                sum_accum     <= sum_accum + data_in;\n\n                // Check if the accumulated sum is >= THRESHOLD_VALUE or <= -THRESHOLD_VALUE based on signed input\n\t\t\t\tif(SIGNED_INPUTS) begin\n                   if ((sum_accum + data_in >= THRESHOLD_VALUE) || (sum_accum + data_in <= -1*THRESHOLD_VALUE)) begin\n                       // Output the current sum and reset the accumulator\n                       sum_out   <= sum_accum + data_in; // Output the accumulated sum\n                       sum_ready <= 1'b1;                // Indicate that the sum is ready\n                       sum_accum <= {DATA_WIDTH{1'b0}};  // Reset the accumulator\n                   end\n                   else begin\n                       // Continue accumulating, but no output until the sum reaches THRESHOLD_VALUE or -THRESHOLD_VALUE\n                       sum_ready <= 1'b0;                // No output yet\n                   end\n\t\t\t\tend else begin\n\t\t\t\t   if (sum_accum + data_in >= THRESHOLD_VALUE) begin\n                       // Output the current sum and reset the accumulator\n                       sum_out   <= sum_accum + data_in; // Output the accumulated sum\n                       sum_ready <= 1'b1;                // Indicate that the sum is ready\n                       sum_accum <= {DATA_WIDTH{1'b0}};  // Reset the accumulator\n                   end\n                   else begin\n                       // Continue accumulating, but no output until the sum reaches THRESHOLD_VALUE or -THRESHOLD_VALUE\n                       sum_ready <= 1'b0;                // No output yet\n                   end\n\t\t\t\tend\n            end\n        end\n    end\n\nendmodule"}, "output": {"rtl/cont_adder_top.sv": ""}, "obj": true}}
{"cvdp_copilot_cont_adder_0042": {"input": {"rtl/cont_adder.sv": "module cont_adder #(\n    parameter DATA_WIDTH = 32,\n    parameter signed THRESHOLD_VALUE_1 = 50,\n    parameter signed THRESHOLD_VALUE_2 = 100,\n    parameter SIGNED_INPUTS = 1,\n    parameter ACCUM_MODE = 0,\n    parameter WEIGHT = 1\n) (\n    input  logic                         clk,\n    input  logic                         reset,\n    input  logic signed [DATA_WIDTH-1:0] data_in,\n    input  logic                         data_valid,\n    input  logic [15:0]                  window_size,\n    output logic signed [DATA_WIDTH-1:0] sum_out,\n    output logic signed [DATA_WIDTH-1:0] avg_out,\n    output logic                         threshold_1,\n    output logic                         threshold_2,\n    output logic                         sum_ready\n);\n\n    // Sequential Registers\n    logic signed [DATA_WIDTH+1:0] sum_accum;\n    logic [15:0]                  sample_count;\n\n    // Combinational Signals\n    logic signed [DATA_WIDTH-1:0] weighted_input;\n    logic signed [DATA_WIDTH-1:0] new_sum;\n    logic                         threshold_1_comb;\n    logic                         threshold_2_comb;\n    logic                         sum_ready_reg;\n\n    // Combinational Logic\n    always_comb begin\n        sum_ready_reg = 0;\n        weighted_input = data_in * WEIGHT;\n        new_sum = sum_accum + weighted_input;\n\n        threshold_1_comb = (new_sum >= THRESHOLD_VALUE_1) || (new_sum <= -THRESHOLD_VALUE_1);\n        threshold_2_comb = (new_sum >= THRESHOLD_VALUE_2) || (new_sum <= -THRESHOLD_VALUE_2);\n\n        if (data_valid) begin\n            if (ACCUM_MODE == 0) begin\n                if (threshold_1_comb || threshold_2_comb) begin\n                    sum_ready_reg = 1;\n                end else begin\n                    sum_ready_reg = 0;\n                end\n            end else if (ACCUM_MODE == 1) begin\n                if ((sample_count + 1) >= window_size) begin\n                    sum_ready_reg = 1;\n                end else begin\n                    sum_ready_reg = 0;\n                end\n            end\n        end else begin\n            sum_ready_reg = 0;\n        end\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            sum_accum     <= 0;\n            sample_count  <= 0;\n            sum_ready     <= 0;\n            sum_out       <= 0;\n            avg_out       <= 0;\n            threshold_1   <= 0;\n            threshold_2   <= 0;\n        end else if (data_valid) begin\n            threshold_1 <= threshold_1_comb;\n            threshold_2 <= threshold_2_comb;\n\n            if (ACCUM_MODE == 1) begin  \n                sum_accum    <= sum_accum + weighted_input;\n                sample_count <= sample_count + 1;\n                if (sum_ready_reg) begin\n                    sum_out      <= sum_accum + weighted_input;\n                    avg_out      <= (sum_accum + weighted_input) / window_size;\n                    sum_ready    <= 1;\n                    sum_accum    <= 0;\n                    sample_count <= 0;\n                end else begin\n                    sum_ready <= 0;\n                    sum_out   <= 0;\n                    avg_out   <= 0;\n                end\n            end else begin  \n                sum_accum <= sum_accum + weighted_input;\n                if (sum_ready_reg) begin\n                    sum_out   <= sum_accum + weighted_input;\n                    sum_ready <= 1;\n                end else begin\n                    sum_ready <= 0;\n                    sum_out   <= 0;\n                end\n                avg_out <= 0; \n            end\n        end else begin\n            sum_ready <= 0;\n        end\n    end\n\nendmodule"}, "output": {"rtl/cont_adder.sv": "module cont_adder #(\n    parameter DATA_WIDTH = 32,\n    parameter signed THRESHOLD_VALUE_1 = 50,\n    parameter signed THRESHOLD_VALUE_2 = 100,\n    parameter SIGNED_INPUTS = 1,\n    parameter ACCUM_MODE = 0,\n    parameter WEIGHT = 1\n) (\n    input  logic                         clk,\n    input  logic                         reset,\n    input  logic signed [DATA_WIDTH-1:0] data_in,\n    input  logic                         data_valid,\n    input  logic [15:0]                  window_size,\n    output logic signed [DATA_WIDTH-1:0] sum_out,\n    output logic signed [DATA_WIDTH-1:0] avg_out,\n    output logic                         threshold_1,\n    output logic                         threshold_2,\n    output logic                         sum_ready\n);\n\n    // Sequential Registers\n    logic signed [DATA_WIDTH+1:0] sum_accum;\n    logic [15:0]                  sample_count;\n\n    // Combinational Signals\n    logic signed [DATA_WIDTH-1:0] weighted_input;\n    logic signed [DATA_WIDTH-1:0] new_sum;\n    logic                         threshold_1_comb;\n    logic                         threshold_2_comb;\n    logic                         sum_ready_reg;\n\n    // Combinational Logic\n    always_comb begin\n        sum_ready_reg = 0;\n        weighted_input = data_in * WEIGHT;\n        new_sum = sum_accum + weighted_input;\n\n        threshold_1_comb = (new_sum >= THRESHOLD_VALUE_1) || (new_sum <= -THRESHOLD_VALUE_1);\n        threshold_2_comb = (new_sum >= THRESHOLD_VALUE_2) || (new_sum <= -THRESHOLD_VALUE_2);\n\n        if (data_valid) begin\n            if (ACCUM_MODE == 0) begin\n                if (threshold_1_comb || threshold_2_comb) begin\n                    sum_ready_reg = 1;\n                end else begin\n                    sum_ready_reg = 0;\n                end\n            end else if (ACCUM_MODE == 1) begin\n                if ((sample_count + 1) >= window_size) begin\n                    sum_ready_reg = 1;\n                end else begin\n                    sum_ready_reg = 0;\n                end\n            end\n        end else begin\n            sum_ready_reg = 0;\n        end\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            sum_accum     <= 0;\n            sample_count  <= 0;\n            sum_ready     <= 0;\n            sum_out       <= 0;\n            avg_out       <= 0;\n            threshold_1   <= 0;\n            threshold_2   <= 0;\n        end else if (data_valid) begin\n            threshold_1 <= threshold_1_comb;\n            threshold_2 <= threshold_2_comb;\n\n            if (ACCUM_MODE == 1) begin  \n                sum_accum    <= sum_accum + weighted_input;\n                sample_count <= sample_count + 1;\n                if (sum_ready_reg) begin\n                    sum_out      <= sum_accum + weighted_input;\n                    avg_out      <= (sum_accum + weighted_input) / window_size;\n                    sum_ready    <= 1;\n                    sum_accum    <= 0;\n                    sample_count <= 0;\n                end else begin\n                    sum_ready <= 0;\n                    sum_out   <= 0;\n                    avg_out   <= 0;\n                end\n            end else begin  \n                sum_accum <= sum_accum + weighted_input;\n                if (sum_ready_reg) begin\n                    sum_out   <= sum_accum + weighted_input;\n                    sum_ready <= 1;\n                end else begin\n                    sum_ready <= 0;\n                    sum_out   <= 0;\n                end\n                avg_out <= 0; \n            end\n        end else begin\n            sum_ready <= 0;\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_cont_adder_0045": {"input": {"rtl/cont_adder.sv": "module cont_adder #(\n  parameter DATA_WIDTH = 32,\n  parameter signed THRESHOLD_VALUE_1 = 50,\n  parameter signed THRESHOLD_VALUE_2 = 100,\n  parameter signed THRESHOLD_VALUE_3 = 150,\n  parameter ACCUM_MODE = 0,\n  parameter WEIGHT = 1,\n  parameter signed SAT_MAX = (2**(DATA_WIDTH-1))-1,\n  parameter signed SAT_MIN = -(2**(DATA_WIDTH-1))\n) (\n  input  logic                         clk,\n  input  logic                         reset,\n  input  logic                         accum_clear,\n  input  logic                         enable,\n  input  logic signed [DATA_WIDTH-1:0] data_in,\n  input  logic                         data_valid,\n  input  logic [15:0]                  window_size,\n  output logic signed [DATA_WIDTH-1:0] sum_out,\n  output logic signed [DATA_WIDTH-1:0] avg_out,\n  output logic                         threshold_1,\n  output logic                         threshold_2,\n  output logic                         threshold_3,\n  output logic                         sum_ready,\n  output logic                         busy\n);\n\n  typedef enum logic [1:0] {IDLE, ACCUM, DONE} state_t;\n  state_t state;\n  logic signed [DATA_WIDTH-1:0] sum_accum;\n  logic [15:0] sample_count;\n  logic signed [DATA_WIDTH-1:0] weighted_in_reg;\n  logic signed [DATA_WIDTH-1:0] new_sum;\n  logic signed [DATA_WIDTH-1:0] sat_sum;\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset)\n      weighted_in_reg <= 0;\n    else if (enable && data_valid) begin\n      if (WEIGHT == 1)\n        weighted_in_reg <= data_in;\n      else\n        weighted_in_reg <= data_in * WEIGHT;\n    end else\n      weighted_in_reg <= weighted_in_reg;\n  end\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n      new_sum <= 0;\n      sat_sum <= 0;\n    end else if (enable && data_valid) begin\n      new_sum <= sum_accum + weighted_in_reg;\n      if ((sum_accum + weighted_in_reg) > SAT_MAX)\n        sat_sum <= SAT_MAX;\n      else if ((sum_accum + weighted_in_reg) < SAT_MIN)\n        sat_sum <= SAT_MIN;\n      else\n        sat_sum <= sum_accum + weighted_in_reg;\n    end\n  end\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n      state <= IDLE;\n      sum_accum <= 0;\n      sample_count <= 0;\n    end else if (accum_clear) begin\n      state <= IDLE;\n      sum_accum <= 0;\n      sample_count <= 0;\n    end else if (enable && data_valid) begin\n      case (state)\n        IDLE: begin\n          state <= ACCUM;\n          sum_accum <= sat_sum;\n          sample_count <= 1;\n        end\n        ACCUM: begin\n          sum_accum <= sat_sum;\n          sample_count <= sample_count + 1;\n          if (ACCUM_MODE == 1) begin\n            if ((sample_count + 1) >= window_size)\n              state <= DONE;\n          end else begin\n            if (((sat_sum >= THRESHOLD_VALUE_1) || (sat_sum <= -THRESHOLD_VALUE_1)) ||\n                ((sat_sum >= THRESHOLD_VALUE_2) || (sat_sum <= -THRESHOLD_VALUE_2)) ||\n                ((sat_sum >= THRESHOLD_VALUE_3) || (sat_sum <= -THRESHOLD_VALUE_3)))\n              state <= DONE;\n          end\n        end\n        DONE: begin\n          state <= IDLE;\n          sum_accum <= 0;\n          sample_count <= 0;\n        end\n        default: state <= IDLE;\n      endcase\n    end\n  end\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n      sum_out <= 0;\n      avg_out <= 0;\n      sum_ready <= 0;\n      threshold_1 <= 0;\n      threshold_2 <= 0;\n      threshold_3 <= 0;\n      busy <= 0;\n    end else begin\n      busy <= (state == ACCUM);\n      if (state == DONE) begin\n        sum_out <= sum_accum;\n        avg_out <= (ACCUM_MODE == 1) ? (sum_accum / sample_count) : 0;\n        sum_ready <= 1;\n        if ((sum_accum >= THRESHOLD_VALUE_1) || (sum_accum <= -THRESHOLD_VALUE_1))\n          threshold_1 <= 1;\n        else\n          threshold_1 <= 0;\n        if ((sum_accum >= THRESHOLD_VALUE_2) || (sum_accum <= -THRESHOLD_VALUE_2))\n          threshold_2 <= 1;\n        else\n          threshold_2 <= 0;\n        if ((sum_accum >= THRESHOLD_VALUE_3) || (sum_accum <= -THRESHOLD_VALUE_3))\n          threshold_3 <= 1;\n        else\n          threshold_3 <= 0;\n      end else begin\n        sum_out <= 0;\n        avg_out <= 0;\n        sum_ready <= 0;\n        threshold_1 <= 0;\n        threshold_2 <= 0;\n        threshold_3 <= 0;\n      end\n    end\n  end\n\nendmodule"}, "output": {"rtl/cont_adder.sv": "module cont_adder #(\n  parameter DATA_WIDTH = 32,\n  parameter signed THRESHOLD_VALUE_1 = 50,\n  parameter signed THRESHOLD_VALUE_2 = 100,\n  parameter signed THRESHOLD_VALUE_3 = 150,\n  parameter ACCUM_MODE = 0,\n  parameter WEIGHT = 1,\n  parameter signed SAT_MAX = (2**(DATA_WIDTH-1))-1,\n  parameter signed SAT_MIN = -(2**(DATA_WIDTH-1))\n) (\n  input  logic                         clk,\n  input  logic                         reset,\n  input  logic                         accum_clear,\n  input  logic                         enable,\n  input  logic signed [DATA_WIDTH-1:0] data_in,\n  input  logic                         data_valid,\n  input  logic [15:0]                  window_size,\n  output logic signed [DATA_WIDTH-1:0] sum_out,\n  output logic signed [DATA_WIDTH-1:0] avg_out,\n  output logic                         threshold_1,\n  output logic                         threshold_2,\n  output logic                         threshold_3,\n  output logic                         sum_ready,\n  output logic                         busy\n);\n\n  typedef enum logic [1:0] {IDLE, ACCUM, DONE} state_t;\n  state_t state;\n  logic signed [DATA_WIDTH-1:0] sum_accum;\n  logic [15:0] sample_count;\n  logic signed [DATA_WIDTH-1:0] weighted_in_reg;\n  logic signed [DATA_WIDTH-1:0] new_sum;\n  logic signed [DATA_WIDTH-1:0] sat_sum;\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset)\n      weighted_in_reg <= 0;\n    else if (enable && data_valid) begin\n      if (WEIGHT == 1)\n        weighted_in_reg <= data_in;\n      else\n        weighted_in_reg <= data_in * WEIGHT;\n    end else\n      weighted_in_reg <= weighted_in_reg;\n  end\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n      new_sum <= 0;\n      sat_sum <= 0;\n    end else if (enable && data_valid) begin\n      new_sum <= sum_accum + weighted_in_reg;\n      if ((sum_accum + weighted_in_reg) > SAT_MAX)\n        sat_sum <= SAT_MAX;\n      else if ((sum_accum + weighted_in_reg) < SAT_MIN)\n        sat_sum <= SAT_MIN;\n      else\n        sat_sum <= sum_accum + weighted_in_reg;\n    end\n  end\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n      state <= IDLE;\n      sum_accum <= 0;\n      sample_count <= 0;\n    end else if (accum_clear) begin\n      state <= IDLE;\n      sum_accum <= 0;\n      sample_count <= 0;\n    end else if (enable && data_valid) begin\n      case (state)\n        IDLE: begin\n          state <= ACCUM;\n          sum_accum <= sat_sum;\n          sample_count <= 1;\n        end\n        ACCUM: begin\n          sum_accum <= sat_sum;\n          sample_count <= sample_count + 1;\n          if (ACCUM_MODE == 1) begin\n            if ((sample_count + 1) >= window_size)\n              state <= DONE;\n          end else begin\n            if (((sat_sum >= THRESHOLD_VALUE_1) || (sat_sum <= -THRESHOLD_VALUE_1)) ||\n                ((sat_sum >= THRESHOLD_VALUE_2) || (sat_sum <= -THRESHOLD_VALUE_2)) ||\n                ((sat_sum >= THRESHOLD_VALUE_3) || (sat_sum <= -THRESHOLD_VALUE_3)))\n              state <= DONE;\n          end\n        end\n        DONE: begin\n          state <= IDLE;\n          sum_accum <= 0;\n          sample_count <= 0;\n        end\n        default: state <= IDLE;\n      endcase\n    end\n  end\n\n  always_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n      sum_out <= 0;\n      avg_out <= 0;\n      sum_ready <= 0;\n      threshold_1 <= 0;\n      threshold_2 <= 0;\n      threshold_3 <= 0;\n      busy <= 0;\n    end else begin\n      busy <= (state == ACCUM);\n      if (state == DONE) begin\n        sum_out <= sum_accum;\n        avg_out <= (ACCUM_MODE == 1) ? (sum_accum / sample_count) : 0;\n        sum_ready <= 1;\n        if ((sum_accum >= THRESHOLD_VALUE_1) || (sum_accum <= -THRESHOLD_VALUE_1))\n          threshold_1 <= 1;\n        else\n          threshold_1 <= 0;\n        if ((sum_accum >= THRESHOLD_VALUE_2) || (sum_accum <= -THRESHOLD_VALUE_2))\n          threshold_2 <= 1;\n        else\n          threshold_2 <= 0;\n        if ((sum_accum >= THRESHOLD_VALUE_3) || (sum_accum <= -THRESHOLD_VALUE_3))\n          threshold_3 <= 1;\n        else\n          threshold_3 <= 0;\n      end else begin\n        sum_out <= 0;\n        avg_out <= 0;\n        sum_ready <= 0;\n        threshold_1 <= 0;\n        threshold_2 <= 0;\n        threshold_3 <= 0;\n      end\n    end\n  end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_convolutional_encoder_0001": {"input": {}, "output": {"rtl/convolutional_encoder.sv": ""}, "obj": true}}
{"cvdp_copilot_convolutional_encoder_0010": {"input": {}, "output": {"rtl/cvdp_convolutional_encoder_RTL_comp.sv": ""}, "obj": true}}
{"cvdp_copilot_crossbar_switch_0001": {"input": {}, "output": {"rtl/crossbar_switch.sv": ""}, "obj": true}}
{"cvdp_copilot_data_bus_controller_0001": {"input": {}, "output": {"rtl/data_bus_controller.sv": ""}, "obj": true}}
{"cvdp_copilot_data_serializer_0001": {"input": {"rtl/data_serializer.sv": "module data_serializer #(\n  parameter DATA_W   = 8,\n  parameter BIT_ORDER= 0,\n  parameter PARITY   = 0\n)(\n  input                  clk,\n  input                  reset,\n  // Parallel data interface\n  input                  p_valid_i,\n  input  [DATA_W-1:0]    p_data_i,\n  output                 p_ready_o,\n  // Serial data interface\n  output                 s_valid_o,\n  output                 s_data_o,\n  input                  s_ready_i,\n  // Transmission enable\n  input                  tx_en_i\n);\n\n  // Local constants\n  localparam ST_RX = 1'b0;\n  localparam ST_TX = 1'b1;\n\n  // If PARITY != 0 => We use 1 extra bit for parity\n  localparam EXTRA_BIT = (PARITY == 0) ? 0 : 1;\n  localparam SHIFT_W   = DATA_W + EXTRA_BIT;\n\n  // Internal regs\n  reg                    state_q, state_d;\n  reg  [SHIFT_W-1:0]     shift_reg_q, shift_reg_d;\n  reg  [$clog2(SHIFT_W)-1:0] count_q, count_d;\n\n  // Parity calculation\n  wire parity_bit_even = ^p_data_i;   // XOR => \"even\"\n  wire parity_bit_odd  = ~^p_data_i;  // invert XOR => \"odd\"\n\n  wire parity_bit = (PARITY == 1) ? parity_bit_even :\n                    (PARITY == 2) ? parity_bit_odd  :\n                                    1'b0; // NONE\n\n  // Sequential state & register updates\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      state_q     <= ST_RX;\n      shift_reg_q <= {SHIFT_W{1'b0}};\n      count_q     <= 0;\n    end else begin\n      state_q     <= state_d;\n      shift_reg_q <= shift_reg_d;\n      count_q     <= count_d;\n    end\n  end\n\n  // Next-state logic\n  always @* begin\n    // Default assignments\n    state_d     = state_q;\n    shift_reg_d = shift_reg_q;\n    count_d     = count_q;\n\n    case (state_q)\n\n      // ST_RX: Load parallel data + parity\n      ST_RX: begin\n        if (p_valid_i) begin\n          if (BIT_ORDER == 0) begin\n            // LSB-first => store LSB in shift_reg_d[0]\n            if (EXTRA_BIT == 1)\n              shift_reg_d = {parity_bit, p_data_i};  // 9 bits if PARITY!=0\n            else\n              shift_reg_d = p_data_i;                // 8 bits if PARITY=0\n          end\n          else begin\n            // MSB-first => store MSB in shift_reg_d[SHIFT_W-1]\n            // If parity is used, it goes in the LSB or SHIFT_W-1?\n            // We'll put it in the LSB if EXTRA_BIT=1\n            if (EXTRA_BIT == 1) begin\n              shift_reg_d[8:4] = {p_data_i[4:0],parity_bit};\n              shift_reg_d[3:0] = p_data_i[8:5];\n            end else\n              shift_reg_d = p_data_i;\n          end\n\n          count_d = 0;\n          state_d = ST_TX;\n        end\n      end\n\n      // ST_TX: Shift bits out until SHIFT_W done\n      ST_TX: begin\n        // Only shift if s_ready_i & tx_en_i\n        if (s_ready_i && tx_en_i) begin\n          if (count_q == (SHIFT_W - 1)) begin\n            // Done sending SHIFT_W bits\n            state_d   = ST_RX;\n            count_d   = 0;\n          end\n          else begin\n            if (BIT_ORDER == 1) begin\n              if (EXTRA_BIT == 1) begin\n                // SHIFT left by 2 bits\n                shift_reg_d[SHIFT_W-1:2] = shift_reg_q[SHIFT_W-3:0];\n                shift_reg_d[1:0]         = 2'b00;\n                count_d                  = count_q + 2;\n              end\n              else begin\n                // Normal MSB-first => shift left by 1\n                shift_reg_d = {shift_reg_q[SHIFT_W-2:0], 1'b0};\n                count_d     = count_q + 1;\n              end\n            end\n            else begin\n              // LSB-first => shift right by 1 (no bug)\n              shift_reg_d = {1'b0, shift_reg_q[SHIFT_W-1:1]};\n              count_d     = count_q + 1;\n            end\n          end\n        end\n      end\n\n      default: begin\n        state_d = ST_RX; // safe fallback\n      end\n    endcase\n  end\n\n  // Outputs\n  assign s_valid_o = (state_q == ST_TX);\n\n  // LSB-first => s_data_o = shift_reg_q[0]\n  // MSB-first => s_data_o = shift_reg_q[SHIFT_W-1]\n  assign s_data_o  = (BIT_ORDER == 0) ? shift_reg_q[0] : shift_reg_q[SHIFT_W-1];\n\n  assign p_ready_o = (state_q == ST_RX);\n\nendmodule"}, "output": {"rtl/data_serializer.sv": ""}, "obj": true}}
{"cvdp_copilot_data_width_converter_0003": {"input": {}, "output": {"rtl/data_width_converter.sv": ""}, "obj": true}}
{"cvdp_copilot_dbi_0001": {"input": {}, "output": {"rtl/dbi_enc.sv": ""}, "obj": true}}
{"cvdp_copilot_dbi_0008": {"input": {"rtl/dbi_enc.sv": "module dbi_enc(\n   // Inputs\n   input  wire        rst_n,   // Asynchronous reset\n   input  wire        clk,     // Clock\n   input  wire [39:0] data_in, // Data input before DBI logic\n   // Outputs\n   output wire [4:0] dbi_cntrl,\n   output wire [39:0] data_out // Data output after DBI logic\n   );\n   wire [39:0] next_dbi_data_out; //calculated dbi_out\n   wire [7:0] dat0;       //  data group 1 to 8               \n   wire [7:0] dat1;       // data group 9 to 16 \n   wire [7:0] dat2;       //  data group 17 to 24              \n   wire [7:0] dat3;       // data group 25 to 32   \n   wire [7:0] dat4;       // data group  33 to 40 \n   wire [7:0] prev_dat0;    // Prev data group                           \n   wire [7:0] prev_dat1;    // Prev data group\n   wire [7:0] prev_dat2;    // Prev data group                           \n   wire [7:0] prev_dat3;    // Prev data group                 \n   wire [7:0] prev_dat4;    // Prev data group                 \n   wire [4:0] dbi_bits;     // dbi_bits[0]       \n                            // dbi_bits[1] \n   reg  [44:0] dbi_data_out; // Registers to latch data after DBI calculations\n   \n   assign data_out = dbi_data_out[39:0];\n   assign dbi_cntrl = dbi_data_out[44:40];\n   assign {dat4,dat3,dat2,dat1,dat0} = data_in;\n   assign dbi_bits[4:0] = {(dbi_bit(dat4[7:0],prev_dat4[7:0])),\n                   (dbi_bit(dat3[7:0],prev_dat3[7:0])),\n                   (dbi_bit(dat2[7:0],prev_dat2[7:0])),\n                   (dbi_bit(dat1[7:0],prev_dat1[7:0])),\n                   (dbi_bit(dat0[7:0],prev_dat0[7:0]))};\n                   \n    assign next_dbi_data_out = { ({8{dbi_bits[4]}} ^ dat4 ), ({8{dbi_bits[3]}} ^ dat3 ), ({8{dbi_bits[2]}} ^ dat2) , ({8{dbi_bits[1]}} ^ dat1) ,\n                                 ({8{dbi_bits[0]}} ^ dat0)  };\n   \n    assign prev_dat0 = dbi_data_out[7:0];//Prev  0 data group. Used to dbi contrl\n    assign prev_dat1 = dbi_data_out[15:8];//Prev  1 data group. Used to get dbi contrl\n    assign prev_dat2 = dbi_data_out[23:16];//Prev 2 data group. Used to get dbi contrl\n    assign prev_dat3 = dbi_data_out[31:24];//Prev  3 data group. Used to get dbi contrl\n    assign prev_dat4 = dbi_data_out[39:32];//Prev 4 data group. Used to get dbi contrl\n\n   \n   // DBI data output registered\nalways @(posedge clk or negedge rst_n)\n  begin: dbi_data_out_register\n    if (!rst_n)\n      begin\n        dbi_data_out <= 45'h0;\n      end\n    else\n      begin\n        dbi_data_out <= {dbi_bits,next_dbi_data_out};\n      end\n  end \n   \n   \n   \n  // Function to calculate each DBI bit                          \nfunction automatic reg dbi_bit (\n  input [7:0] cur_d,  // Current data\n  input [7:0] prv_d); // Previous data\n  integer          i;  // Integer index\n  reg [4:0] tmp;       // Counter Variable\n  reg [7:0] temp_dat;  // Intermediate DBI value\n\n  tmp = 5'd0;                            \n  for (i=0; i<8; i=i+1)                 \n    begin                                \n      temp_dat[i] = cur_d[i] ^ prv_d[i];  \n      tmp = tmp + temp_dat[i];            \n    end                              \n dbi_bit = (tmp > 4) ? 1 : 0;\n\nendfunction\n   \n   \n   \nendmodule"}, "output": {"rtl/dbi_enc.sv": "module dbi_enc(\n   // Inputs\n   input  wire        rst_n,   // Asynchronous reset\n   input  wire        clk,     // Clock\n   input  wire [39:0] data_in, // Data input before DBI logic\n   // Outputs\n   output wire [4:0] dbi_cntrl,\n   output wire [39:0] data_out // Data output after DBI logic\n   );\n   wire [39:0] next_dbi_data_out; //calculated dbi_out\n   wire [7:0] dat0;       //  data group 1 to 8               \n   wire [7:0] dat1;       // data group 9 to 16 \n   wire [7:0] dat2;       //  data group 17 to 24              \n   wire [7:0] dat3;       // data group 25 to 32   \n   wire [7:0] dat4;       // data group  33 to 40 \n   wire [7:0] prev_dat0;    // Prev data group                           \n   wire [7:0] prev_dat1;    // Prev data group\n   wire [7:0] prev_dat2;    // Prev data group                           \n   wire [7:0] prev_dat3;    // Prev data group                 \n   wire [7:0] prev_dat4;    // Prev data group                 \n   wire [4:0] dbi_bits;     // dbi_bits[0]       \n                            // dbi_bits[1] \n   reg  [44:0] dbi_data_out; // Registers to latch data after DBI calculations\n   \n   assign data_out = dbi_data_out[39:0];\n   assign dbi_cntrl = dbi_data_out[44:40];\n   assign {dat4,dat3,dat2,dat1,dat0} = data_in;\n   assign dbi_bits[4:0] = {(dbi_bit(dat4[7:0],prev_dat4[7:0])),\n                   (dbi_bit(dat3[7:0],prev_dat3[7:0])),\n                   (dbi_bit(dat2[7:0],prev_dat2[7:0])),\n                   (dbi_bit(dat1[7:0],prev_dat1[7:0])),\n                   (dbi_bit(dat0[7:0],prev_dat0[7:0]))};\n                   \n    assign next_dbi_data_out = { ({8{dbi_bits[4]}} ^ dat4 ), ({8{dbi_bits[3]}} ^ dat3 ), ({8{dbi_bits[2]}} ^ dat2) , ({8{dbi_bits[1]}} ^ dat1) ,\n                                 ({8{dbi_bits[0]}} ^ dat0)  };\n   \n    assign prev_dat0 = dbi_data_out[7:0];//Prev  0 data group. Used to dbi contrl\n    assign prev_dat1 = dbi_data_out[15:8];//Prev  1 data group. Used to get dbi contrl\n    assign prev_dat2 = dbi_data_out[23:16];//Prev 2 data group. Used to get dbi contrl\n    assign prev_dat3 = dbi_data_out[31:24];//Prev  3 data group. Used to get dbi contrl\n    assign prev_dat4 = dbi_data_out[39:32];//Prev 4 data group. Used to get dbi contrl\n\n   \n   // DBI data output registered\nalways @(posedge clk or negedge rst_n)\n  begin: dbi_data_out_register\n    if (!rst_n)\n      begin\n        dbi_data_out <= 45'h0;\n      end\n    else\n      begin\n        dbi_data_out <= {dbi_bits,next_dbi_data_out};\n      end\n  end \n   \n   \n   \n  // Function to calculate each DBI bit                          \nfunction automatic reg dbi_bit (\n  input [7:0] cur_d,  // Current data\n  input [7:0] prv_d); // Previous data\n  integer          i;  // Integer index\n  reg [4:0] tmp;       // Counter Variable\n  reg [7:0] temp_dat;  // Intermediate DBI value\n\n  tmp = 5'd0;                            \n  for (i=0; i<8; i=i+1)                 \n    begin                                \n      temp_dat[i] = cur_d[i] ^ prv_d[i];  \n      tmp = tmp + temp_dat[i];            \n    end                              \n dbi_bit = (tmp > 4) ? 1 : 0;\n\nendfunction\n   \n   \n   \nendmodule"}, "obj": true}}
{"cvdp_copilot_dbi_dec_0001": {"input": {}, "output": {"rtl/dbi_dec.sv": ""}, "obj": true}}
{"cvdp_copilot_decode_firstbit_0001": {"input": {}, "output": {"rtl/cvdp_copilot_decode_firstbit.sv": ""}, "obj": true}}
{"cvdp_copilot_decoder_8b10b_0001": {"input": {}, "output": {"rtl/decoder_8b10b.sv": ""}, "obj": true}}
{"cvdp_copilot_digital_dice_roller_0001": {"input": {}, "output": {"rtl/digital_dice_roller.sv": ""}, "obj": true}}
{"cvdp_copilot_digital_dice_roller_0004": {"input": {"rtl/digital_dice_roller.sv": "module digital_dice_roller #(\n    parameter int DICE_MAX  = 6,                    // Maximum dice value\n    parameter int BIT_WIDTH = $clog2(DICE_MAX) + 1  // Bit width to represent dice value\n) (\n    input wire clk,\n    input wire reset,  // Asynchronous reset signal\n    input wire button,\n    output reg [BIT_WIDTH-1:0] dice_value\n);\n\n  // State encoding\n  typedef enum logic [1:0] {\n    IDLE    = 2'b00,\n    ROLLING = 2'b01\n  } state_t;\n\n  state_t current_state, next_state;\n  reg [BIT_WIDTH-1:0] counter;  // Counter to represent dice values\n\n  // State transition and asynchronous reset logic (sequential)\n  always_ff @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      // Reset to initial values when async_reset is asserted\n      current_state <= IDLE;\n      counter <= 1;\n      dice_value <= 1;\n    end else begin\n      current_state <= next_state;\n    end\n  end\n\n  // Next state logic and counter increment (combinational)\n  always_comb begin\n    next_state = current_state;\n\n    case (current_state)\n      IDLE: begin\n        if (button) next_state = ROLLING;\n      end\n\n      ROLLING: begin\n        if (!button) next_state = IDLE;\n      end\n    endcase\n  end\n\n  // Counter logic to simulate rolling dice values from 1 to DICE_MAX\n  always_ff @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      // Reset counter and dice value when async_reset is asserted\n      counter <= 1;\n      dice_value <= 1;\n    end else if (current_state == ROLLING) begin\n      if (counter == DICE_MAX) counter <= 1;  // Reset to 1 after reaching DICE_MAX\n      else counter <= counter + 1;\n    end else if (current_state == IDLE) begin\n      dice_value <= counter;  // Latch the final value\n    end\n  end\nendmodule"}, "output": {"rtl/digital_dice_roller.sv": "module digital_dice_roller #(\n    parameter int DICE_MAX  = 6,                    // Maximum dice value\n    parameter int BIT_WIDTH = $clog2(DICE_MAX) + 1  // Bit width to represent dice value\n) (\n    input wire clk,\n    input wire reset,  // Asynchronous reset signal\n    input wire button,\n    output reg [BIT_WIDTH-1:0] dice_value\n);\n\n  // State encoding\n  typedef enum logic [1:0] {\n    IDLE    = 2'b00,\n    ROLLING = 2'b01\n  } state_t;\n\n  state_t current_state, next_state;\n  reg [BIT_WIDTH-1:0] counter;  // Counter to represent dice values\n\n  // State transition and asynchronous reset logic (sequential)\n  always_ff @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      // Reset to initial values when async_reset is asserted\n      current_state <= IDLE;\n      counter <= 1;\n      dice_value <= 1;\n    end else begin\n      current_state <= next_state;\n    end\n  end\n\n  // Next state logic and counter increment (combinational)\n  always_comb begin\n    next_state = current_state;\n\n    case (current_state)\n      IDLE: begin\n        if (button) next_state = ROLLING;\n      end\n\n      ROLLING: begin\n        if (!button) next_state = IDLE;\n      end\n    endcase\n  end\n\n  // Counter logic to simulate rolling dice values from 1 to DICE_MAX\n  always_ff @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      // Reset counter and dice value when async_reset is asserted\n      counter <= 1;\n      dice_value <= 1;\n    end else if (current_state == ROLLING) begin\n      if (counter == DICE_MAX) counter <= 1;  // Reset to 1 after reaching DICE_MAX\n      else counter <= counter + 1;\n    end else if (current_state == IDLE) begin\n      dice_value <= counter;  // Latch the final value\n    end\n  end\nendmodule"}, "obj": true}}
{"cvdp_copilot_digital_stopwatch_0001": {"input": {}, "output": {"rtl/dig_stopwatch.sv": ""}, "obj": true}}
{"cvdp_copilot_digital_stopwatch_0012": {"input": {"rtl/dig_stopwatch.sv": "module dig_stopwatch #(\n    parameter CLK_FREQ = 50000000  // Default clock frequency is 50 MHz\n)(\n    input wire clk,                // Input clock (parameterized frequency)\n    input wire reset,              // Reset signal\n    input wire start_stop,         // Start/Stop control\n    output reg [5:0] seconds,      // Seconds counter (0-59)\n    output reg [5:0] minutes,      // Minutes counter (0-59)\n    output reg hour                // Hour counter \n);\n\n    localparam COUNTER_MAX = CLK_FREQ - 1;  // Calculate max counter value\n    reg [$clog2(COUNTER_MAX):0] counter;    // Clock divider counter width based on CLK_FREQ\n    reg one_sec_pulse;                      // One second pulse signal\n\n    // Clock divider to create a 1 Hz clock pulse from parameterized frequency\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 0;\n            one_sec_pulse <= 0;\n        end else begin\n            if (start_stop) begin\n                if (counter == COUNTER_MAX) begin\n                    counter <= 0;\n                    one_sec_pulse <= 1'b1;        // Generate a pulse every second\n                end else begin\n                    counter <= counter + 1;\n                    one_sec_pulse <= 1'b0;\n                end\n            end else begin\n                one_sec_pulse <= 1'b0;           // Ensure one_sec_pulse is cleared if paused\n            end\n        end\n    end\n\n    // Stopwatch logic\n    always @(posedge one_sec_pulse or posedge reset) begin\n        if (reset) begin\n            seconds <= 6'b0;\n            minutes <= 6'b0;\n            hour <= 1'b0;\n        end else if (start_stop == 1 && hour == 0) begin\n            if (seconds < 59) begin\n                seconds <= seconds + 1'b1;\n            end else begin\n                seconds <= 6'b0;\n                if (minutes < 59) begin\n                    minutes <= minutes + 1'b1;\n                end else begin\n                    minutes <= 6'b0;\n                    hour <= 1'b1;\n                end\n            end\n        end\n    end\n\nendmodule"}, "output": {"rtl/dig_stopwatch.sv": "module dig_stopwatch #(\n    parameter CLK_FREQ = 50000000  // Default clock frequency is 50 MHz\n)(\n    input wire clk,                // Input clock (parameterized frequency)\n    input wire reset,              // Reset signal\n    input wire start_stop,         // Start/Stop control\n    output reg [5:0] seconds,      // Seconds counter (0-59)\n    output reg [5:0] minutes,      // Minutes counter (0-59)\n    output reg hour                // Hour counter \n);\n\n    localparam COUNTER_MAX = CLK_FREQ - 1;  // Calculate max counter value\n    reg [$clog2(COUNTER_MAX):0] counter;    // Clock divider counter width based on CLK_FREQ\n    reg one_sec_pulse;                      // One second pulse signal\n\n    // Clock divider to create a 1 Hz clock pulse from parameterized frequency\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 0;\n            one_sec_pulse <= 0;\n        end else begin\n            if (start_stop) begin\n                if (counter == COUNTER_MAX) begin\n                    counter <= 0;\n                    one_sec_pulse <= 1'b1;        // Generate a pulse every second\n                end else begin\n                    counter <= counter + 1;\n                    one_sec_pulse <= 1'b0;\n                end\n            end else begin\n                one_sec_pulse <= 1'b0;           // Ensure one_sec_pulse is cleared if paused\n            end\n        end\n    end\n\n    // Stopwatch logic\n    always @(posedge one_sec_pulse or posedge reset) begin\n        if (reset) begin\n            seconds <= 6'b0;\n            minutes <= 6'b0;\n            hour <= 1'b0;\n        end else if (start_stop == 1 && hour == 0) begin\n            if (seconds < 59) begin\n                seconds <= seconds + 1'b1;\n            end else begin\n                seconds <= 6'b0;\n                if (minutes < 59) begin\n                    minutes <= minutes + 1'b1;\n                end else begin\n                    minutes <= 6'b0;\n                    hour <= 1'b1;\n                end\n            end\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_dot_product_0002": {"input": {}, "output": {"rtl/dot_product.sv": ""}, "obj": true}}
{"cvdp_copilot_dot_product_0005": {"input": {"rtl/dot_product.sv": "module dot_product (\n    input               clk_in,                     // Clock signal\n    input               reset_in,                   // Asynchronous Reset signal, Active HIGH\n    input               start_in,                   // Start computation signal\n    input       [6:0]   dot_length_in,              // Length of the dot product vectors\n    input       [7:0]   vector_a_in,                // Input vector A (8-bit)\n    input               vector_a_valid_in,          // Valid signal for vector A\n    input       [15:0]  vector_b_in,                // Input vector B (16-bit)\n    input               vector_b_valid_in,          // Valid signal for vector B\n    output reg  [31:0]  dot_product_out,            // Output dot product result (32-bit)\n    output reg          dot_product_valid_out       // Valid signal for dot product output\n);\n\n    typedef enum logic [1:0] {\n        IDLE    = 2'b00,\n        COMPUTE = 2'b01,\n        OUTPUT  = 2'b10\n    } state_t;\n\n    state_t state;\n    reg [31:0] acc;\n    reg [6:0] cnt;\n    reg [6:0] dot_length_reg;\n    reg vector_a_valid_in_prev;\n    reg vector_b_valid_in_prev;\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            state <= IDLE;\n            acc <= 0;\n            cnt <= 0;\n            dot_product_out <= 0;\n            dot_product_valid_out <= 0;\n            dot_length_reg <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    dot_product_valid_out <= 0;\n                    dot_length_reg <= dot_length_in;\n                    if (start_in) begin\n                        state <= COMPUTE;\n                        acc <= 0;\n                        cnt <= 0;\n                    end\n                end\n                COMPUTE: begin\n                    if (vector_a_valid_in && vector_b_valid_in) begin\n                        acc <= acc + (vector_a_in * vector_b_in);\n                        cnt <= cnt + 1;\n                    end\n                    if (cnt == dot_length_reg - 1) begin\n                        state <= OUTPUT;\n                    end else begin\n                        state <= COMPUTE;\n                    end\n                end\n                OUTPUT: begin\n                    dot_product_out <= acc;\n                    dot_product_valid_out <= 1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}, "output": {"rtl/dot_product.sv": "module dot_product (\n    input               clk_in,                     // Clock signal\n    input               reset_in,                   // Asynchronous Reset signal, Active HIGH\n    input               start_in,                   // Start computation signal\n    input       [6:0]   dot_length_in,              // Length of the dot product vectors\n    input       [7:0]   vector_a_in,                // Input vector A (8-bit)\n    input               vector_a_valid_in,          // Valid signal for vector A\n    input       [15:0]  vector_b_in,                // Input vector B (16-bit)\n    input               vector_b_valid_in,          // Valid signal for vector B\n    output reg  [31:0]  dot_product_out,            // Output dot product result (32-bit)\n    output reg          dot_product_valid_out       // Valid signal for dot product output\n);\n\n    typedef enum logic [1:0] {\n        IDLE    = 2'b00,\n        COMPUTE = 2'b01,\n        OUTPUT  = 2'b10\n    } state_t;\n\n    state_t state;\n    reg [31:0] acc;\n    reg [6:0] cnt;\n    reg [6:0] dot_length_reg;\n    reg vector_a_valid_in_prev;\n    reg vector_b_valid_in_prev;\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            state <= IDLE;\n            acc <= 0;\n            cnt <= 0;\n            dot_product_out <= 0;\n            dot_product_valid_out <= 0;\n            dot_length_reg <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    dot_product_valid_out <= 0;\n                    dot_length_reg <= dot_length_in;\n                    if (start_in) begin\n                        state <= COMPUTE;\n                        acc <= 0;\n                        cnt <= 0;\n                    end\n                end\n                COMPUTE: begin\n                    if (vector_a_valid_in && vector_b_valid_in) begin\n                        acc <= acc + (vector_a_in * vector_b_in);\n                        cnt <= cnt + 1;\n                    end\n                    if (cnt == dot_length_reg - 1) begin\n                        state <= OUTPUT;\n                    end else begin\n                        state <= COMPUTE;\n                    end\n                end\n                OUTPUT: begin\n                    dot_product_out <= acc;\n                    dot_product_valid_out <= 1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_dot_product_0012": {"input": {"rtl/dot_product.sv": "module dot_product (\n    input               clk_in,                     // Clock signal\n    input               reset_in,                   // Asynchronous Reset signal, Active HIGH\n    input               start_in,                   // Start computation signal\n    input       [6:0]   dot_length_in,              // Length of the dot product vectors\n    input       [7:0]   vector_a_in,                // Input vector A (8-bit)\n    input               vector_a_valid_in,          // Valid signal for vector A\n    input       [15:0]  vector_b_in,                // Input vector B (16-bit)\n    input               vector_b_valid_in,          // Valid signal for vector B\n    output reg  [31:0]  dot_product_out,            // Output dot product result (32-bit)\n    output reg          dot_product_valid_out       // Valid signal for dot product output\n);\n\n    typedef enum logic [1:0] {\n        IDLE    = 2'b00,\n        COMPUTE = 2'b01,\n        OUTPUT  = 2'b10\n    } state_t;\n\n    state_t state;\n    reg [31:0] acc;\n    reg [6:0] cnt;\n    reg [6:0] dot_length_reg;\n    reg vector_a_valid_in_prev;\n    reg vector_b_valid_in_prev;\n\n    always @(posedge clk_in or posedge reset_in) begin\n        if (reset_in) begin\n            state <= IDLE;\n            acc <= 0;\n            cnt <= 0;\n            dot_product_out <= 0;\n            dot_product_valid_out <= 0;\n            dot_length_reg <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    dot_product_valid_out <= 0;\n                    dot_length_reg <= dot_length_in;\n                    if (start_in) begin\n                        state <= COMPUTE;\n                        acc <= 0;\n                        cnt <= 0;\n                    end\n                end\n                COMPUTE: begin\n                    if (vector_a_valid_in && vector_b_valid_in) begin\n                        acc <= acc + (vector_a_in * vector_b_in);\n                        cnt <= cnt + 1;\n                    end\n                    if (cnt == dot_length_in - 1) begin\n                        state <= OUTPUT;\n                    end else begin\n                        state <= COMPUTE;\n                    end\n                end\n                OUTPUT: begin\n                    dot_product_out <= acc;\n                    dot_product_valid_out <= 1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    always @(posedge clk_in) begin\n        if (state == OUTPUT) begin\n            dot_product_valid_out <= 1; // Valid signal is HIGH in OUTPUT state\n        end else begin\n            dot_product_valid_out <= 0; // Valid signal is LOW in all other states\n        end\n    end\n\nendmodule"}, "output": {"rtl/dot_product.sv": ""}, "obj": true}}
{"cvdp_copilot_edge_detector_0001": {"input": {}, "output": {"rtl/sync_pos_neg_edge_detector.sv": ""}, "obj": true}}
{"cvdp_copilot_elastic_buffer_0001": {"input": {}, "output": {"rtl/elastic_buffer_pattern_matcher.sv": ""}, "obj": true}}
{"cvdp_copilot_elastic_buffer_0005": {"input": {"rtl/elastic_buffer_pattern_matcher.sv": "module elastic_buffer_pattern_matcher #(\n    parameter int WIDTH        = 16,                              // Represents the Width of the input data,pattern and mask signals.\n    parameter int NUM_PATTERNS = 4\n)(\n    input  logic                              clk,                // Clock input\n    input  logic                              rst,                // Active high synchronous reset\n    input logic                               i_valid,            // Input data valid signal\n    input  logic [WIDTH:0]                  i_data,             // Input data to be matched\n    // Flattened array of patterns: each pattern is WIDTH bits wide.\n    input  logic [NUM_PATTERNS*WIDTH:0]     i_pattern,          \n    // Flattened array of masks: each mask is WIDTH bits wide (1 = compare; 0 = don't care).\n    input  logic [NUM_PATTERNS*WIDTH:0]     i_mask,             \n    input  logic [$clog2(WIDTH+1)-1:0]        i_error_tolerance,  // Runtime configurable error tolerance\n     output logic                              o_valid,            // Output valid signal\n    output logic [NUM_PATTERNS-1:0]           o_match             // Match output for each pattern\n);\n   logic [1:0] o_valid_reg;\n   // ---------------------------------------------------------------------------\n   // Pipeline Stage 1: Compute Masked Differences\n   //\n   // For each pattern, compute the bitwise difference between i_data and\n   // the corresponding pattern slice, then mask off \"don't care\" bits.\n   //---------------------------------------------------------------------------\n   logic [WIDTH-1:0] diff_pipe1 [NUM_PATTERNS-1:0];\n   logic [WIDTH-1:0] diff_pipe2 [NUM_PATTERNS-1:0];\n\n   always_ff @(posedge clk) begin\n      if (rst) begin\n         for (int j = 0; j < NUM_PATTERNS; j++) begin\n            diff_pipe1[j] <= '0;\n         end\n      end else begin\n         for (int j = 0; j < NUM_PATTERNS; j++) begin\n            // Extract the j-th pattern and mask slice from the flattened inputs.\n            diff_pipe1[j] <= (i_data ^ i_pattern[j*WIDTH +: WIDTH]) & i_mask[j*WIDTH +: WIDTH];\n         end\n      end\n   end\n\n   //---------------------------------------------------------------------------\n   // Pipeline Stage 2: Count Mismatches Using a Popcount Function\n   //\n   // Count the number of 1's (mismatches) in each diff vector.\n   //---------------------------------------------------------------------------\n   logic [$clog2(WIDTH+1)-1:0] error_count_pipe2 [NUM_PATTERNS-1:0];\n   logic [$clog2(WIDTH+1)-1:0] error_count_pipe3 [NUM_PATTERNS-1:0];\n\n   // Popcount function: counts the number of '1's in a vector.\n   function automatic [$clog2(WIDTH+1)-1:0] popcount(input logic [WIDTH-1:0] vector);\n      int k;\n      popcount = 0;\n      for (k = 0; k < WIDTH; k++) begin\n         popcount += {{$clog2(WIDTH+1)-1{1'b0}}, vector[k]};\n      end\n   endfunction\n\n   always_ff @(posedge clk) begin\n      if (rst) begin\n         for (int j = 0; j < NUM_PATTERNS; j++) begin\n            error_count_pipe2[j] = '0;\n\t\t\ti_mask[j] <= '0;\n   o_match[j] <= '0;\n         end\n      end else begin\n         for (int j = 0; j < NUM_PATTERNS; j++) begin\n            error_count_pipe2[j] <= popcount(diff_pipe1[j]);\n         end\n      end\n   end\n\n   //---------------------------------------------------------------------------\n   // Pipeline Stage 3: Compare Error Count with Runtime Tolerance\n   //\n   // Assert the match signal for each pattern if the number of mismatches is\n   // less than or equal to the error tolerance.\n   //---------------------------------------------------------------------------\n   always_comb begin\n      for (int j = 0; j < NUM_PATTERNS; j++) begin\n\t\to_match[j] = (error_count_pipe2[j] <= i_error_tolerance);\n      end\n   end\n\n\n   //---------------------------------------------------------------------------\n   // Valid pipeline\n   //---------------------------------------------------------------------------\n   always_ff @(posedge clk) begin\n      if (rst)\n         {o_valid, o_valid_reg} <= '0;\n      else\n         {o_valid, o_valid_reg} <= {o_valid_reg, i_valid}; \n   end\n\t\nendmodule"}, "output": {"rtl/elastic_buffer_pattern_matcher.sv": ""}, "obj": true}}
{"cvdp_copilot_elevator_control_0006": {"input": {"rtl/elevator_control_system.sv": "/*\n * Elevator Control System\n * \n * This module implements an FSM-based elevator control system capable of managing multiple floors,\n * handling call requests, and responding to emergency stops. The elevator transitions between \n * five main states: Idle, Moving Up, Moving Down, Emergency Halt, Door Open. It prioritizes floor requests \n * based on direction, moving to the highest or lowest requested floor depending on the current direction.\n*/\nmodule elevator_control_system #(\n    parameter N = 8, //Number of floors\n    parameter DOOR_OPEN_TIME_MS = 500 // Door open time in milliseconds\n) ( \n    input wire clk,                   // 100MHz clock input\n    input wire reset,                 // Active-high reset signal\n    input wire [N-1:0] call_requests, // External Floor call requests\n    input wire emergency_stop,        // Emergency stop signal\n    output wire [$clog2(N)-1:0] current_floor, // Current floor of the elevator\n    output reg direction,             // Elevator direction: 1 = up, 0 = down\n    output reg door_open,             // Door open signal\n    output reg [2:0] system_status    // Elevator system state indicator\n);\n\n// State Encoding\nlocalparam IDLE = 3'b000;          // Elevator is idle\nlocalparam MOVING_UP = 3'b001;     // Elevator moving up\nlocalparam MOVING_DOWN = 3'b010;   // Elevator moving down\nlocalparam EMERGENCY_HALT = 3'b011;// Emergency halt state\nlocalparam DOOR_OPEN = 3'b100;     // Door open state\n\n// Internal registers\nreg [N-1:0] call_requests_internal;   // Internal copy of call requests\nreg [2:0] present_state, next_state; // FSM current and next states\nreg [$clog2(N)-1:0] max_request;     // Highest requested floor\nreg [$clog2(N)-1:0] min_request;    // Lowest requested floor\n\n\n// Door open time configuration\n`ifdef SIMULATION\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam SIM_DOOR_OPEN_TIME_MS = 0.05; // Shorter door open time for simulation\n    localparam DOOR_OPEN_CYCLES = (SIM_DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000); // Door open cycles for simulation   \n`else\n    // Calculating door open cycles based on time and clock frequency\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam DOOR_OPEN_CYCLES = (DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000);   // Door open cycles for real implementation\n`endif\n\n\nreg [$clog2(DOOR_OPEN_CYCLES)-1:0] door_open_counter;   // Counter for door open duration\n\n\nreg [$clog2(N)-1:0] current_floor_reg, current_floor_next=0;\n\nassign current_floor = current_floor_reg;\n\n// FSM state transition\nalways@(posedge clk or posedge reset) begin\n    if(reset)begin\n        present_state <= IDLE;\n        system_status <= IDLE;\n        current_floor_reg <= 0;\n        max_request <= 0;\n        min_request <= N-1;        \n    end else begin\n        present_state <= next_state;\n        system_status <= next_state;\n        current_floor_reg <= current_floor_next;\n        \n        // Calculate max_request and min_request based on active requests\n        max_request = 0;\n        min_request = N-1;\n        for (integer i = 0; i < N; i = i + 1) begin\n            if (call_requests_internal[i]) begin\n                if (i > max_request) max_request = i;\n                if (i < min_request) min_request = i;\n            end\n        end\n    end\nend\n\nalways@(*)begin\n    next_state = present_state;\n    current_floor_next = current_floor_reg;\n    \n    case(present_state)\n        IDLE:begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal != 0)begin\n                if(max_request > current_floor_reg)begin\n                    next_state = MOVING_UP;\n                end else if(min_request < current_floor_reg) begin\n                    next_state = MOVING_DOWN;\n                end\n            end\n        end\n\n        MOVING_UP: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg+1]) begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg >= max_request) begin\n                // If we reach the highest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = MOVING_UP;\n            end\n        end\n\n        MOVING_DOWN: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg-1]) begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg <= min_request) begin\n                // If we reach the lowest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = MOVING_DOWN;\n            end\n        end\n\n        EMERGENCY_HALT: begin\n            if (!emergency_stop) begin\n                next_state = IDLE;\n                current_floor_next = 0; // Optionally reset to ground floor\n            end\n        end\n\n        DOOR_OPEN: begin\n            if (door_open_counter == 0) begin\n                next_state = IDLE;\n            end else begin\n                next_state = DOOR_OPEN;\n            end\n        end\n    endcase\nend\n\n\n// Door open control logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        door_open_counter <= 0;\n        door_open <= 0;\n    end else begin\n        if (present_state == DOOR_OPEN) begin\n            if (door_open_counter > 0) begin\n                door_open <= 1;\n                door_open_counter <= door_open_counter - 1;\n            end else begin\n                door_open <= 0;\n                next_state = IDLE;\n            end\n        end else begin\n            door_open <= 0;\n            door_open_counter <= DOOR_OPEN_CYCLES; // Reset door open counter\n        end\n    end\nend\n\n// Call request management\nalways@(*)begin\n    if(reset) begin\n        call_requests_internal = 0;\n    end else begin\n        if(call_requests_internal[current_floor_reg])begin\n            call_requests_internal[current_floor_reg] = 0;      // Clear served request\n        end\n        call_requests_internal = call_requests_internal | call_requests;    // Update requests\n    end\nend\n\n// Direction control logic\nalways@(*)begin\n    if(reset) begin\n        direction = 1;  // Default direction is up\n    end else begin\n        if(present_state == MOVING_UP)begin\n            direction = 1;\n        end else if (present_state == MOVING_DOWN) begin\n            direction = 0;\n        end else begin\n            direction = 1;\n        end\n    end\nend\n\nendmodule"}, "output": {"rtl/elevator_control_system.sv": "", "rtl/floor_to_seven_segment.sv": ""}, "obj": true}}
{"cvdp_copilot_elevator_control_0009": {"input": {"rtl/elevator_control_system.sv": "/*\n * Elevator Control System\n * \n * This module implements an FSM-based elevator control system capable of managing multiple floors,\n * handling call requests, and responding to emergency stops. The elevator transitions between \n * five main states: Idle, Moving Up, Moving Down, Emergency Halt, Door Open. It prioritizes floor requests \n * based on direction, moving to the highest or lowest requested floor depending on the current direction.\n*/\nmodule elevator_control_system #(\n    parameter N = 8, //Number of floors\n    parameter DOOR_OPEN_TIME_MS = 500 // Door open time in milliseconds\n) ( \n    input wire clk,                   // 100MHz clock input\n    input wire reset,                 // Active-high reset signal\n    input wire [N-1:0] call_requests, // External Floor call requests\n    input wire emergency_stop,        // Emergency stop signal\n    output wire [$clog2(N)-1:0] current_floor, // Current floor of the elevator\n    output reg direction,             // Elevator direction: 1 = up, 0 = down\n    output reg door_open,             // Door open signal\n    output reg [2:0] system_status,    // Elevator system state indicator\n    output wire [6:0] seven_seg_out    // Seven-segment display output for current floor visualization\n);\n\n// State Encoding\nlocalparam IDLE = 3'b000;          // Elevator is idle\nlocalparam MOVING_UP = 3'b001;     // Elevator moving up\nlocalparam MOVING_DOWN = 3'b010;   // Elevator moving down\nlocalparam EMERGENCY_HALT = 3'b011;// Emergency halt state\nlocalparam DOOR_OPEN = 3'b100;     // Door open state\n\n// Internal registers\nreg [N-1:0] call_requests_internal;   // Internal copy of call requests\nreg [2:0] present_state, next_state; // FSM current and next states\nreg [$clog2(N)-1:0] max_request;     // Highest requested floor\nreg [$clog2(N)-1:0] min_request;    // Lowest requested floor\n\n// Door open time configuration\n`ifdef SIMULATION\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam SIM_DOOR_OPEN_TIME_MS = 0.05; // Shorter door open time for simulation\n    localparam DOOR_OPEN_CYCLES = (SIM_DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000); // Door open cycles for simulation   \n`else\n    // Calculating door open cycles based on time and clock frequency\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam DOOR_OPEN_CYCLES = (DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000);   // Door open cycles for real implementation\n`endif\n\n\nreg [$clog2(DOOR_OPEN_CYCLES)-1:0] door_open_counter;   // Counter for door open duration\n\nreg [$clog2(N)-1:0] current_floor_reg, current_floor_next=0;\n\nassign current_floor = current_floor_reg;\n\n// FSM state transition\nalways@(posedge clk or posedge reset) begin\n    if(reset)begin\n        present_state <= IDLE;\n        system_status <= IDLE;\n        current_floor_reg <= 0;\n        max_request <= 0;\n        min_request <= N-1;        \n    end else begin\n        present_state <= next_state;\n        system_status <= next_state;\n        current_floor_reg <= current_floor_next;\n        \n        // Calculate max_request and min_request based on active requests\n        max_request = 0;\n        min_request = N-1;\n        for (integer i = 0; i < N; i = i + 1) begin\n            if (call_requests_internal[i]) begin\n                if (i > max_request) max_request = i;\n                if (i < min_request) min_request = i;\n            end\n        end\n    end\nend\n\nalways@(*)begin\n    next_state = present_state;\n    current_floor_next = current_floor_reg;\n    \n    case(present_state)\n        IDLE:begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal != 0)begin\n                if(max_request > current_floor_reg)begin\n                    next_state = MOVING_UP;\n                end else if(min_request < current_floor_reg) begin\n                    next_state = MOVING_DOWN;\n                end\n            end\n        end\n\n        MOVING_UP: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg+1]) begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg >= max_request) begin\n                // If we reach the highest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = MOVING_UP;\n            end\n        end\n\n        MOVING_DOWN: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg-1]) begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg <= min_request) begin\n                // If we reach the lowest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = MOVING_DOWN;\n            end\n        end\n\n        EMERGENCY_HALT: begin\n            if (!emergency_stop) begin\n                next_state = IDLE;\n                current_floor_next = 0; // Optionally reset to ground floor\n            end\n        end\n\n        DOOR_OPEN: begin\n            if (door_open_counter == 0) begin\n                next_state = IDLE;\n            end else begin\n                next_state = DOOR_OPEN;\n            end\n        end\n    endcase\nend\n\n\n// Door open control logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        door_open_counter <= 0;\n        door_open <= 0;\n    end else begin\n        if (present_state == DOOR_OPEN) begin\n            if (door_open_counter > 0) begin\n                door_open <= 1;\n                door_open_counter <= door_open_counter - 1;\n            end else begin\n                door_open <= 0;\n                next_state = IDLE;\n            end\n        end else begin\n            door_open <= 0;\n            door_open_counter <= DOOR_OPEN_CYCLES; // Reset door open counter\n        end\n    end\nend\n\n// Call request management\nalways@(*)begin\n    if(reset) begin\n        call_requests_internal = 0;\n    end else begin\n        if(call_requests_internal[current_floor_reg])begin\n            call_requests_internal[current_floor_reg] = 0;      // Clear served request\n        end\n        call_requests_internal = call_requests_internal | call_requests;    // Update requests\n    end\nend\n\n// Direction control logic\nalways@(*)begin\n    if(reset) begin\n        direction = 1;\n    end else begin\n        if(present_state == MOVING_UP)begin\n            direction = 1;\n        end else if (present_state == MOVING_DOWN) begin\n            direction = 0;\n        end else begin\n            direction = 1;\n        end\n    end\nend\n\n\n// Seven-segment display converter instantiation\nfloor_to_seven_segment #(.N(8)) floor_display_converter (\n    .floor_display(current_floor_reg),\n    .seven_seg_out(seven_seg_out)\n);\n\nendmodule", "rtl/floor_to_seven_segment.sv": "/*\n * Floor to Seven-Segment Display Converter\n * \n * Converts the current floor number (binary) to a seven-segment display output.\n * Supports floors 0 to N-1, with invalid inputs resulting in a blank display.\n */\nmodule floor_to_seven_segment #(\n    parameter N = 8 // Number of floors, assumes floors are numbered 0 to N-1\n)(\n    input wire [$clog2(N)-1:0] floor_display, // Binary floor number input\n    output reg [6:0] seven_seg_out // Seven-segment display output: {a, b, c, d, e, f, g}\n);\n\n    always @(*) begin\n        case (floor_display)\n            4'd0: seven_seg_out = 7'b1111110; // 0\n            4'd1: seven_seg_out = 7'b0110000; // 1\n            4'd2: seven_seg_out = 7'b1101101; // 2\n            4'd3: seven_seg_out = 7'b1111001; // 3\n            4'd4: seven_seg_out = 7'b0110011; // 4\n            4'd5: seven_seg_out = 7'b1011011; // 5\n            4'd6: seven_seg_out = 7'b1011111; // 6\n            4'd7: seven_seg_out = 7'b1110000; // 7\n            4'd8: seven_seg_out = 7'b1111111; // 8\n            4'd9: seven_seg_out = 7'b1111011; // 9\n            default: seven_seg_out = 7'b0000000; // Blank display for invalid floor numbers\n        endcase\n    end\n\nendmodule"}, "output": {"rtl/elevator_control_system.sv": ""}, "obj": true}}
{"cvdp_copilot_elevator_control_0026": {"input": {"rtl/elevator_control_system.sv": "/*\n * Elevator Control System\n * \n * This module implements an FSM-based elevator control system capable of managing multiple floors,\n * handling call requests, and responding to emergency stops. The elevator transitions between \n * five main states: Idle, Moving Up, Moving Down, Emergency Halt, Door Open. It prioritizes floor requests \n * based on direction, moving to the highest or lowest requested floor depending on the current direction.\n*/\nmodule elevator_control_system #(\n    parameter N = 8, //Number of floors\n    parameter DOOR_OPEN_TIME_MS = 500 // Door open time in milliseconds\n) ( \n    input wire clk,                   // 100MHz clock input\n    input wire reset,                 // Active-high reset signal\n    input wire [N-1:0] call_requests, // External Floor call requests\n    input wire emergency_stop,        // Emergency stop signal\n    input wire overload_detected,\n    output wire [$clog2(N)-1:0] current_floor, // Current floor of the elevator\n    output reg direction,             // Elevator direction: 1 = up, 0 = down\n    output reg door_open,             // Door open signal\n    output reg [2:0] system_status,    // Elevator system state indicator\n    output overload_warning,          // Overload warning signal\n    output wire [6:0] seven_seg_out    // Seven-segment display output for current floor visualization\n);\n\n// State Encoding\nlocalparam IDLE = 3'b000;          // Elevator is idle\nlocalparam MOVING_UP = 3'b001;     // Elevator moving up\nlocalparam MOVING_DOWN = 3'b010;   // Elevator moving down\nlocalparam EMERGENCY_HALT = 3'b011;// Emergency halt state\nlocalparam DOOR_OPEN = 3'b100;     // Door open state\nlocalparam OVERLOAD_HALT = 3'b101; // New state for overload condition\n\n// Internal registers\nreg [N-1:0] call_requests_internal;   // Internal copy of call requests\nreg [2:0] present_state, next_state; // FSM current and next states\nreg [$clog2(N)-1:0] max_request;     // Highest requested floor\nreg [$clog2(N)-1:0] min_request;    // Lowest requested floor\n\n// Door open time configuration\n`ifdef SIMULATION\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam SIM_DOOR_OPEN_TIME_MS = 0.05; // Shorter door open time for simulation\n    localparam DOOR_OPEN_CYCLES = (SIM_DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000); // Door open cycles for simulation   \n`else\n    // Calculating door open cycles based on time and clock frequency\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam DOOR_OPEN_CYCLES = (DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000);   // Door open cycles for real implementation\n`endif\n\n\nreg [$clog2(DOOR_OPEN_CYCLES)-1:0] door_open_counter;   // Counter for door open duration\n\nreg [$clog2(N)-1:0] current_floor_reg, current_floor_next=0;\n\nassign current_floor = current_floor_reg;\n\n// Update overload warning signal\nassign overload_warning = (overload_detected == 1 && present_state == OVERLOAD_HALT);\n\n// FSM state transition\nalways@(posedge clk or posedge reset) begin\n    if(reset)begin\n        present_state <= IDLE;\n        system_status <= IDLE;\n        current_floor_reg <= 0;\n        max_request <= 0;\n        min_request <= N-1;        \n    end else begin\n        present_state <= next_state;\n        system_status <= next_state;\n        current_floor_reg <= current_floor_next;\n        \n        // Calculate max_request and min_request based on active requests\n        max_request = 0;\n        min_request = N-1;\n        for (integer i = 0; i < N; i = i + 1) begin\n            if (call_requests_internal[i]) begin\n                if (i > max_request) max_request = i;\n                if (i < min_request) min_request = i;\n            end\n        end\n    end\nend\n\nalways@(*)begin\n    next_state = present_state;\n    current_floor_next = current_floor_reg;\n    \n    case(present_state)\n        IDLE:begin\n            if(overload_detected) begin\n                next_state = OVERLOAD_HALT;\n            end else if(emergency_stop) begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal != 0)begin\n                if(max_request > current_floor_reg)begin\n                    next_state = MOVING_UP;\n                end else if(min_request < current_floor_reg) begin\n                    next_state = MOVING_DOWN;\n                end\n            end\n        end\n\n        MOVING_UP: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg+1]) begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg >= max_request) begin\n                // If we reach the highest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = MOVING_UP;\n            end\n        end\n\n        MOVING_DOWN: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg-1]) begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg <= min_request) begin\n                // If we reach the lowest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = MOVING_DOWN;\n            end\n        end\n\n        EMERGENCY_HALT: begin\n            if (!emergency_stop) begin\n                next_state = IDLE;\n                current_floor_next = 0; // Optionally reset to ground floor\n            end\n        end\n\n        DOOR_OPEN: begin\n            if(overload_detected) begin\n                next_state = OVERLOAD_HALT;\n            end else if (door_open_counter == 0) begin\n                next_state = IDLE;\n            end else begin\n                next_state = DOOR_OPEN;\n            end\n        end\n\n        OVERLOAD_HALT: begin\n            if(!overload_detected) begin\n                if(door_open) begin\n                    next_state = DOOR_OPEN;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n        end\n    endcase\nend\n\n\n// Door open control logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        door_open_counter <= 0;\n        door_open <= 0;\n    end else begin\n        if (present_state == OVERLOAD_HALT) begin\n            door_open_counter <= DOOR_OPEN_CYCLES;\n            door_open <= 1;\n        end else if (present_state == DOOR_OPEN) begin\n            if (door_open_counter > 0) begin\n                door_open <= 1;\n                door_open_counter <= door_open_counter - 1;\n            end else begin\n                door_open <= 0;\n                next_state = IDLE;\n            end\n        end else begin\n            door_open <= 0;\n            door_open_counter <= DOOR_OPEN_CYCLES; // Reset door open counter\n        end\n    end\nend\n\n// Call request management\nalways@(*)begin\n    if(reset) begin\n        call_requests_internal = 0;\n    end else begin\n        if(call_requests_internal[current_floor_reg])begin\n            call_requests_internal[current_floor_reg] = 0;      // Clear served request\n        end\n        call_requests_internal = call_requests_internal | call_requests;    // Update requests\n    end\nend\n\n// Direction control logic\nalways@(*)begin\n    if(reset) begin\n        direction = 1;\n    end else begin\n        if(present_state == MOVING_UP)begin\n            direction = 1;\n        end else if (present_state == MOVING_DOWN) begin\n            direction = 0;\n        end else begin\n            direction = 1;\n        end\n    end\nend\n\n\n// Seven-segment display converter instantiation\nfloor_to_seven_segment #(.N(8)) floor_display_converter (\n    .floor_display(current_floor_reg),\n    .seven_seg_out(seven_seg_out)\n);\n\nendmodule", "rtl/floor_to_seven_segment.sv": "/*\n * Floor to Seven-Segment Display Converter\n * \n * Converts the current floor number (binary) to a seven-segment display output.\n * Supports floors 0 to N-1, with invalid inputs resulting in a blank display.\n */\nmodule floor_to_seven_segment #(\n    parameter N = 8 // Number of floors, assumes floors are numbered 0 to N-1\n)(\n    input wire [$clog2(N)-1:0] floor_display, // Binary floor number input\n    output reg [6:0] seven_seg_out // Seven-segment display output: {a, b, c, d, e, f, g}\n);\n\n    always @(*) begin\n        case (floor_display)\n            4'd0: seven_seg_out = 7'b1111110; // 0\n            4'd1: seven_seg_out = 7'b0110000; // 1\n            4'd2: seven_seg_out = 7'b1101101; // 2\n            4'd3: seven_seg_out = 7'b1111001; // 3\n            4'd4: seven_seg_out = 7'b0110011; // 4\n            4'd5: seven_seg_out = 7'b1011011; // 5\n            4'd6: seven_seg_out = 7'b1011111; // 6\n            4'd7: seven_seg_out = 7'b1110000; // 7\n            4'd8: seven_seg_out = 7'b1111111; // 8\n            4'd9: seven_seg_out = 7'b1111011; // 9\n            default: seven_seg_out = 7'b0000000; // Blank display for invalid floor numbers\n        endcase\n    end\n\nendmodule"}, "output": {"rtl/elevator_control_system.sv": "", "rtl/floor_to_seven_segment.sv": "", "rtl/Binary2BCD.sv": ""}, "obj": true}}
{"cvdp_copilot_elevator_control_0033": {"input": {"rtl/Binary2BCD.sv": "module Binary2BCD(input [7:0] num,output reg [3:0]thousand, output reg [3:0]hundred, output reg [3:0]ten, output reg [3:0]one );\n    reg[19:0] shift;\n    integer i;\n    \n    always @(num)\n    begin\n        shift[19:8] =0;\n        shift[7:0]=num;\n        \n        for(i=0;i<8;i=i+1)\n        begin\n            if(shift[11:8]>=5)\n                shift[11:8]=shift[11:8] +3;\n           \n            if(shift[15:12]>=5)\n                    shift[15:12]=shift[15:12] +3; \n\n            if(shift[19:16]>=5)\n                shift[19:16]=shift[19:16] +3;\n            \n            shift=shift <<1;                                       \n        end\n        \n        hundred=shift[19:16];\n        ten=shift[15:12];\n        one=shift[11:8];\n        thousand=4'b0000;\n        \n    end\n    \nendmodule", "rtl/elevator_control_system.sv": "/*\n * Elevator Control System\n * \n * This module implements an FSM-based elevator control system capable of managing multiple floors,\n * handling call requests, and responding to emergency stops. The elevator transitions between \n * five main states: Idle, Moving Up, Moving Down, Emergency Halt, Door Open. It prioritizes floor requests \n * based on direction, moving to the highest or lowest requested floor depending on the current direction.\n*/\nmodule elevator_control_system #(\n    parameter N = 8, //Number of floors\n    parameter DOOR_OPEN_TIME_MS = 500 // Door open time in milliseconds\n) ( \n    input wire clk,                   // 100MHz clock input\n    input wire reset,                 // Active-high reset signal\n    input wire [N-1:0] call_requests, // External Floor call requests\n    input wire emergency_stop,        // Emergency stop signal\n    input wire overload_detected,\n    output wire [$clog2(N)-1:0] current_floor, // Current floor of the elevator\n    output reg direction,             // Elevator direction: 1 = up, 0 = down\n    output reg door_open,             // Door open signal\n    output reg [2:0] system_status,    // Elevator system state indicator\n    output overload_warning,          // Overload warning signal\n    output [3:0]thousand,output[3:0] hundred, output [3:0]ten, output [3:0]one,\n    output wire [6:0] seven_seg_out,    // Seven-segment display output for current floor visualization\n    output wire [3:0] seven_seg_out_anode //Signal for switching between ones, tens, hundred, thousand place on seven segment\n\n);\n\n// State Encoding\nlocalparam IDLE = 3'b000;          // Elevator is idle\nlocalparam MOVING_UP = 3'b001;     // Elevator moving up\nlocalparam MOVING_DOWN = 3'b010;   // Elevator moving down\nlocalparam EMERGENCY_HALT = 3'b011;// Emergency halt state\nlocalparam DOOR_OPEN = 3'b100;     // Door open state\nlocalparam OVERLOAD_HALT = 3'b101; // New state for overload condition\n\n// Internal registers\nreg [N-1:0] call_requests_internal;   // Internal copy of call requests\nreg [2:0] present_state, next_state; // FSM current and next states\nreg [$clog2(N)-1:0] max_request;     // Highest requested floor\nreg [$clog2(N)-1:0] min_request;    // Lowest requested floor\n\n// Door open time configuration\n`ifdef SIMULATION\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam SIM_DOOR_OPEN_TIME_MS = 0.05; // Shorter door open time for simulation\n    localparam DOOR_OPEN_CYCLES = (SIM_DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000); // Door open cycles for simulation   \n`else\n    // Calculating door open cycles based on time and clock frequency\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam DOOR_OPEN_CYCLES = (DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000);   // Door open cycles for real implementation\n`endif\n\n\nreg [$clog2(DOOR_OPEN_CYCLES)-1:0] door_open_counter;   // Counter for door open duration\n\nreg [$clog2(N)-1:0] current_floor_reg, current_floor_next=0;\n\nassign current_floor = current_floor_reg;\n\n// Update overload warning signal\nassign overload_warning = (overload_detected == 1 && present_state == OVERLOAD_HALT);\n\n// FSM state transition\nalways@(posedge clk or posedge reset) begin\n    if(reset)begin\n        present_state <= IDLE;\n        system_status <= IDLE;\n        current_floor_reg <= 0;        \n    end else begin\n        present_state <= next_state;\n        system_status <= next_state;\n        current_floor_reg <= current_floor_next;\n    end\nend\n\nalways@(posedge clk or posedge reset) begin\n    if(reset)begin\n        max_request <= 0;\n        min_request <= N-1;        \n    end else begin        \n        // Calculate max_request and min_request based on active requests\n        max_request = 0;\n        min_request = N-1;\n        for (integer i = 0; i < N; i = i + 1) begin\n            if (call_requests_internal[i]) begin\n                if (i > max_request) \n                    max_request = i; \n                if (i < min_request)  \n                    min_request = i; \n            end\n        end\n    end\nend\n\nalways@(*)begin\n    next_state = present_state;\n    current_floor_next = current_floor_reg;\n    \n    case(present_state)\n        IDLE:begin\n            if(overload_detected) begin\n                next_state = OVERLOAD_HALT;\n            end else if(emergency_stop) begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal != 0)begin\n                if(max_request > current_floor_reg)begin\n                    next_state = MOVING_UP;\n                end else if(min_request < current_floor_reg) begin\n                    next_state = MOVING_DOWN;\n                end\n            end\n        end\n\n        MOVING_UP: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg+1]) begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg >= max_request) begin\n                // If we reach the highest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = MOVING_UP;\n            end\n        end\n\n        MOVING_DOWN: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg-1]) begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg <= min_request) begin\n                // If we reach the lowest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = MOVING_DOWN;\n            end\n        end\n\n        EMERGENCY_HALT: begin\n            if (!emergency_stop) begin\n                next_state = IDLE;\n                current_floor_next = 0; // Optionally reset to ground floor\n            end\n        end\n\n        DOOR_OPEN: begin\n            if(overload_detected) begin\n                next_state = OVERLOAD_HALT;\n            end else if (door_open_counter == 0) begin\n                next_state = IDLE;\n            end else begin\n                next_state = DOOR_OPEN;\n            end\n        end\n\n        OVERLOAD_HALT: begin\n            if(!overload_detected) begin\n                if(door_open) begin\n                    next_state = DOOR_OPEN;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n        end\n    endcase\nend\n\n\n// Door open control logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        door_open_counter <= 0;\n        door_open <= 0;\n    end else begin\n        if (present_state == OVERLOAD_HALT) begin\n            door_open_counter <= DOOR_OPEN_CYCLES;\n            door_open <= 1;\n        end else if (present_state == DOOR_OPEN) begin\n            if (door_open_counter > 0) begin\n                door_open <= 1;\n                door_open_counter <= door_open_counter - 1;\n            end else begin\n                door_open <= 0;\n                next_state = IDLE;\n            end\n        end else begin\n            door_open <= 0;\n            door_open_counter <= DOOR_OPEN_CYCLES; // Reset door open counter\n        end\n    end\nend\n\n// Call request management\nalways@(*)begin\n    if(reset) begin\n        call_requests_internal = 0;\n    end else begin\n        if(call_requests_internal[current_floor_reg])begin\n            call_requests_internal[current_floor_reg] = 0;      // Clear served request\n        end\n        call_requests_internal = call_requests_internal | call_requests;    // Update requests\n    end\nend\n\n// Direction control logic\nalways@(*)begin\n    if(reset) begin\n        direction = 1;\n    end else begin\n        if(present_state == MOVING_UP)begin\n            direction = 1;\n        end else if (present_state == MOVING_DOWN) begin\n            direction = 0;\n        end else begin\n            direction = 1;\n        end\n    end\nend\n\n\n// Seven-segment display converter instantiation\nfloor_to_seven_segment floor_display_converter (\n    .clk(clk),\n    .floor_display(current_floor_reg),\n    .seven_seg_out(seven_seg_out),\n    .seven_seg_out_anode(seven_seg_out_anode),\n    .thousand(thousand), .hundred(hundred),.ten(ten),.one(one)\n);\n\nendmodule", "rtl/floor_to_seven_segment.sv": "/*\n * Floor to Seven-Segment Display Converter\n * \n * Converts the current floor number (binary) to a seven-segment display output.\n * Supports floors 0 to N-1, with invalid inputs resulting in a blank display.\n */\nmodule floor_to_seven_segment (\n    input wire clk, \n    input wire [7:0] floor_display, // Binary floor number input\n    output reg [6:0] seven_seg_out, // Seven-segment display output: {a, b, c, d, e, f, g}\n    output [3:0]seven_seg_out_anode, ////Signal for switching between ones, tens, hundred, thousand place on seven segment\n    output [3:0] thousand, output[3:0] hundred, output [3:0]ten, output [3:0] one\n);\n\n    //Internal signals\n     reg [6:0]sseg_temp=7'b1111111;\n     reg [3:0]an_temp = 4'b1110 ;\n     reg [17:0] count=0; //the 18 bit counter which allows us to multiplex at 1000Hz\n\n     always @ (posedge clk)\n      begin\n        count <= count + 1;\n      end\n\n    //code for display multiple digits\nalways @(*) begin\n    case (count[17:16]) // Using only the 2 MSBs of the counter\n        2'b00: // When the 2 MSBs are 00, enable the fourth display\n        begin\n            case (one)\n                4'd0: sseg_temp = 7'b1111110; // Display 0\n                4'd1: sseg_temp = 7'b0110000; // Display 1\n                4'd2: sseg_temp = 7'b1101101; // Display 2\n                4'd3: sseg_temp = 7'b1111001; // Display 3\n                4'd4: sseg_temp = 7'b0110011; // Display 4\n                4'd5: sseg_temp = 7'b1011011; // Display 5\n                4'd6: sseg_temp = 7'b1011111; // Display 6\n                4'd7: sseg_temp = 7'b1110000; // Display 7\n                4'd8: sseg_temp = 7'b1111111; // Display 8\n                4'd9: sseg_temp = 7'b1111011; // Display 9\n                default: sseg_temp = 7'b0000000; // Blank display\n            endcase\n            an_temp = 4'b1110; // Enable the fourth display\n        end\n        \n        2'b01: // When the 2 MSBs are 01, enable the third display\n        begin\n            case (ten)\n                4'd0: sseg_temp = 7'b1111110; // Display 0\n                4'd1: sseg_temp = 7'b0110000; // Display 1\n                4'd2: sseg_temp = 7'b1101101; // Display 2\n                4'd3: sseg_temp = 7'b1111001; // Display 3\n                4'd4: sseg_temp = 7'b0110011; // Display 4\n                4'd5: sseg_temp = 7'b1011011; // Display 5\n                4'd6: sseg_temp = 7'b1011111; // Display 6\n                4'd7: sseg_temp = 7'b1110000; // Display 7\n                4'd8: sseg_temp = 7'b1111111; // Display 8\n                4'd9: sseg_temp = 7'b1111011; // Display 9\n                default: sseg_temp = 7'b0000000; // Blank display\n            endcase\n            an_temp = 4'b1101; // Enable the third display\n        end\n\n        2'b10: // When the 2 MSBs are 10, enable the second display\n        begin\n            case (hundred)\n                4'd0: sseg_temp = 7'b1111110; // Display 0\n                4'd1: sseg_temp = 7'b0110000; // Display 1\n                4'd2: sseg_temp = 7'b1101101; // Display 2\n                4'd3: sseg_temp = 7'b1111001; // Display 3\n                4'd4: sseg_temp = 7'b0110011; // Display 4\n                4'd5: sseg_temp = 7'b1011011; // Display 5\n                4'd6: sseg_temp = 7'b1011111; // Display 6\n                4'd7: sseg_temp = 7'b1110000; // Display 7\n                4'd8: sseg_temp = 7'b1111111; // Display 8\n                4'd9: sseg_temp = 7'b1111011; // Display 9\n                default: sseg_temp = 7'b0000000; // Blank display\n            endcase\n            an_temp = 4'b1011; // Enable the second display\n        end\n\n        2'b11: // When the 2 MSBs are 11, enable the first display\n        begin\n            case (thousand)\n                4'd0: sseg_temp = 7'b1111110; // Display 0\n                4'd1: sseg_temp = 7'b0110000; // Display 1\n                4'd2: sseg_temp = 7'b1101101; // Display 2\n                4'd3: sseg_temp = 7'b1111001; // Display 3\n                4'd4: sseg_temp = 7'b0110011; // Display 4\n                4'd5: sseg_temp = 7'b1011011; // Display 5\n                4'd6: sseg_temp = 7'b1011111; // Display 6\n                4'd7: sseg_temp = 7'b1110000; // Display 7\n                4'd8: sseg_temp = 7'b1111111; // Display 8\n                4'd9: sseg_temp = 7'b1111011; // Display 9\n                default: sseg_temp = 7'b0000000; // Blank display\n            endcase\n            an_temp = 4'b0111; // Enable the first display\n        end\n    endcase\nend\n\nassign seven_seg_out = sseg_temp;\nassign seven_seg_out_anode = an_temp;\n\n    //Binary to BCD covertor to receive seprate bits for ones, tens, hundred, thousand places\n    Binary2BCD B1(.num(floor_display),.thousand(thousand), .hundred(hundred),.ten(ten),.one(one) );\n\nendmodule"}, "output": {"rtl/elevator_control_system.sv": ""}, "obj": true}}
{"cvdp_copilot_elevator_control_0036": {"input": {"rtl/Binary2BCD.sv": "module Binary2BCD(input [7:0] num,output reg [3:0]thousand, output reg [3:0]hundred, output reg [3:0]ten, output reg [3:0]one );\n    reg[19:0] shift;\n    integer i;\n    \n    always @(num)\n    begin\n        shift[19:8] =0;\n        shift[7:0]=num;\n        \n        for(i=0;i<8;i=i+1)\n        begin\n            if(shift[11:8]>=5)\n                shift[11:8]=shift[11:8] +3;\n           \n            if(shift[15:12]>=5)\n                    shift[15:12]=shift[15:12] +3; \n\n            if(shift[19:16]>=5)\n                shift[19:16]=shift[19:16] +3;\n            \n            shift=shift <<1;                                       \n        end\n        \n        hundred=shift[19:16];\n        ten=shift[15:12];\n        one=shift[11:8];\n        thousand=4'b0000;\n        \n    end\n    \nendmodule", "rtl/elevator_control_system.sv": "/*\n * Elevator Control System\n * \n * This module implements an FSM-based elevator control system capable of managing multiple floors,\n * handling call requests, and responding to emergency stops. The elevator transitions between \n * five main states: Idle, Moving Up, Moving Down, Emergency Halt, Door Open. It prioritizes floor requests \n * based on direction, moving to the highest or lowest requested floor depending on the current direction.\n*/\nmodule elevator_control_system #(\n    parameter N = 8, //Number of floors\n    parameter DOOR_OPEN_TIME_MS = 500 // Door open time in milliseconds\n) ( \n    input wire clk,                   // 100MHz clock input\n    input wire reset,                 // Active-high reset signal\n    input wire [N-1:0] call_requests, // External Floor call requests\n    input wire emergency_stop,        // Emergency stop signal\n    input wire overload_detected,\n    output wire [$clog2(N)-1:0] current_floor, // Current floor of the elevator\n    output reg direction,             // Elevator direction: 1 = up, 0 = down\n    output reg door_open,             // Door open signal\n    output reg [2:0] system_status,    // Elevator system state indicator\n    output overload_warning,          // Overload warning signal\n    output [3:0]thousand,output[3:0] hundred, output [3:0]ten, output [3:0]one,\n    output wire [6:0] seven_seg_out,    // Seven-segment display output for current floor visualization\n    output wire [3:0] seven_seg_out_anode //Signal for switching between ones, tens, hundred, thousand place on seven segment\n\n);\n\n// State Encoding\nlocalparam IDLE = 3'b000;          // Elevator is idle\nlocalparam MOVING_UP = 3'b001;     // Elevator moving up\nlocalparam MOVING_DOWN = 3'b010;   // Elevator moving down\nlocalparam EMERGENCY_HALT = 3'b011;// Emergency halt state\nlocalparam DOOR_OPEN = 3'b100;     // Door open state\nlocalparam OVERLOAD_HALT = 3'b101; // New state for overload condition\n\n// Internal registers\nreg [N-1:0] call_requests_internal;   // Internal copy of call requests\nreg [2:0] present_state, next_state; // FSM current and next states\nreg [$clog2(N)-1:0] max_request;     // Highest requested floor\nreg [$clog2(N)-1:0] min_request;    // Lowest requested floor\n\n// Door open time configuration\n`ifdef SIMULATION\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam SIM_DOOR_OPEN_TIME_MS = 0.05; // Shorter door open time for simulation\n    localparam DOOR_OPEN_CYCLES = (SIM_DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000); // Door open cycles for simulation   \n`else\n    // Calculating door open cycles based on time and clock frequency\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam DOOR_OPEN_CYCLES = (DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000);   // Door open cycles for real implementation\n`endif\n\n\nreg [$clog2(DOOR_OPEN_CYCLES)-1:0] door_open_counter;   // Counter for door open duration\n\nreg [$clog2(N)-1:0] current_floor_reg, current_floor_next=0;\n\nassign current_floor = current_floor_reg;\n\n// Update overload warning signal\nassign overload_warning = (overload_detected == 1 && present_state == OVERLOAD_HALT);\n\n// FSM state transition\nalways@(posedge clk or posedge reset) begin\n    if(reset)begin\n        present_state <= IDLE;\n        system_status <= IDLE;\n        current_floor_reg <= 0;        \n    end else begin\n        present_state <= next_state;\n        system_status <= next_state;\n        current_floor_reg <= current_floor_next;\n    end\nend\n\nalways@(*) begin\n    if(reset)begin\n        max_request = 0;\n        min_request = {$clog2(N){1'b1}};        \n    end else begin        \n        // Calculate max_request and min_request based on active requests\n        max_request = 0;\n        min_request = {$clog2(N){1'b1}};\n        for (integer i = 0; i < N; i = i + 1) begin\n            if (call_requests_internal[i]) begin\n                if (i > max_request) \n                    max_request = i[$clog2(N)-1:0]; \n                if (i < min_request)  \n                    min_request = i[$clog2(N)-1:0]; \n            end\n        end\n    end\nend\n\nalways@(*)begin\n    next_state = present_state;\n    current_floor_next = current_floor_reg;\n    \n    case(present_state)\n        IDLE:begin\n            if(overload_detected) begin\n                next_state = OVERLOAD_HALT;\n            end else if(emergency_stop) begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal != 0)begin\n                if(max_request > current_floor_reg)begin\n                    next_state = MOVING_UP;\n                end else if(min_request < current_floor_reg) begin\n                    next_state = MOVING_DOWN;\n                end\n            end\n        end\n\n        MOVING_UP: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg+1]) begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg >= max_request) begin\n                // If we reach the highest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = MOVING_UP;\n            end\n        end\n\n        MOVING_DOWN: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg-1]) begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg <= min_request) begin\n                // If we reach the lowest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = MOVING_DOWN;\n            end\n        end\n\n        EMERGENCY_HALT: begin\n            if (!emergency_stop) begin\n                next_state = IDLE;\n                current_floor_next = 0; // Optionally reset to ground floor\n            end\n        end\n\n        DOOR_OPEN: begin\n            if(overload_detected) begin\n                next_state = OVERLOAD_HALT;\n            end else if (door_open_counter == 0) begin\n                next_state = IDLE;\n            end else begin\n                next_state = DOOR_OPEN;\n            end\n        end\n\n        OVERLOAD_HALT: begin\n            if(!overload_detected) begin\n                if(door_open) begin\n                    next_state = DOOR_OPEN;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n        end\n    endcase\nend\n\n\n// Door open control logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        door_open <= 0;\n    end else begin\n        if (present_state == OVERLOAD_HALT) begin\n            door_open <= 1;\n        end else if (present_state == DOOR_OPEN) begin\n            if (door_open_counter > 0) begin\n                door_open <= 1;\n            end else begin\n                door_open <= 0;\n            end\n        end else begin\n            door_open <= 0;\n        end\n    end\nend\n\n\nalways@(*) begin\n    if(present_state == OVERLOAD_HALT) begin\n        door_open <= 1;\n    end else if(present_state == DOOR_OPEN) begin\n        door_open <= 1;\n    end else begin\n        door_open <= 0;\n    end\nend\n\n\nalways @(posedge clk or posedge reset) begin\n    if(reset) begin\n        door_open_counter <= DOOR_OPEN_CYCLES;\n    end else if( present_state == DOOR_OPEN) begin\n        if(door_open_counter > 0 ) begin\n            door_open_counter = door_open_counter - 1;\n        end else begin\n            door_open_counter <= DOOR_OPEN_CYCLES;\n        end\n    end else begin\n        door_open_counter <= DOOR_OPEN_CYCLES;\n    end\n\nend\n\n\n// Call request management\nalways@(*)begin\n    if(reset) begin\n        call_requests_internal = 0;\n    end else begin\n        if(call_requests_internal[current_floor_reg])begin\n            call_requests_internal[current_floor_reg] = 0;      // Clear served request\n        end\n        call_requests_internal = call_requests_internal | call_requests;    // Update requests\n    end\nend\n\n// Direction control logic\nalways@(*)begin\n    if(reset) begin\n        direction = 1;\n    end else begin\n        if(present_state == MOVING_UP)begin\n            direction = 1;\n        end else if (present_state == MOVING_DOWN) begin\n            direction = 0;\n        end else begin\n            direction = 1;\n        end\n    end\nend\n\n\n// Seven-segment display converter instantiation\nfloor_to_seven_segment floor_display_converter (\n    .clk(clk),\n    .floor_display({{8-($clog2(N)){1'b0}},current_floor_reg}),\n    .seven_seg_out(seven_seg_out),\n    .seven_seg_out_anode(seven_seg_out_anode),\n    .thousand(thousand), .hundred(hundred),.ten(ten),.one(one)\n);\n\nendmodule", "rtl/floor_to_seven_segment.sv": "/*\n * Floor to Seven-Segment Display Converter\n * \n * Converts the current floor number (binary) to a seven-segment display output.\n * Supports floors 0 to N-1, with invalid inputs resulting in a blank display.\n */\nmodule floor_to_seven_segment (\n    input wire clk, \n    input wire [7:0] floor_display, // Binary floor number input\n    output reg [6:0] seven_seg_out, // Seven-segment display output: {a, b, c, d, e, f, g}\n    output [3:0]seven_seg_out_anode, ////Signal for switching between ones, tens, hundred, thousand place on seven segment\n    output [3:0] thousand, output[3:0] hundred, output [3:0]ten, output [3:0] one\n);\n\n    //Internal signals\n     reg [6:0]sseg_temp=7'b1111111;\n     reg [3:0]an_temp = 4'b1110 ;\n     reg [17:0] count=0; //the 18 bit counter which allows us to multiplex at 1000Hz\n\n     always @ (posedge clk)\n      begin\n        count <= count + 1;\n      end\n\n    //code for display multiple digits\nalways @(*) begin\n    case (count[17:16]) // Using only the 2 MSBs of the counter\n        2'b00: // When the 2 MSBs are 00, enable the fourth display\n        begin\n            case (one)\n                4'd0: sseg_temp = 7'b1111110; // Display 0\n                4'd1: sseg_temp = 7'b0110000; // Display 1\n                4'd2: sseg_temp = 7'b1101101; // Display 2\n                4'd3: sseg_temp = 7'b1111001; // Display 3\n                4'd4: sseg_temp = 7'b0110011; // Display 4\n                4'd5: sseg_temp = 7'b1011011; // Display 5\n                4'd6: sseg_temp = 7'b1011111; // Display 6\n                4'd7: sseg_temp = 7'b1110000; // Display 7\n                4'd8: sseg_temp = 7'b1111111; // Display 8\n                4'd9: sseg_temp = 7'b1111011; // Display 9\n                default: sseg_temp = 7'b0000000; // Blank display\n            endcase\n            an_temp = 4'b1110; // Enable the fourth display\n        end\n        \n        2'b01: // When the 2 MSBs are 01, enable the third display\n        begin\n            case (ten)\n                4'd0: sseg_temp = 7'b1111110; // Display 0\n                4'd1: sseg_temp = 7'b0110000; // Display 1\n                4'd2: sseg_temp = 7'b1101101; // Display 2\n                4'd3: sseg_temp = 7'b1111001; // Display 3\n                4'd4: sseg_temp = 7'b0110011; // Display 4\n                4'd5: sseg_temp = 7'b1011011; // Display 5\n                4'd6: sseg_temp = 7'b1011111; // Display 6\n                4'd7: sseg_temp = 7'b1110000; // Display 7\n                4'd8: sseg_temp = 7'b1111111; // Display 8\n                4'd9: sseg_temp = 7'b1111011; // Display 9\n                default: sseg_temp = 7'b0000000; // Blank display\n            endcase\n            an_temp = 4'b1101; // Enable the third display\n        end\n\n        2'b10: // When the 2 MSBs are 10, enable the second display\n        begin\n            case (hundred)\n                4'd0: sseg_temp = 7'b1111110; // Display 0\n                4'd1: sseg_temp = 7'b0110000; // Display 1\n                4'd2: sseg_temp = 7'b1101101; // Display 2\n                4'd3: sseg_temp = 7'b1111001; // Display 3\n                4'd4: sseg_temp = 7'b0110011; // Display 4\n                4'd5: sseg_temp = 7'b1011011; // Display 5\n                4'd6: sseg_temp = 7'b1011111; // Display 6\n                4'd7: sseg_temp = 7'b1110000; // Display 7\n                4'd8: sseg_temp = 7'b1111111; // Display 8\n                4'd9: sseg_temp = 7'b1111011; // Display 9\n                default: sseg_temp = 7'b0000000; // Blank display\n            endcase\n            an_temp = 4'b1011; // Enable the second display\n        end\n\n        2'b11: // When the 2 MSBs are 11, enable the first display\n        begin\n            case (thousand)\n                4'd0: sseg_temp = 7'b1111110; // Display 0\n                4'd1: sseg_temp = 7'b0110000; // Display 1\n                4'd2: sseg_temp = 7'b1101101; // Display 2\n                4'd3: sseg_temp = 7'b1111001; // Display 3\n                4'd4: sseg_temp = 7'b0110011; // Display 4\n                4'd5: sseg_temp = 7'b1011011; // Display 5\n                4'd6: sseg_temp = 7'b1011111; // Display 6\n                4'd7: sseg_temp = 7'b1110000; // Display 7\n                4'd8: sseg_temp = 7'b1111111; // Display 8\n                4'd9: sseg_temp = 7'b1111011; // Display 9\n                default: sseg_temp = 7'b0000000; // Blank display\n            endcase\n            an_temp = 4'b0111; // Enable the first display\n        end\n    endcase\nend\n\nassign seven_seg_out = sseg_temp;\nassign seven_seg_out_anode = an_temp;\n\n    //Binary to BCD covertor to receive seprate bits for ones, tens, hundred, thousand places\n    Binary2BCD B1(.num(floor_display),.thousand(thousand), .hundred(hundred),.ten(ten),.one(one) );\n\nendmodule"}, "output": {"rtl/elevator_control_system.sv": "/*\n * Elevator Control System\n * \n * This module implements an FSM-based elevator control system capable of managing multiple floors,\n * handling call requests, and responding to emergency stops. The elevator transitions between \n * five main states: Idle, Moving Up, Moving Down, Emergency Halt, Door Open. It prioritizes floor requests \n * based on direction, moving to the highest or lowest requested floor depending on the current direction.\n*/\nmodule elevator_control_system #(\n    parameter N = 8, //Number of floors\n    parameter DOOR_OPEN_TIME_MS = 500 // Door open time in milliseconds\n) ( \n    input wire clk,                   // 100MHz clock input\n    input wire reset,                 // Active-high reset signal\n    input wire [N-1:0] call_requests, // External Floor call requests\n    input wire emergency_stop,        // Emergency stop signal\n    input wire overload_detected,\n    output wire [$clog2(N)-1:0] current_floor, // Current floor of the elevator\n    output reg direction,             // Elevator direction: 1 = up, 0 = down\n    output reg door_open,             // Door open signal\n    output reg [2:0] system_status,    // Elevator system state indicator\n    output overload_warning,          // Overload warning signal\n    output [3:0]thousand,output[3:0] hundred, output [3:0]ten, output [3:0]one,\n    output wire [6:0] seven_seg_out,    // Seven-segment display output for current floor visualization\n    output wire [3:0] seven_seg_out_anode //Signal for switching between ones, tens, hundred, thousand place on seven segment\n\n);\n\n// State Encoding\nlocalparam IDLE = 3'b000;          // Elevator is idle\nlocalparam MOVING_UP = 3'b001;     // Elevator moving up\nlocalparam MOVING_DOWN = 3'b010;   // Elevator moving down\nlocalparam EMERGENCY_HALT = 3'b011;// Emergency halt state\nlocalparam DOOR_OPEN = 3'b100;     // Door open state\nlocalparam OVERLOAD_HALT = 3'b101; // New state for overload condition\n\n// Internal registers\nreg [N-1:0] call_requests_internal;   // Internal copy of call requests\nreg [2:0] present_state, next_state; // FSM current and next states\nreg [$clog2(N)-1:0] max_request;     // Highest requested floor\nreg [$clog2(N)-1:0] min_request;    // Lowest requested floor\n\n// Door open time configuration\n`ifdef SIMULATION\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam SIM_DOOR_OPEN_TIME_MS = 0.05; // Shorter door open time for simulation\n    localparam DOOR_OPEN_CYCLES = (SIM_DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000); // Door open cycles for simulation   \n`else\n    // Calculating door open cycles based on time and clock frequency\n    localparam CLK_FREQ_MHZ = 100;  // Clock frequency in MHz\n    localparam DOOR_OPEN_CYCLES = (DOOR_OPEN_TIME_MS * CLK_FREQ_MHZ * 1000);   // Door open cycles for real implementation\n`endif\n\n\nreg [$clog2(DOOR_OPEN_CYCLES)-1:0] door_open_counter;   // Counter for door open duration\n\nreg [$clog2(N)-1:0] current_floor_reg, current_floor_next=0;\n\nassign current_floor = current_floor_reg;\n\n// Update overload warning signal\nassign overload_warning = (overload_detected == 1 && present_state == OVERLOAD_HALT);\n\n// FSM state transition\nalways@(posedge clk or posedge reset) begin\n    if(reset)begin\n        present_state <= IDLE;\n        system_status <= IDLE;\n        current_floor_reg <= 0;        \n    end else begin\n        present_state <= next_state;\n        system_status <= next_state;\n        current_floor_reg <= current_floor_next;\n    end\nend\n\nalways@(*) begin\n    if(reset)begin\n        max_request = 0;\n        min_request = {$clog2(N){1'b1}};        \n    end else begin        \n        // Calculate max_request and min_request based on active requests\n        max_request = 0;\n        min_request = {$clog2(N){1'b1}};\n        for (integer i = 0; i < N; i = i + 1) begin\n            if (call_requests_internal[i]) begin\n                if (i > max_request) \n                    max_request = i[$clog2(N)-1:0]; \n                if (i < min_request)  \n                    min_request = i[$clog2(N)-1:0]; \n            end\n        end\n    end\nend\n\nalways@(*)begin\n    next_state = present_state;\n    current_floor_next = current_floor_reg;\n    \n    case(present_state)\n        IDLE:begin\n            if(overload_detected) begin\n                next_state = OVERLOAD_HALT;\n            end else if(emergency_stop) begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal != 0)begin\n                if(max_request > current_floor_reg)begin\n                    next_state = MOVING_UP;\n                end else if(min_request < current_floor_reg) begin\n                    next_state = MOVING_DOWN;\n                end\n            end\n        end\n\n        MOVING_UP: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg+1]) begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg >= max_request) begin\n                // If we reach the highest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg + 1;\n                next_state = MOVING_UP;\n            end\n        end\n\n        MOVING_DOWN: begin\n            if(emergency_stop)begin\n                next_state = EMERGENCY_HALT;\n            end else if(call_requests_internal[current_floor_reg-1]) begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = DOOR_OPEN;\n            end else if(current_floor_reg <= min_request) begin\n                // If we reach the lowest request, go idle\n                next_state = IDLE;\n            end else begin\n                current_floor_next = current_floor_reg - 1;\n                next_state = MOVING_DOWN;\n            end\n        end\n\n        EMERGENCY_HALT: begin\n            if (!emergency_stop) begin\n                next_state = IDLE;\n                current_floor_next = 0; // Optionally reset to ground floor\n            end\n        end\n\n        DOOR_OPEN: begin\n            if(overload_detected) begin\n                next_state = OVERLOAD_HALT;\n            end else if (door_open_counter == 0) begin\n                next_state = IDLE;\n            end else begin\n                next_state = DOOR_OPEN;\n            end\n        end\n\n        OVERLOAD_HALT: begin\n            if(!overload_detected) begin\n                if(door_open) begin\n                    next_state = DOOR_OPEN;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n        end\n    endcase\nend\n\n\n// Door open control logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        door_open <= 0;\n    end else begin\n        if (present_state == OVERLOAD_HALT) begin\n            door_open <= 1;\n        end else if (present_state == DOOR_OPEN) begin\n            if (door_open_counter > 0) begin\n                door_open <= 1;\n            end else begin\n                door_open <= 0;\n            end\n        end else begin\n            door_open <= 0;\n        end\n    end\nend\n\n\nalways@(*) begin\n    if(present_state == OVERLOAD_HALT) begin\n        door_open <= 1;\n    end else if(present_state == DOOR_OPEN) begin\n        door_open <= 1;\n    end else begin\n        door_open <= 0;\n    end\nend\n\n\nalways @(posedge clk or posedge reset) begin\n    if(reset) begin\n        door_open_counter <= DOOR_OPEN_CYCLES;\n    end else if( present_state == DOOR_OPEN) begin\n        if(door_open_counter > 0 ) begin\n            door_open_counter = door_open_counter - 1;\n        end else begin\n            door_open_counter <= DOOR_OPEN_CYCLES;\n        end\n    end else begin\n        door_open_counter <= DOOR_OPEN_CYCLES;\n    end\n\nend\n\n\n// Call request management\nalways@(*)begin\n    if(reset) begin\n        call_requests_internal = 0;\n    end else begin\n        if(call_requests_internal[current_floor_reg])begin\n            call_requests_internal[current_floor_reg] = 0;      // Clear served request\n        end\n        call_requests_internal = call_requests_internal | call_requests;    // Update requests\n    end\nend\n\n// Direction control logic\nalways@(*)begin\n    if(reset) begin\n        direction = 1;\n    end else begin\n        if(present_state == MOVING_UP)begin\n            direction = 1;\n        end else if (present_state == MOVING_DOWN) begin\n            direction = 0;\n        end else begin\n            direction = 1;\n        end\n    end\nend\n\n\n// Seven-segment display converter instantiation\nfloor_to_seven_segment floor_display_converter (\n    .clk(clk),\n    .floor_display({{8-($clog2(N)){1'b0}},current_floor_reg}),\n    .seven_seg_out(seven_seg_out),\n    .seven_seg_out_anode(seven_seg_out_anode),\n    .thousand(thousand), .hundred(hundred),.ten(ten),.one(one)\n);\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_ethernet_packet_parser_0001": {"input": {}, "output": {"rtl/ethernet_parser.v": ""}, "obj": true}}
{"cvdp_copilot_events_to_apb_0001": {"input": {}, "output": {"rtl/apb_controller.sv": ""}, "obj": true}}
{"cvdp_copilot_factorial_0001": {"input": {}, "output": {"rtl/factorial.sv": ""}, "obj": true}}
{"cvdp_copilot_fan_controller_0001": {"input": {}, "output": {"rtl/fan_controller.sv": ""}, "obj": true}}
{"cvdp_copilot_fan_controller_0005": {"input": {"rtl/fan_controller.sv": "module fan_controller (\n    input wire clk,                 // System clock\n    input wire reset,               // Reset signal\n    output reg fan_pwm_out,         // PWM output for fan control\n\n    //APB signals\n    input  wire         psel,       // Slave select\n    input  wire         penable,    // Enable signal\n    input  wire         pwrite,     // Write control\n    input  wire [7:0]   paddr,      // Address bus\n    input  wire [7:0]   pwdata,     // Write data bus\n    output reg  [7:0]   prdata,     // Read data bus\n    output reg          pready,      // Ready signal\n    output reg          pslverr     // Slave error\n);\n\n    // Parameters for temperature thresholds\n    reg [7:0] TEMP_LOW ;      // Low temperature threshold\n    reg [7:0] TEMP_MED ;      // Medium temperature threshold\n    reg [7:0] TEMP_HIGH;      // High temperature threshold\n    reg [7:0]  temp_adc_in;   // Temperature sensor input (0-255)\n  \n    reg setup;\n    // APB Protocol States\n    always @(posedge clk or posedge reset)\n\tbegin\n        if (reset)\n        begin\n            prdata   <= 7'b0;\n            pready   <= 1'b0;\n            pslverr  <= 1'b0;\n            TEMP_LOW <= 7'd30;\n            TEMP_MED <= 7'd60;\n            TEMP_HIGH <=7'd90;\n            setup  <= 1'b0;\n        end\n        else\n        begin\n            if (psel && !penable && !setup)\n            begin\n                // Setup phase: Indicate the slave is not yet ready\n                pready <= 1'b0;\n                setup  <= 1'b1;\n\n            end\n            else if (psel && penable && setup)\n            begin\n                // Access phase: Perform read/write operation and indicate ready\n                pready <= 1'b1; // Slave is ready for the current operation\n                setup  <= 1'b0;\n                if (pwrite)\n                 begin\n                    // Write Operation\n                    case(paddr)\n                          16'h0a: begin \n                                  TEMP_LOW    <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          16'h0b: begin \n                                  TEMP_MED    <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          16'h0c: begin\n                                  TEMP_HIGH   <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          16'h0f: begin\n                                  temp_adc_in <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          default:pslverr     <= 1'b1;\n                    endcase\n                end\n                else \n                begin\n                    // Read Operation\n                    case(paddr)\n                          16'h0a: begin\n                                  prdata   <= TEMP_LOW ;\n                                  pslverr  <= 1'b0;\n                                  end\n                          16'h0b: begin \n                                  prdata   <= TEMP_MED ;\n                                  pslverr  <= 1'b0;\n                                  end\n                          16'h0c: begin\n                                  prdata   <= TEMP_HIGH;\n                                  pslverr  <= 1'b0;\n                                  end\n                          16'h0f: begin\n                                  prdata   <= temp_adc_in;\n                                  pslverr  <= 1'b0;\n                                  end\n                          default:pslverr  <= 1'b1;\n                    endcase\n                end\n            end\n            else\n            begin\n                // Default case: Clear ready signal when not selected\n                pready <= 1'b0;\n                setup  <= 1'b0;\n            end\n        end\n    end\n\n    // PWM control\n    reg [7:0] pwm_duty_cycle;    // Duty cycle (0-255)\n    reg [7:0] pwm_counter;       // Counter for PWM generation\n    wire [1:0] speed_control;    //speed control bit \n    // Fan speed adjustment logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n        begin\n            pwm_duty_cycle <= 8'd0;  // Fan off by default\n        end \n        else\n        begin\n            case(speed_control)\n              1 : pwm_duty_cycle <= 8'd64;  // Low speed (25% duty cycle)\n              2 : pwm_duty_cycle <= 8'd128; // Medium speed (50% duty cycle)\n              3 : pwm_duty_cycle <= 8'd192; // High speed (75% duty cycle)\n              4 : pwm_duty_cycle <= 8'd255; // Full speed (100% duty cycle)\n            default :  pwm_duty_cycle <= 8'd255; // Full speed (100% duty cycle)\n            endcase\n\n        end\n    end\n\n    assign speed_control = (temp_adc_in < TEMP_LOW ? 1 : \n                           (temp_adc_in < TEMP_MED ? 2 : \n                           (temp_adc_in < TEMP_HIGH ? 3 : 4)));\n\n    // PWM generation logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            pwm_counter <= 8'd0;\n            fan_pwm_out <= 1'b0;\n        end else begin\n            pwm_counter <= pwm_counter + 1;\n            fan_pwm_out <= (pwm_counter < pwm_duty_cycle) ? 1'b1 : 1'b0;\n        end\n    end\n\nendmodule"}, "output": {"rtl/fan_controller.sv": "module fan_controller (\n    input wire clk,                 // System clock\n    input wire reset,               // Reset signal\n    output reg fan_pwm_out,         // PWM output for fan control\n\n    //APB signals\n    input  wire         psel,       // Slave select\n    input  wire         penable,    // Enable signal\n    input  wire         pwrite,     // Write control\n    input  wire [7:0]   paddr,      // Address bus\n    input  wire [7:0]   pwdata,     // Write data bus\n    output reg  [7:0]   prdata,     // Read data bus\n    output reg          pready,      // Ready signal\n    output reg          pslverr     // Slave error\n);\n\n    // Parameters for temperature thresholds\n    reg [7:0] TEMP_LOW ;      // Low temperature threshold\n    reg [7:0] TEMP_MED ;      // Medium temperature threshold\n    reg [7:0] TEMP_HIGH;      // High temperature threshold\n    reg [7:0]  temp_adc_in;   // Temperature sensor input (0-255)\n  \n    reg setup;\n    // APB Protocol States\n    always @(posedge clk or posedge reset)\n\tbegin\n        if (reset)\n        begin\n            prdata   <= 7'b0;\n            pready   <= 1'b0;\n            pslverr  <= 1'b0;\n            TEMP_LOW <= 7'd30;\n            TEMP_MED <= 7'd60;\n            TEMP_HIGH <=7'd90;\n            setup  <= 1'b0;\n        end\n        else\n        begin\n            if (psel && !penable && !setup)\n            begin\n                // Setup phase: Indicate the slave is not yet ready\n                pready <= 1'b0;\n                setup  <= 1'b1;\n\n            end\n            else if (psel && penable && setup)\n            begin\n                // Access phase: Perform read/write operation and indicate ready\n                pready <= 1'b1; // Slave is ready for the current operation\n                setup  <= 1'b0;\n                if (pwrite)\n                 begin\n                    // Write Operation\n                    case(paddr)\n                          16'h0a: begin \n                                  TEMP_LOW    <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          16'h0b: begin \n                                  TEMP_MED    <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          16'h0c: begin\n                                  TEMP_HIGH   <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          16'h0f: begin\n                                  temp_adc_in <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          default:pslverr     <= 1'b1;\n                    endcase\n                end\n                else \n                begin\n                    // Read Operation\n                    case(paddr)\n                          16'h0a: begin\n                                  prdata   <= TEMP_LOW ;\n                                  pslverr  <= 1'b0;\n                                  end\n                          16'h0b: begin \n                                  prdata   <= TEMP_MED ;\n                                  pslverr  <= 1'b0;\n                                  end\n                          16'h0c: begin\n                                  prdata   <= TEMP_HIGH;\n                                  pslverr  <= 1'b0;\n                                  end\n                          16'h0f: begin\n                                  prdata   <= temp_adc_in;\n                                  pslverr  <= 1'b0;\n                                  end\n                          default:pslverr  <= 1'b1;\n                    endcase\n                end\n            end\n            else\n            begin\n                // Default case: Clear ready signal when not selected\n                pready <= 1'b0;\n                setup  <= 1'b0;\n            end\n        end\n    end\n\n    // PWM control\n    reg [7:0] pwm_duty_cycle;    // Duty cycle (0-255)\n    reg [7:0] pwm_counter;       // Counter for PWM generation\n    wire [1:0] speed_control;    //speed control bit \n    // Fan speed adjustment logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n        begin\n            pwm_duty_cycle <= 8'd0;  // Fan off by default\n        end \n        else\n        begin\n            case(speed_control)\n              1 : pwm_duty_cycle <= 8'd64;  // Low speed (25% duty cycle)\n              2 : pwm_duty_cycle <= 8'd128; // Medium speed (50% duty cycle)\n              3 : pwm_duty_cycle <= 8'd192; // High speed (75% duty cycle)\n              4 : pwm_duty_cycle <= 8'd255; // Full speed (100% duty cycle)\n            default :  pwm_duty_cycle <= 8'd255; // Full speed (100% duty cycle)\n            endcase\n\n        end\n    end\n\n    assign speed_control = (temp_adc_in < TEMP_LOW ? 1 : \n                           (temp_adc_in < TEMP_MED ? 2 : \n                           (temp_adc_in < TEMP_HIGH ? 3 : 4)));\n\n    // PWM generation logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            pwm_counter <= 8'd0;\n            fan_pwm_out <= 1'b0;\n        end else begin\n            pwm_counter <= pwm_counter + 1;\n            fan_pwm_out <= (pwm_counter < pwm_duty_cycle) ? 1'b1 : 1'b0;\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_fan_controller_0008": {"input": {"rtl/fan_controller.sv": "module fan_controller (\n    input wire clk,                 // System clock\n    input wire reset,               // Reset signal\n    output reg fan_pwm_out,         // PWM output for fan control\n\n    //APB signals\n    input  wire         psel,       // Slave select\n    input  wire         penable,    // Enable signal\n    input  wire         pwrite,     // Write control\n    input  wire [7:0]   paddr,      // Address bus\n    input  wire [7:0]   pwdata,     // Write data bus\n    output reg  [7:0]   prdata,     // Read data bus\n    output reg          pready,      // Ready signal\n    output reg          pslverr     // Slave error\n);\n\n    // Parameters for temperature thresholds\n    reg [7:0] TEMP_LOW ;      // Low temperature threshold\n    reg [7:0] TEMP_MED ;      // Medium temperature threshold\n    reg [7:0] TEMP_HIGH;      // High temperature threshold\n    reg [7:0]  temp_adc_in;   // Temperature sensor input (0-255)\n  \n    reg setup;\n    // APB Protocol States\n    always @(posedge clk or posedge reset)\n\tbegin\n        if (reset)\n        begin\n            prdata   <= 8'b0;\n            pready   <= 1'b0;\n            pslverr  <= 1'b0;\n            TEMP_LOW <= 8'd30;\n            TEMP_MED <= 8'd60;\n            TEMP_HIGH <=8'd90;\n            setup  <= 1'b0;\n        end\n        else\n        begin\n            if (psel && !penable && !setup)\n            begin\n                // Setup phase: Indicate the slave is not yet ready\n                pready <= 1'b0;\n                setup  <= 1'b1;\n\n            end\n            else if (psel && penable && setup)\n            begin\n                // Access phase: Perform read/write operation and indicate ready\n                pready <= 1'b1; // Slave is ready for the current operation\n                setup  <= 1'b0;\n                if (pwrite)\n                 begin\n                    // Write Operation\n                    case(paddr)\n                          8'h0a: begin \n                                  TEMP_LOW    <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          8'h0b: begin \n                                  TEMP_MED    <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          8'h0c: begin\n                                  TEMP_HIGH   <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          8'h0f: begin\n                                  temp_adc_in <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          default:pslverr     <= 1'b1;\n                    endcase\n                end\n                else \n                begin\n                    // Read Operation\n                    case(paddr)\n                          8'h0a: begin\n                                  prdata   <= TEMP_LOW ;\n                                  pslverr  <= 1'b0;\n                                  end\n                          8'h0b: begin \n                                  prdata   <= TEMP_MED ;\n                                  pslverr  <= 1'b0;\n                                  end\n                          8'h0c: begin\n                                  prdata   <= TEMP_HIGH;\n                                  pslverr  <= 1'b0;\n                                  end\n                          8'h0f: begin\n                                  prdata   <= temp_adc_in;\n                                  pslverr  <= 1'b0;\n                                  end\n                          default:pslverr  <= 1'b1;\n                    endcase\n                end\n            end\n            else\n            begin\n                // Default case: Clear ready signal when not selected\n                pready <= 1'b0;\n                setup  <= 1'b0;\n            end\n        end\n    end\n\n    // PWM control\n    reg [7:0] pwm_duty_cycle;    // Duty cycle (0-255)\n    reg [7:0] pwm_counter;       // Counter for PWM generation\n    wire [2:0] speed_control;    //speed control bit \n    // Fan speed adjustment logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n        begin\n            pwm_duty_cycle <= 8'd0;  // Fan off by default\n        end \n        else\n        begin\n            case(speed_control)\n              3'd1 : pwm_duty_cycle <= 8'd64;  // Low speed (25% duty cycle)\n              3'd2 : pwm_duty_cycle <= 8'd128; // Medium speed (50% duty cycle)\n              3'd3 : pwm_duty_cycle <= 8'd192; // High speed (75% duty cycle)\n              3'd4 : pwm_duty_cycle <= 8'd255; // Full speed (100% duty cycle)\n            default :  pwm_duty_cycle <= 8'd255; // Full speed (100% duty cycle)\n            endcase\n\n        end\n    end\n\n    assign speed_control = (temp_adc_in < TEMP_LOW ? 3'd1 : \n                           (temp_adc_in < TEMP_MED ? 3'd2 : \n                           (temp_adc_in < TEMP_HIGH ? 3'd3 : 3'd4)));\n\n    // PWM generation logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            pwm_counter <= 8'd0;\n            fan_pwm_out <= 1'b0;\n        end else begin\n            pwm_counter <= pwm_counter + 1;\n            fan_pwm_out <= (pwm_counter < pwm_duty_cycle) ? 1'b1 : 1'b0;\n        end\n    end\n\nendmodule"}, "output": {"rtl/fan_controller.sv": "module fan_controller (\n    input wire clk,                 // System clock\n    input wire reset,               // Reset signal\n    output reg fan_pwm_out,         // PWM output for fan control\n\n    //APB signals\n    input  wire         psel,       // Slave select\n    input  wire         penable,    // Enable signal\n    input  wire         pwrite,     // Write control\n    input  wire [7:0]   paddr,      // Address bus\n    input  wire [7:0]   pwdata,     // Write data bus\n    output reg  [7:0]   prdata,     // Read data bus\n    output reg          pready,      // Ready signal\n    output reg          pslverr     // Slave error\n);\n\n    // Parameters for temperature thresholds\n    reg [7:0] TEMP_LOW ;      // Low temperature threshold\n    reg [7:0] TEMP_MED ;      // Medium temperature threshold\n    reg [7:0] TEMP_HIGH;      // High temperature threshold\n    reg [7:0]  temp_adc_in;   // Temperature sensor input (0-255)\n  \n    reg setup;\n    // APB Protocol States\n    always @(posedge clk or posedge reset)\n\tbegin\n        if (reset)\n        begin\n            prdata   <= 8'b0;\n            pready   <= 1'b0;\n            pslverr  <= 1'b0;\n            TEMP_LOW <= 8'd30;\n            TEMP_MED <= 8'd60;\n            TEMP_HIGH <=8'd90;\n            setup  <= 1'b0;\n        end\n        else\n        begin\n            if (psel && !penable && !setup)\n            begin\n                // Setup phase: Indicate the slave is not yet ready\n                pready <= 1'b0;\n                setup  <= 1'b1;\n\n            end\n            else if (psel && penable && setup)\n            begin\n                // Access phase: Perform read/write operation and indicate ready\n                pready <= 1'b1; // Slave is ready for the current operation\n                setup  <= 1'b0;\n                if (pwrite)\n                 begin\n                    // Write Operation\n                    case(paddr)\n                          8'h0a: begin \n                                  TEMP_LOW    <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          8'h0b: begin \n                                  TEMP_MED    <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          8'h0c: begin\n                                  TEMP_HIGH   <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          8'h0f: begin\n                                  temp_adc_in <= pwdata;\n                                  pslverr     <= 1'b0;\n                                  end\n                          default:pslverr     <= 1'b1;\n                    endcase\n                end\n                else \n                begin\n                    // Read Operation\n                    case(paddr)\n                          8'h0a: begin\n                                  prdata   <= TEMP_LOW ;\n                                  pslverr  <= 1'b0;\n                                  end\n                          8'h0b: begin \n                                  prdata   <= TEMP_MED ;\n                                  pslverr  <= 1'b0;\n                                  end\n                          8'h0c: begin\n                                  prdata   <= TEMP_HIGH;\n                                  pslverr  <= 1'b0;\n                                  end\n                          8'h0f: begin\n                                  prdata   <= temp_adc_in;\n                                  pslverr  <= 1'b0;\n                                  end\n                          default:pslverr  <= 1'b1;\n                    endcase\n                end\n            end\n            else\n            begin\n                // Default case: Clear ready signal when not selected\n                pready <= 1'b0;\n                setup  <= 1'b0;\n            end\n        end\n    end\n\n    // PWM control\n    reg [7:0] pwm_duty_cycle;    // Duty cycle (0-255)\n    reg [7:0] pwm_counter;       // Counter for PWM generation\n    wire [2:0] speed_control;    //speed control bit \n    // Fan speed adjustment logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n        begin\n            pwm_duty_cycle <= 8'd0;  // Fan off by default\n        end \n        else\n        begin\n            case(speed_control)\n              3'd1 : pwm_duty_cycle <= 8'd64;  // Low speed (25% duty cycle)\n              3'd2 : pwm_duty_cycle <= 8'd128; // Medium speed (50% duty cycle)\n              3'd3 : pwm_duty_cycle <= 8'd192; // High speed (75% duty cycle)\n              3'd4 : pwm_duty_cycle <= 8'd255; // Full speed (100% duty cycle)\n            default :  pwm_duty_cycle <= 8'd255; // Full speed (100% duty cycle)\n            endcase\n\n        end\n    end\n\n    assign speed_control = (temp_adc_in < TEMP_LOW ? 3'd1 : \n                           (temp_adc_in < TEMP_MED ? 3'd2 : \n                           (temp_adc_in < TEMP_HIGH ? 3'd3 : 3'd4)));\n\n    // PWM generation logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            pwm_counter <= 8'd0;\n            fan_pwm_out <= 1'b0;\n        end else begin\n            pwm_counter <= pwm_counter + 1;\n            fan_pwm_out <= (pwm_counter < pwm_duty_cycle) ? 1'b1 : 1'b0;\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_fibonacci_series_0001": {"input": {}, "output": {"rtl/fibonacci_series.sv": ""}, "obj": true}}
{"cvdp_copilot_fifo_async_0001": {"input": {}, "output": {"rtl/fifo_async.sv": ""}, "obj": true}}
{"cvdp_copilot_fifo_to_axis_0001": {"input": {}, "output": {"rtl/ping_pong_fifo_2_axi_stream.sv": ""}, "obj": true}}
{"cvdp_copilot_fifo_to_axis_0005": {"input": {"rtl/ping_pong_fifo_2_axi_stream.sv": "module ping_pong_fifo_2_axi_stream #( \n    parameter DATA_WIDTH = 32\n)(\n    input  logic                                 rst,\n    \n    // Ping Pong FIFO Read Interface\n    input  logic                                 i_block_fifo_rdy,\n    output logic                                 o_block_fifo_act,\n    input  logic [23:0]                          i_block_fifo_size,\n    input  logic [(DATA_WIDTH + 1) - 1:0]        i_block_fifo_data,\n    output logic                                 o_block_fifo_stb,\n    input  logic [3:0]                           i_axi_user,\n    \n    // AXI Stream Output\n    input  logic                                 i_axi_clk,\n    output logic [3:0]                           o_axi_user,\n    input  logic                                 i_axi_ready,\n    output logic [DATA_WIDTH - 1:0]              o_axi_data,\n    output logic                                 o_axi_last,\n    output logic                                 o_axi_valid\n);\n\n    // Internal Registers\n    logic [23:0] block_size_reg;\n    logic [23:0] data_count;\n    logic        fifo_active;\n    logic        data_valid;\n    \n    typedef enum logic [1:0] {\n        IDLE,\n        READ_FIFO,\n        SEND_AXI\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    always_ff @(posedge i_axi_clk or posedge rst) begin\n        if (rst) begin\n            current_state      <= IDLE;\n            block_size_reg     <= 24'd0;\n            data_count         <= 24'd0;\n            fifo_active        <= 1'b0;\n            o_block_fifo_act   <= 1'b0;\n            o_block_fifo_stb   <= 1'b0;\n            o_axi_valid        <= 1'b0;\n            o_axi_data         <= {DATA_WIDTH{1'b0}};\n            o_axi_last         <= 1'b0;\n            o_axi_user         <= 4'd0;\n        end else begin\n            current_state      <= next_state;\n            o_block_fifo_act   <= 1'b0;\n            o_block_fifo_stb   <= 1'b0;\n            o_axi_valid        <= 1'b0;\n            o_axi_last         <= 1'b0;\n            \n            case (current_state)\n                IDLE: begin\n                    if (i_block_fifo_rdy) begin\n                        o_block_fifo_act <= 1'b1; \n                        block_size_reg    <= i_block_fifo_size;\n                        fifo_active       <= 1'b1;\n                        data_count        <= 24'd0;\n                        next_state        <= READ_FIFO;\n                    end else begin\n                        next_state <= IDLE;\n                    end\n                end\n                \n                READ_FIFO: begin\n                    if (fifo_active && i_block_fifo_rdy) begin\n                        o_block_fifo_stb <= 1'b1; \n                        data_count       <= data_count + 24'd1;\n                        next_state       <= SEND_AXI;\n                    end else begin\n                        next_state <= READ_FIFO;\n                    end\n                end\n                \n                SEND_AXI: begin\n                    if (fifo_active && i_axi_ready) begin\n                        o_axi_valid  <= 1'b1;\n                        o_axi_data   <= i_block_fifo_data[DATA_WIDTH-1:0];\n                        o_axi_user   <= i_axi_user;\n                        \n                        if (data_count + 24'd1 >= block_size_reg) begin\n                            o_axi_last <= 1'b1;\n                            fifo_active <= 1'b0; \n                            next_state  <= IDLE;\n                        end else begin\n                            next_state <= READ_FIFO;\n                        end\n                    end else begin\n                        next_state <= SEND_AXI;\n                    end\n                end\n                \n                default: next_state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}, "output": {"rtl/ping_pong_fifo_2_axi_stream.sv": "module ping_pong_fifo_2_axi_stream #( \n    parameter DATA_WIDTH = 32\n)(\n    input  logic                                 rst,\n    \n    // Ping Pong FIFO Read Interface\n    input  logic                                 i_block_fifo_rdy,\n    output logic                                 o_block_fifo_act,\n    input  logic [23:0]                          i_block_fifo_size,\n    input  logic [(DATA_WIDTH + 1) - 1:0]        i_block_fifo_data,\n    output logic                                 o_block_fifo_stb,\n    input  logic [3:0]                           i_axi_user,\n    \n    // AXI Stream Output\n    input  logic                                 i_axi_clk,\n    output logic [3:0]                           o_axi_user,\n    input  logic                                 i_axi_ready,\n    output logic [DATA_WIDTH - 1:0]              o_axi_data,\n    output logic                                 o_axi_last,\n    output logic                                 o_axi_valid\n);\n\n    // Internal Registers\n    logic [23:0] block_size_reg;\n    logic [23:0] data_count;\n    logic        fifo_active;\n    logic        data_valid;\n    \n    typedef enum logic [1:0] {\n        IDLE,\n        READ_FIFO,\n        SEND_AXI\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    always_ff @(posedge i_axi_clk or posedge rst) begin\n        if (rst) begin\n            current_state      <= IDLE;\n            block_size_reg     <= 24'd0;\n            data_count         <= 24'd0;\n            fifo_active        <= 1'b0;\n            o_block_fifo_act   <= 1'b0;\n            o_block_fifo_stb   <= 1'b0;\n            o_axi_valid        <= 1'b0;\n            o_axi_data         <= {DATA_WIDTH{1'b0}};\n            o_axi_last         <= 1'b0;\n            o_axi_user         <= 4'd0;\n        end else begin\n            current_state      <= next_state;\n            o_block_fifo_act   <= 1'b0;\n            o_block_fifo_stb   <= 1'b0;\n            o_axi_valid        <= 1'b0;\n            o_axi_last         <= 1'b0;\n            \n            case (current_state)\n                IDLE: begin\n                    if (i_block_fifo_rdy) begin\n                        o_block_fifo_act <= 1'b1; \n                        block_size_reg    <= i_block_fifo_size;\n                        fifo_active       <= 1'b1;\n                        data_count        <= 24'd0;\n                        next_state        <= READ_FIFO;\n                    end else begin\n                        next_state <= IDLE;\n                    end\n                end\n                \n                READ_FIFO: begin\n                    if (fifo_active && i_block_fifo_rdy) begin\n                        o_block_fifo_stb <= 1'b1; \n                        data_count       <= data_count + 24'd1;\n                        next_state       <= SEND_AXI;\n                    end else begin\n                        next_state <= READ_FIFO;\n                    end\n                end\n                \n                SEND_AXI: begin\n                    if (fifo_active && i_axi_ready) begin\n                        o_axi_valid  <= 1'b1;\n                        o_axi_data   <= i_block_fifo_data[DATA_WIDTH-1:0];\n                        o_axi_user   <= i_axi_user;\n                        \n                        if (data_count + 24'd1 >= block_size_reg) begin\n                            o_axi_last <= 1'b1;\n                            fifo_active <= 1'b0; \n                            next_state  <= IDLE;\n                        end else begin\n                            next_state <= READ_FIFO;\n                        end\n                    end else begin\n                        next_state <= SEND_AXI;\n                    end\n                end\n                \n                default: next_state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_filo_0005": {"input": {}, "output": {"rtl/FILO_RTL.sv": ""}, "obj": true}}
{"cvdp_copilot_filo_0033": {"input": {"rtl/FILO_RTL.sv": "module FILO_RTL #(\n    parameter DATA_WIDTH = 8,  // Width of the data entries\n    parameter FILO_DEPTH = 16  // Depth of the FILO buffer\n) (\n    input  wire                  clk,       // Clock signal\n    input  wire                  reset,     // Asynchronous reset signal\n    input  wire                  push,      // Push control signal\n    input  wire                  pop,       // Pop control signal\n    input  wire [DATA_WIDTH-1:0] data_in,   // Data input\n    output reg  [DATA_WIDTH-1:0] data_out,  // Data output\n    output reg                   full,      // Full status signal\n    output reg                   empty      // Empty status signal\n);\n\n \n  reg [DATA_WIDTH-1:0] memory[FILO_DEPTH-1:0];  \n  reg [$clog2(FILO_DEPTH):0] top;  \n \n  reg feedthrough_valid;\n  reg [DATA_WIDTH-1:0] feedthrough_data;\n\n \n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      top <= 0;\n      empty <= 1;\n      full <= 0;\n      feedthrough_valid <= 0;\n      data_out <= 0;  \n    end else begin\n    \n      if (push && pop && empty) begin\n        data_out <= data_in; \n        feedthrough_data <= data_in;\n        feedthrough_valid <= 1;\n      end else begin\n      \n        if (push && !full) begin\n          memory[top] <= data_in;  \n          top <= top + 1;  \n          feedthrough_valid <= 0;\n        end\n\n        if (pop && !empty) begin\n          if (feedthrough_valid) begin\n            data_out <= feedthrough_data;  \n            feedthrough_valid <= 0;\n          end else begin\n            top <= top; \n            data_out <= memory[top-1]; \n          end\n        end\n      end\n\n      empty <= (top == 0);\n      full  <= (top == FILO_DEPTH);  \n    end\n  end\nendmodule"}, "output": {"rtl/FILO_RTL.sv": ""}, "obj": true}}
{"cvdp_copilot_findfasterclock_0001": {"input": {}, "output": {"rtl/findfasterclock.sv": ""}, "obj": true}}
{"cvdp_copilot_flop_0001": {"input": {}, "output": {"rtl/SR_flipflop.sv": ""}, "obj": true}}
{"cvdp_copilot_flop_0002": {"input": {}, "output": {"rtl/JK_flipflop.sv": ""}, "obj": true}}
{"cvdp_copilot_fsm_seq_detector_0001": {"input": {}, "output": {"rtl/fsm_seq_detector.sv": ""}, "obj": true}}
{"cvdp_copilot_fsm_seq_detector_0023": {"input": {"rtl/fsm_seq_detector.sv": "module fsm_seq_detector\n(\n    input  bit     clk_in,       // Free Running Clock\n    input  logic   rst_in,       // Active HIGH reset\n    input  logic   seq_in,       // Continuous 1-bit Sequence Input\n    output logic   seq_detected  // '0': Not Detected. '1': Detected. Will be HIGH for 1 Clock cycle Only\n);\n\ntypedef enum logic [2:0] {S0, S1, S2, S3, S4, S5, S6, S7} state_t;\nstate_t cur_state, next_state;\n\nlogic seq_detected_w;\n\nalways @ (posedge clk_in or posedge rst_in)\nbegin\n    if (rst_in)\n        cur_state <= S0;\n    else\n        cur_state <= next_state;\nend\n\nalways_comb begin\n    if (rst_in) begin\n        seq_detected_w = 1'b0;\n        next_state = S0;\n    end\n    else begin\n        case (cur_state)\n            S0: begin\n                if (seq_in) begin\n                    next_state = S1;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    seq_detected_w = 1'b0;\n                    next_state = S0;\n                end\t\n            end\n            S1: begin\n                if (seq_in) begin\n                    next_state = S1;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S2;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S2: begin\n                if (seq_in) begin\n                    next_state = S3;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S0;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S3: begin\n                if (seq_in) begin\n                    next_state = S4;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S2;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S4: begin\n                if (seq_in) begin\n                    next_state = S1;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S5;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S5: begin\n                if (seq_in) begin\n                    next_state = S3;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S6;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S6: begin\n                if (seq_in) begin\n                    next_state = S1;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S7;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S7: begin\n                if (seq_in) begin\n                    next_state = S1;\n                    seq_detected_w = 1'b1;\n                end\n                else begin\n                    next_state = S0;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            default: begin\n                next_state = S0;\n                seq_detected_w = 1'b0;\n            end\n        endcase\n    end\nend\n\nalways @ (posedge clk_in or posedge rst_in)\nbegin\n    if (rst_in)\n        seq_detected <= 1'b0;\n    else\n        seq_detected <= seq_detected_w;\nend\n\nendmodule"}, "output": {"rtl/fsm_seq_detector.sv": "module fsm_seq_detector\n(\n    input  bit     clk_in,       // Free Running Clock\n    input  logic   rst_in,       // Active HIGH reset\n    input  logic   seq_in,       // Continuous 1-bit Sequence Input\n    output logic   seq_detected  // '0': Not Detected. '1': Detected. Will be HIGH for 1 Clock cycle Only\n);\n\ntypedef enum logic [2:0] {S0, S1, S2, S3, S4, S5, S6, S7} state_t;\nstate_t cur_state, next_state;\n\nlogic seq_detected_w;\n\nalways @ (posedge clk_in or posedge rst_in)\nbegin\n    if (rst_in)\n        cur_state <= S0;\n    else\n        cur_state <= next_state;\nend\n\nalways_comb begin\n    if (rst_in) begin\n        seq_detected_w = 1'b0;\n        next_state = S0;\n    end\n    else begin\n        case (cur_state)\n            S0: begin\n                if (seq_in) begin\n                    next_state = S1;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    seq_detected_w = 1'b0;\n                    next_state = S0;\n                end\t\n            end\n            S1: begin\n                if (seq_in) begin\n                    next_state = S1;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S2;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S2: begin\n                if (seq_in) begin\n                    next_state = S3;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S0;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S3: begin\n                if (seq_in) begin\n                    next_state = S4;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S2;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S4: begin\n                if (seq_in) begin\n                    next_state = S1;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S5;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S5: begin\n                if (seq_in) begin\n                    next_state = S3;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S6;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S6: begin\n                if (seq_in) begin\n                    next_state = S1;\n                    seq_detected_w = 1'b0;\n                end\n                else begin\n                    next_state = S7;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            S7: begin\n                if (seq_in) begin\n                    next_state = S1;\n                    seq_detected_w = 1'b1;\n                end\n                else begin\n                    next_state = S0;\n                    seq_detected_w = 1'b0;\n                end\n            end\n            default: begin\n                next_state = S0;\n                seq_detected_w = 1'b0;\n            end\n        endcase\n    end\nend\n\nalways @ (posedge clk_in or posedge rst_in)\nbegin\n    if (rst_in)\n        seq_detected <= 1'b0;\n    else\n        seq_detected <= seq_detected_w;\nend\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_galois_encryption_0001": {"input": {"rtl/galois_encryption.sv": "/*\nGalois field (2^8) matrix-based encryption/decryption system using AES's polynomial to perform galois field operations\n*/\n\nmodule galois_encryption #(\n    parameter NBW_DATA = 'd128,\n    parameter NBW_KEY  = 'd32\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_encrypt,\n    input  logic                i_valid,\n    input  logic [NBW_DATA-1:0] i_data,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    output logic                o_valid,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam LATENCY  = 'd3;\nlocalparam NBW_WORD = 'd8;\nlocalparam MOD_POLY = 8'h1B;\nlocalparam LINES    = 'd4;\nlocalparam COLUMNS  = 'd4;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [LATENCY:0]    valid_ff;\nlogic [NBW_KEY-1:0]  key_ff;\nlogic [NBW_WORD-1:0] data_in_ff      [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes2_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes3_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes9_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesB_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesD_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesE_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_out_nx     [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes2_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes3_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes9_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesB_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesD_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesE_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_out_ff     [LINES][COLUMNS];\n\nlogic [NBW_WORD-1:0] data_xtimes2 [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes4 [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes8 [LINES][COLUMNS];\n\n// ----------------------------------------\n// - Control registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : ctrl_regs\n    if (!rst_async_n) begin\n        valid_ff <= 0;\n        key_ff   <= 0;\n    end else begin\n        valid_ff[0]         <= i_valid;\n        valid_ff[LATENCY:1] <= valid_ff[LATENCY-1:0];\n        if(i_update_key) begin\n            key_ff <= i_key;\n        end\n    end\nend\n\n// ----------------------------------------\n// - Data registers\n// ----------------------------------------\nalways_ff @(posedge clk) begin : data_regs\n    for (int line = 0; line < LINES; line++) begin\n        for (int column = 0; column < COLUMNS; column++) begin\n            if(i_valid) begin\n                if(i_encrypt) begin\n                    data_in_ff[line][column] <= i_data[NBW_DATA-1-(column*NBW_WORD + line*NBW_WORD*COLUMNS)-:NBW_WORD];\n                end else begin\n                    data_in_ff[line][column] <= i_data[NBW_DATA-1-(column*NBW_WORD + line*NBW_WORD*COLUMNS)-:NBW_WORD] ^ key_ff[NBW_KEY-line*NBW_WORD-1-:NBW_WORD];            \n                end\n            end\n\n            data_xtimes2_ff[line][column] <= data_xtimes2_nx[line][column];\n            data_xtimes3_ff[line][column] <= data_xtimes3_nx[line][column];\n            data_xtimes9_ff[line][column] <= data_xtimes9_nx[line][column];\n            data_xtimesB_ff[line][column] <= data_xtimesB_nx[line][column];\n            data_xtimesD_ff[line][column] <= data_xtimesD_nx[line][column];\n            data_xtimesE_ff[line][column] <= data_xtimesE_nx[line][column];\n\n            if(valid_ff[2]) begin\n                data_out_ff[line][column] <= data_out_nx[line][column];\n            end\n        end\n    end\nend\n\n// ----------------------------------------\n// - Intermediary steps\n// ----------------------------------------\n\n// Calculate GF(2^8) multiplication by 2, 4 and 8\nalways_comb begin : multiply_gf2_4_8\n    for (int line = 0; line < LINES; line++) begin\n        for (int column = 0; column < COLUMNS; column++) begin\n            data_xtimes2[line][column] = data_in_ff[line][column] << 1 ^ MOD_POLY;\n            data_xtimes4[line][column] = data_in_ff[line][column] << 2 ^ MOD_POLY;\n            data_xtimes8[line][column] = data_in_ff[line][column] << 4 ^ MOD_POLY;\n        end\n    end\nend\n\n// Calculate GF(2^8) multiplications by the values in the polynomial\nalways_comb begin : multiply_gf\n    for (int line = 0; line < LINES; line++) begin\n        for (int column = 0; column < COLUMNS; column++) begin\n            data_xtimes2_nx[line][column] = data_xtimes2[line][column];\n            if(i_encrypt) begin\n                data_xtimes3_nx[line][column] = data_xtimes2[line][column] ^ data_in_ff[line][column];\n                data_xtimes9_nx[line][column] = data_xtimes9_ff[line][column];\n                data_xtimesB_nx[line][column] = data_xtimesB_ff[line][column];\n                data_xtimesD_nx[line][column] = data_xtimesD_ff[line][column];\n                data_xtimesE_nx[line][column] = data_xtimesE_ff[line][column];\n            end else begin\n                data_xtimes3_nx[line][column] = data_xtimes3_ff[line][column];\n                data_xtimes9_nx[line][column] = data_xtimes8[line][column] ^ data_in_ff[line][column];\n                data_xtimesB_nx[line][column] = data_xtimes8[line][column] ^ data_xtimes2[line][column] ^ data_in_ff  [line][column];\n                data_xtimesD_nx[line][column] = data_xtimes8[line][column] ^ data_xtimes4[line][column] ^ data_in_ff  [line][column];\n                data_xtimesE_nx[line][column] = data_xtimes8[line][column] ^ data_xtimes4[line][column] ^ data_xtimes2[line][column] ^ data_in_ff[line][column];\n            end\n        end\n    end\nend\n\n// Calculate output matrix\nalways_comb begin : out_matrix\n    if(i_encrypt) begin\n        for (int column = 0; column < COLUMNS; column++) begin\n            data_out_nx[0][column] = data_xtimes2_ff[0][column] ^ data_xtimes3_ff[1][column] ^ data_in_ff[2][column] ^ data_in_ff[3][column];\n            data_out_nx[1][column] = data_xtimes2_ff[1][column] ^ data_xtimes3_ff[2][column] ^ data_in_ff[3][column] ^ data_in_ff[0][column];\n            data_out_nx[2][column] = data_xtimes2_ff[2][column] ^ data_xtimes3_ff[3][column] ^ data_in_ff[0][column] ^ data_in_ff[1][column];\n            data_out_nx[3][column] = data_xtimes2_ff[3][column] ^ data_xtimes3_ff[0][column] ^ data_in_ff[1][column] ^ data_in_ff[2][column];\n        end\n    end else begin\n        for (int column = 0; column < COLUMNS; column++) begin\n            data_out_nx[0][column] = data_xtimesE_ff[0][column] ^ data_xtimesB_ff[1][column] ^ data_xtimesD_ff[2][column] ^ data_xtimes9_ff[3][column];\n            data_out_nx[1][column] = data_xtimesE_ff[1][column] ^ data_xtimesB_ff[2][column] ^ data_xtimesD_ff[3][column] ^ data_xtimes9_ff[0][column];\n            data_out_nx[2][column] = data_xtimesE_ff[2][column] ^ data_xtimesB_ff[3][column] ^ data_xtimesD_ff[0][column] ^ data_xtimes9_ff[1][column];\n            data_out_nx[3][column] = data_xtimesE_ff[3][column] ^ data_xtimesB_ff[0][column] ^ data_xtimesD_ff[1][column] ^ data_xtimes9_ff[2][column];\n        end\n    end\nend\n\n// ----------------------------------------\n// - Assign outputs\n// ----------------------------------------\n\n// Map output values from lines x columns to a single dimension\nalways_comb begin : out_mapping\n    if(valid_ff[LATENCY]) begin\n        for (int line = 0; line < LINES; line++) begin\n            for (int column = 0; column < COLUMNS; column++) begin\n                if(i_encrypt) begin\n                    o_data[NBW_DATA-(column*NBW_WORD + line*NBW_WORD*COLUMNS)-1-:NBW_WORD] = data_out_ff[line][column] ^ key_ff[NBW_KEY-line*NBW_WORD-1-:NBW_WORD];\n                end else begin\n                    o_data[NBW_DATA-(column*NBW_WORD + line*NBW_WORD*COLUMNS)-1-:NBW_WORD] = data_out_ff[line][column];\n                end\n            end\n        end\n    end else begin\n        o_data = 0;\n    end\nend\n\nassign o_valid = valid_ff[LATENCY];\n\nendmodule : galois_encryption"}, "output": {"rtl/galois_encryption.sv": "/*\nGalois field (2^8) matrix-based encryption/decryption system using AES's polynomial to perform galois field operations\n*/\n\nmodule galois_encryption #(\n    parameter NBW_DATA = 'd128,\n    parameter NBW_KEY  = 'd32\n) (\n    input  logic                clk,\n    input  logic                rst_async_n,\n    input  logic                i_encrypt,\n    input  logic                i_valid,\n    input  logic [NBW_DATA-1:0] i_data,\n    input  logic                i_update_key,\n    input  logic [NBW_KEY-1:0]  i_key,\n    output logic                o_valid,\n    output logic [NBW_DATA-1:0] o_data\n);\n\n// ----------------------------------------\n// - Internal Parameters\n// ----------------------------------------\nlocalparam LATENCY  = 'd3;\nlocalparam NBW_WORD = 'd8;\nlocalparam MOD_POLY = 8'h1B;\nlocalparam LINES    = 'd4;\nlocalparam COLUMNS  = 'd4;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [LATENCY:0]    valid_ff;\nlogic [NBW_KEY-1:0]  key_ff;\nlogic [NBW_WORD-1:0] data_in_ff      [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes2_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes3_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes9_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesB_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesD_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesE_nx [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_out_nx     [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes2_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes3_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes9_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesB_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesD_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimesE_ff [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_out_ff     [LINES][COLUMNS];\n\nlogic [NBW_WORD-1:0] data_xtimes2 [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes4 [LINES][COLUMNS];\nlogic [NBW_WORD-1:0] data_xtimes8 [LINES][COLUMNS];\n\n// ----------------------------------------\n// - Control registers\n// ----------------------------------------\nalways_ff @(posedge clk or negedge rst_async_n) begin : ctrl_regs\n    if (!rst_async_n) begin\n        valid_ff <= 0;\n        key_ff   <= 0;\n    end else begin\n        valid_ff[0]         <= i_valid;\n        valid_ff[LATENCY:1] <= valid_ff[LATENCY-1:0];\n        if(i_update_key) begin\n            key_ff <= i_key;\n        end\n    end\nend\n\n// ----------------------------------------\n// - Data registers\n// ----------------------------------------\nalways_ff @(posedge clk) begin : data_regs\n    for (int line = 0; line < LINES; line++) begin\n        for (int column = 0; column < COLUMNS; column++) begin\n            if(i_valid) begin\n                if(i_encrypt) begin\n                    data_in_ff[line][column] <= i_data[NBW_DATA-1-(column*NBW_WORD + line*NBW_WORD*COLUMNS)-:NBW_WORD];\n                end else begin\n                    data_in_ff[line][column] <= i_data[NBW_DATA-1-(column*NBW_WORD + line*NBW_WORD*COLUMNS)-:NBW_WORD] ^ key_ff[NBW_KEY-line*NBW_WORD-1-:NBW_WORD];            \n                end\n            end\n\n            data_xtimes2_ff[line][column] <= data_xtimes2_nx[line][column];\n            data_xtimes3_ff[line][column] <= data_xtimes3_nx[line][column];\n            data_xtimes9_ff[line][column] <= data_xtimes9_nx[line][column];\n            data_xtimesB_ff[line][column] <= data_xtimesB_nx[line][column];\n            data_xtimesD_ff[line][column] <= data_xtimesD_nx[line][column];\n            data_xtimesE_ff[line][column] <= data_xtimesE_nx[line][column];\n\n            if(valid_ff[2]) begin\n                data_out_ff[line][column] <= data_out_nx[line][column];\n            end\n        end\n    end\nend\n\n// ----------------------------------------\n// - Intermediary steps\n// ----------------------------------------\n\n// Calculate GF(2^8) multiplication by 2, 4 and 8\nalways_comb begin : multiply_gf2_4_8\n    for (int line = 0; line < LINES; line++) begin\n        for (int column = 0; column < COLUMNS; column++) begin\n            data_xtimes2[line][column] = data_in_ff[line][column] << 1 ^ MOD_POLY;\n            data_xtimes4[line][column] = data_in_ff[line][column] << 2 ^ MOD_POLY;\n            data_xtimes8[line][column] = data_in_ff[line][column] << 4 ^ MOD_POLY;\n        end\n    end\nend\n\n// Calculate GF(2^8) multiplications by the values in the polynomial\nalways_comb begin : multiply_gf\n    for (int line = 0; line < LINES; line++) begin\n        for (int column = 0; column < COLUMNS; column++) begin\n            data_xtimes2_nx[line][column] = data_xtimes2[line][column];\n            if(i_encrypt) begin\n                data_xtimes3_nx[line][column] = data_xtimes2[line][column] ^ data_in_ff[line][column];\n                data_xtimes9_nx[line][column] = data_xtimes9_ff[line][column];\n                data_xtimesB_nx[line][column] = data_xtimesB_ff[line][column];\n                data_xtimesD_nx[line][column] = data_xtimesD_ff[line][column];\n                data_xtimesE_nx[line][column] = data_xtimesE_ff[line][column];\n            end else begin\n                data_xtimes3_nx[line][column] = data_xtimes3_ff[line][column];\n                data_xtimes9_nx[line][column] = data_xtimes8[line][column] ^ data_in_ff[line][column];\n                data_xtimesB_nx[line][column] = data_xtimes8[line][column] ^ data_xtimes2[line][column] ^ data_in_ff  [line][column];\n                data_xtimesD_nx[line][column] = data_xtimes8[line][column] ^ data_xtimes4[line][column] ^ data_in_ff  [line][column];\n                data_xtimesE_nx[line][column] = data_xtimes8[line][column] ^ data_xtimes4[line][column] ^ data_xtimes2[line][column] ^ data_in_ff[line][column];\n            end\n        end\n    end\nend\n\n// Calculate output matrix\nalways_comb begin : out_matrix\n    if(i_encrypt) begin\n        for (int column = 0; column < COLUMNS; column++) begin\n            data_out_nx[0][column] = data_xtimes2_ff[0][column] ^ data_xtimes3_ff[1][column] ^ data_in_ff[2][column] ^ data_in_ff[3][column];\n            data_out_nx[1][column] = data_xtimes2_ff[1][column] ^ data_xtimes3_ff[2][column] ^ data_in_ff[3][column] ^ data_in_ff[0][column];\n            data_out_nx[2][column] = data_xtimes2_ff[2][column] ^ data_xtimes3_ff[3][column] ^ data_in_ff[0][column] ^ data_in_ff[1][column];\n            data_out_nx[3][column] = data_xtimes2_ff[3][column] ^ data_xtimes3_ff[0][column] ^ data_in_ff[1][column] ^ data_in_ff[2][column];\n        end\n    end else begin\n        for (int column = 0; column < COLUMNS; column++) begin\n            data_out_nx[0][column] = data_xtimesE_ff[0][column] ^ data_xtimesB_ff[1][column] ^ data_xtimesD_ff[2][column] ^ data_xtimes9_ff[3][column];\n            data_out_nx[1][column] = data_xtimesE_ff[1][column] ^ data_xtimesB_ff[2][column] ^ data_xtimesD_ff[3][column] ^ data_xtimes9_ff[0][column];\n            data_out_nx[2][column] = data_xtimesE_ff[2][column] ^ data_xtimesB_ff[3][column] ^ data_xtimesD_ff[0][column] ^ data_xtimes9_ff[1][column];\n            data_out_nx[3][column] = data_xtimesE_ff[3][column] ^ data_xtimesB_ff[0][column] ^ data_xtimesD_ff[1][column] ^ data_xtimes9_ff[2][column];\n        end\n    end\nend\n\n// ----------------------------------------\n// - Assign outputs\n// ----------------------------------------\n\n// Map output values from lines x columns to a single dimension\nalways_comb begin : out_mapping\n    if(valid_ff[LATENCY]) begin\n        for (int line = 0; line < LINES; line++) begin\n            for (int column = 0; column < COLUMNS; column++) begin\n                if(i_encrypt) begin\n                    o_data[NBW_DATA-(column*NBW_WORD + line*NBW_WORD*COLUMNS)-1-:NBW_WORD] = data_out_ff[line][column] ^ key_ff[NBW_KEY-line*NBW_WORD-1-:NBW_WORD];\n                end else begin\n                    o_data[NBW_DATA-(column*NBW_WORD + line*NBW_WORD*COLUMNS)-1-:NBW_WORD] = data_out_ff[line][column];\n                end\n            end\n        end\n    end else begin\n        o_data = 0;\n    end\nend\n\nassign o_valid = valid_ff[LATENCY];\n\nendmodule : galois_encryption"}, "obj": true}}
{"cvdp_copilot_gaussian_rounding_div_0003": {"input": {}, "output": {"rtl/divider.sv": ""}, "obj": true}}
{"cvdp_copilot_gaussian_rounding_div_0005": {"input": {}, "output": {"rtl/divider.sv": ""}, "obj": true}}
{"cvdp_copilot_gaussian_rounding_div_0022": {"input": {"rtl/divider.sv": "//////////////////////////////////////////////\n// Top-Level Gold-Schmidt Division Module\n//////////////////////////////////////////////\nmodule divider (\n    input  logic         clk,\n    input  logic         rst_n,\n    input  logic         start,\n    input  logic [17:0]  dividend,  // unsigned\n    input  logic [17:0]  divisor,   // unsigned\n    output logic [17:0]  dv_out,\n    output logic         valid\n);\n\n    //////////////////////////////////////////////\n    // Local parameters\n    //////////////////////////////////////////////\n    localparam logic [17:0] TWO  = 18'b000000010_000000000;  // \"2.0\" in Q9.9\n    localparam logic [17:0] ZERO = 18'b000000000_000000000;  // \"0.0\" in Q9.9\n\n    //////////////////////////////////////////////\n    // Internal signals\n    //////////////////////////////////////////////\n    logic [17:0] D_0, N_0;\n    logic [17:0] D, D2, D4, D6, D8, D10, D12, D14, D16, D18, D20;\n    logic [17:0] N, N2, N4, N6, N8, N10, N12, N14, N16, N18, N20, N21;\n    logic [17:0] F, F1, F2, F3, F4, F5, F6, F7, F8, F9;\n    logic [47:0] D1, N1, D3, N3, D5, N5, D7, N7, D9, N9, D11, N11, D13, N13, D15, N15, D17, N17, D19, N19;\n\n    // Pipeline stage flags\n    logic st1, st2, st3, st4, st5, st6, st7, st8, st9, st10, st11, st12;\n\n    //////////////////////////////////////////////\n    // Pre-registers for dividend/divisor\n    //////////////////////////////////////////////\n    reg18 reg_dividend_pre(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(dividend),\n        .data_out(N_0)\n    );\n\n    reg18 reg_divisor_pre(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(divisor),\n        .data_out(D_0)\n    );\n\n    // Pipeline control for \"start\"\n    dff1 ff0(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (start),\n        .q     (st1)\n    );\n\n    //////////////////////////////////////////////\n    // Prescaling: only for magnitude < 1\n    //////////////////////////////////////////////\n    logic [17:0] prescaled_divisor, prescaled_dividend;\n    pre_scaler prescaler_inst(\n        .a(D_0),\n        .c(N_0),\n        .b(prescaled_divisor),\n        .d(prescaled_dividend)\n    );\n\n    //////////////////////////////////////////////\n    // Register the prescaled divisor & dividend\n    //////////////////////////////////////////////\n    reg18 reg_divisor_stage1(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(prescaled_divisor),\n        .data_out(D)\n    );\n\n    reg18 reg_dividend_stage1(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(prescaled_dividend),\n        .data_out(N)\n    );\n\n    dff1 ff1(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st1),\n        .q     (st2)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 1: Compute F = (2 - D), multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        // Because we're unsigned and D < 1.0, we do F = 2 - D\n        F = TWO - D;\n    end\n\n    assign D1 = F * D;\n    assign N1 = F * N;\n\n    reg18 reg_divisor_stage2(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D1[26:9]),     // Keep 18 bits\n        .data_out(D2)\n    );\n\n    reg18 reg_dividend_stage2(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N1[26:9]),\n        .data_out(N2)\n    );\n\n    dff1 ff2(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st2),\n        .q     (st3)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 2: F1 = 2 - D2, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F1 = TWO - D2;\n    end\n\n    assign D3 = F1 * D2;\n    assign N3 = F1 * N2;\n\n    reg18 reg_divisor_stage3(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D3[26:9]),\n        .data_out(D4)\n    );\n\n    reg18 reg_dividend_stage3(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N3[26:9]),\n        .data_out(N4)\n    );\n\n    dff1 ff3(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st3),\n        .q     (st4)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 3: F2 = 2 - D4, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F2 = TWO - D4;\n    end\n\n    assign D5 = F2 * D4;\n    assign N5 = F2 * N4;\n\n    reg18 reg_divisor_stage4(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D5[26:9]),\n        .data_out(D6)\n    );\n\n    reg18 reg_dividend_stage4(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N5[26:9]),\n        .data_out(N6)\n    );\n\n    dff1 ff4(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st4),\n        .q     (st5)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 4: F3 = 2 - D6, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F3 = TWO - D6;\n    end\n\n    assign D7 = F3 * D6;\n    assign N7 = F3 * N6;\n\n    reg18 reg_divisor_stage5(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D7[26:9]),\n        .data_out(D8)\n    );\n\n    reg18 reg_dividend_stage5(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N7[26:9]),\n        .data_out(N8)\n    );\n\n    dff1 ff6(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st5),\n        .q     (st6)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 5: F4 = 2 - D8, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F4 = TWO - D8;\n    end\n\n    assign D9 = F4 * D8;\n    assign N9 = F4 * N8;\n\n    reg18 reg_divisor_stage6(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D9[26:9]),\n        .data_out(D10)\n    );\n    reg18 reg_dividend_stage6(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N9[26:9]),\n        .data_out(N10)\n    );\n\n    dff1 ff8(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st6),\n        .q     (st7)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 6: F5 = 2 - D10, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F5 = TWO - D10;\n    end\n\n    assign D11 = F5 * D10;\n    assign N11 = F5 * N10;\n\n    reg18 reg_divisor_stage7(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D11[26:9]),\n        .data_out(D12)\n    );\n    reg18 reg_dividend_stage7(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N11[26:9]),\n        .data_out(N12)\n    );\n\n    dff1 ff9(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st7),\n        .q     (st8)\n    );\n\t\n\n    //////////////////////////////////////////////\n    // Stage 7: F6 = 2 - D12, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F6 = TWO - D12;\n    end\n\n    assign D13 = F6 * D12;\n    assign N13 = F6 * N12;\n\n    reg18 reg_divisor_stage8(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D13[26:9]),\n        .data_out(D14)\n    );\n    reg18 reg_dividend_stage8(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N13[26:9]),\n        .data_out(N14)\n    );\n\n    dff1 ff10(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st8),\n        .q     (st9)\n    );\n\n\n    //////////////////////////////////////////////\n    // Stage 8: F7 = 2 - D14, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F7 = TWO - D14;\n    end\n\n    assign D15 = F7 * D14;\n    assign N15 = F7 * N14;\n\n    reg18 reg_divisor_stage9(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D15[26:9]),\n        .data_out(D16)\n    );\n    reg18 reg_dividend_stage9(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N15[26:9]),\n        .data_out(N16)\n    );\n\n    dff1 ff11(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st9),\n        .q     (st10)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 9: F8 = 2 - D16, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F8 = TWO - D16;\n    end\n\n    assign D17 = F8 * D16;\n    assign N17 = F8 * N16;\n\n    reg18 reg_divisor_stage10(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D17[26:9]),\n        .data_out(D18)\n    );\n    reg18 reg_dividend_stage10(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N17[26:9]),\n        .data_out(N18)\n    );\n\n    dff1 ff12(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st10),\n        .q     (st11)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 10: F9 = 2 - D18, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F9 = TWO - D18;\n    end\n\n    assign D19 = F9 * D18;\n    assign N19 = F9 * N18;\n\n    reg18 reg_divisor_stage11(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D19[26:9]),\n        .data_out(D20)\n    );\n    reg18 reg_dividend_stage11(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N19[26:9]),\n        .data_out(N20)\n    );\n\n    dff1 ff13(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st11),\n        .q     (st12)\n    );\n\n    always_comb begin\n        N21 = N20;\n    end\n\n    // Final output register\n    reg18 reg_quotient_out(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N21),\n        .data_out(dv_out)\n    );\n\n    // Final pipeline control\n    dff1 ff14(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st12),\n        .q     (valid)\n    );\n\nendmodule\n\n////////////////////////////////////////////////\n// Pre-scaling (Prescaling) Module\n////////////////////////////////////////////////\nmodule pre_scaler (\n    input  logic [17:0] a,  // unsigned divisor\n    input  logic [17:0] c,  // unsigned dividend\n    output logic [17:0] b,  // prescaled divisor\n    output logic [17:0] d   // prescaled dividend\n);\n    // For simplicity, if 'a' is large, we shift until it is < 1.0 in Q9.9 format\n    // That means the integer bits of 'a' must be 0. We find how many leading bits\n    // we need to shift out.\n\n    always_comb begin : SHIFT_LOGIC\n        // 'a' has 18 bits in total, where the top 9 bits are integer, bottom 9 bits are fractional.\n        // We want the integer part of 'a' to be 0 => 'a[17:9]' should be zero after shifting.\n\n        if (a[17]) begin\n            b = a >> 8;\n            d = c >> 8;\n        end\n        else if (a[16]) begin\n            b = a >> 7;\n            d = c >> 7;\n        end\n        else if (a[15]) begin\n            b = a >> 6;\n            d = c >> 6;\n        end\n        else if (a[14]) begin\n            b = a >> 5;\n            d = c >> 5;\n        end\n        else if (a[13]) begin\n            b = a >> 4;\n            d = c >> 4;\n        end\n        else if (a[12]) begin\n            b = a >> 3;\n            d = c >> 3;\n        end\n        else if (a[11]) begin\n            b = a >> 2;\n            d = c >> 2;\n        end\n        else if (a[10]) begin\n            b = a >> 1;\n            d = c >> 1;\n        end\n        else begin\n            b = a;\n            d = c;\n        end\n    end\nendmodule\n\n////////////////////////////////////////////////\n// Single-bit DFF\n////////////////////////////////////////////////\nmodule dff1 (\n    input  logic clk,\n    input  logic reset,\n    input  logic d,\n    output logic q\n);\n    always_ff @(posedge clk) begin\n        if (reset) \n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule\n\n\n////////////////////////////////////////////////\n// 18-bit register (parallel load)\n////////////////////////////////////////////////\nmodule reg18 (\n    input  logic        clk,\n    input  logic        reset,\n    input  logic [17:0] data_in,\n    output logic [17:0] data_out\n);\n    always_ff @(posedge clk) begin\n        if (reset) \n            data_out <= 18'd0;\n        else\n            data_out <= data_in;\n    end\nendmodule"}, "output": {"rtl/divider.sv": "//////////////////////////////////////////////\n// Top-Level Gold-Schmidt Division Module\n//////////////////////////////////////////////\nmodule divider (\n    input  logic         clk,\n    input  logic         rst_n,\n    input  logic         start,\n    input  logic [17:0]  dividend,  // unsigned\n    input  logic [17:0]  divisor,   // unsigned\n    output logic [17:0]  dv_out,\n    output logic         valid\n);\n\n    //////////////////////////////////////////////\n    // Local parameters\n    //////////////////////////////////////////////\n    localparam logic [17:0] TWO  = 18'b000000010_000000000;  // \"2.0\" in Q9.9\n    localparam logic [17:0] ZERO = 18'b000000000_000000000;  // \"0.0\" in Q9.9\n\n    //////////////////////////////////////////////\n    // Internal signals\n    //////////////////////////////////////////////\n    logic [17:0] D_0, N_0;\n    logic [17:0] D, D2, D4, D6, D8, D10, D12, D14, D16, D18, D20;\n    logic [17:0] N, N2, N4, N6, N8, N10, N12, N14, N16, N18, N20, N21;\n    logic [17:0] F, F1, F2, F3, F4, F5, F6, F7, F8, F9;\n    logic [47:0] D1, N1, D3, N3, D5, N5, D7, N7, D9, N9, D11, N11, D13, N13, D15, N15, D17, N17, D19, N19;\n\n    // Pipeline stage flags\n    logic st1, st2, st3, st4, st5, st6, st7, st8, st9, st10, st11, st12;\n\n    //////////////////////////////////////////////\n    // Pre-registers for dividend/divisor\n    //////////////////////////////////////////////\n    reg18 reg_dividend_pre(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(dividend),\n        .data_out(N_0)\n    );\n\n    reg18 reg_divisor_pre(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(divisor),\n        .data_out(D_0)\n    );\n\n    // Pipeline control for \"start\"\n    dff1 ff0(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (start),\n        .q     (st1)\n    );\n\n    //////////////////////////////////////////////\n    // Prescaling: only for magnitude < 1\n    //////////////////////////////////////////////\n    logic [17:0] prescaled_divisor, prescaled_dividend;\n    pre_scaler prescaler_inst(\n        .a(D_0),\n        .c(N_0),\n        .b(prescaled_divisor),\n        .d(prescaled_dividend)\n    );\n\n    //////////////////////////////////////////////\n    // Register the prescaled divisor & dividend\n    //////////////////////////////////////////////\n    reg18 reg_divisor_stage1(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(prescaled_divisor),\n        .data_out(D)\n    );\n\n    reg18 reg_dividend_stage1(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(prescaled_dividend),\n        .data_out(N)\n    );\n\n    dff1 ff1(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st1),\n        .q     (st2)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 1: Compute F = (2 - D), multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        // Because we're unsigned and D < 1.0, we do F = 2 - D\n        F = TWO - D;\n    end\n\n    assign D1 = F * D;\n    assign N1 = F * N;\n\n    reg18 reg_divisor_stage2(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D1[26:9]),     // Keep 18 bits\n        .data_out(D2)\n    );\n\n    reg18 reg_dividend_stage2(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N1[26:9]),\n        .data_out(N2)\n    );\n\n    dff1 ff2(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st2),\n        .q     (st3)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 2: F1 = 2 - D2, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F1 = TWO - D2;\n    end\n\n    assign D3 = F1 * D2;\n    assign N3 = F1 * N2;\n\n    reg18 reg_divisor_stage3(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D3[26:9]),\n        .data_out(D4)\n    );\n\n    reg18 reg_dividend_stage3(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N3[26:9]),\n        .data_out(N4)\n    );\n\n    dff1 ff3(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st3),\n        .q     (st4)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 3: F2 = 2 - D4, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F2 = TWO - D4;\n    end\n\n    assign D5 = F2 * D4;\n    assign N5 = F2 * N4;\n\n    reg18 reg_divisor_stage4(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D5[26:9]),\n        .data_out(D6)\n    );\n\n    reg18 reg_dividend_stage4(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N5[26:9]),\n        .data_out(N6)\n    );\n\n    dff1 ff4(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st4),\n        .q     (st5)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 4: F3 = 2 - D6, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F3 = TWO - D6;\n    end\n\n    assign D7 = F3 * D6;\n    assign N7 = F3 * N6;\n\n    reg18 reg_divisor_stage5(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D7[26:9]),\n        .data_out(D8)\n    );\n\n    reg18 reg_dividend_stage5(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N7[26:9]),\n        .data_out(N8)\n    );\n\n    dff1 ff6(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st5),\n        .q     (st6)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 5: F4 = 2 - D8, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F4 = TWO - D8;\n    end\n\n    assign D9 = F4 * D8;\n    assign N9 = F4 * N8;\n\n    reg18 reg_divisor_stage6(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D9[26:9]),\n        .data_out(D10)\n    );\n    reg18 reg_dividend_stage6(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N9[26:9]),\n        .data_out(N10)\n    );\n\n    dff1 ff8(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st6),\n        .q     (st7)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 6: F5 = 2 - D10, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F5 = TWO - D10;\n    end\n\n    assign D11 = F5 * D10;\n    assign N11 = F5 * N10;\n\n    reg18 reg_divisor_stage7(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D11[26:9]),\n        .data_out(D12)\n    );\n    reg18 reg_dividend_stage7(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N11[26:9]),\n        .data_out(N12)\n    );\n\n    dff1 ff9(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st7),\n        .q     (st8)\n    );\n\t\n\n    //////////////////////////////////////////////\n    // Stage 7: F6 = 2 - D12, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F6 = TWO - D12;\n    end\n\n    assign D13 = F6 * D12;\n    assign N13 = F6 * N12;\n\n    reg18 reg_divisor_stage8(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D13[26:9]),\n        .data_out(D14)\n    );\n    reg18 reg_dividend_stage8(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N13[26:9]),\n        .data_out(N14)\n    );\n\n    dff1 ff10(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st8),\n        .q     (st9)\n    );\n\n\n    //////////////////////////////////////////////\n    // Stage 8: F7 = 2 - D14, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F7 = TWO - D14;\n    end\n\n    assign D15 = F7 * D14;\n    assign N15 = F7 * N14;\n\n    reg18 reg_divisor_stage9(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D15[26:9]),\n        .data_out(D16)\n    );\n    reg18 reg_dividend_stage9(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N15[26:9]),\n        .data_out(N16)\n    );\n\n    dff1 ff11(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st9),\n        .q     (st10)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 9: F8 = 2 - D16, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F8 = TWO - D16;\n    end\n\n    assign D17 = F8 * D16;\n    assign N17 = F8 * N16;\n\n    reg18 reg_divisor_stage10(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D17[26:9]),\n        .data_out(D18)\n    );\n    reg18 reg_dividend_stage10(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N17[26:9]),\n        .data_out(N18)\n    );\n\n    dff1 ff12(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st10),\n        .q     (st11)\n    );\n\n    //////////////////////////////////////////////\n    // Stage 10: F9 = 2 - D18, multiply, register\n    //////////////////////////////////////////////\n    always_comb begin\n        F9 = TWO - D18;\n    end\n\n    assign D19 = F9 * D18;\n    assign N19 = F9 * N18;\n\n    reg18 reg_divisor_stage11(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(D19[26:9]),\n        .data_out(D20)\n    );\n    reg18 reg_dividend_stage11(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N19[26:9]),\n        .data_out(N20)\n    );\n\n    dff1 ff13(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st11),\n        .q     (st12)\n    );\n\n    always_comb begin\n        N21 = N20;\n    end\n\n    // Final output register\n    reg18 reg_quotient_out(\n        .clk   (clk),\n        .reset (~rst_n),\n        .data_in(N21),\n        .data_out(dv_out)\n    );\n\n    // Final pipeline control\n    dff1 ff14(\n        .clk   (clk),\n        .reset (~rst_n),\n        .d     (st12),\n        .q     (valid)\n    );\n\nendmodule\n\n////////////////////////////////////////////////\n// Pre-scaling (Prescaling) Module\n////////////////////////////////////////////////\nmodule pre_scaler (\n    input  logic [17:0] a,  // unsigned divisor\n    input  logic [17:0] c,  // unsigned dividend\n    output logic [17:0] b,  // prescaled divisor\n    output logic [17:0] d   // prescaled dividend\n);\n    // For simplicity, if 'a' is large, we shift until it is < 1.0 in Q9.9 format\n    // That means the integer bits of 'a' must be 0. We find how many leading bits\n    // we need to shift out.\n\n    always_comb begin : SHIFT_LOGIC\n        // 'a' has 18 bits in total, where the top 9 bits are integer, bottom 9 bits are fractional.\n        // We want the integer part of 'a' to be 0 => 'a[17:9]' should be zero after shifting.\n\n        if (a[17]) begin\n            b = a >> 8;\n            d = c >> 8;\n        end\n        else if (a[16]) begin\n            b = a >> 7;\n            d = c >> 7;\n        end\n        else if (a[15]) begin\n            b = a >> 6;\n            d = c >> 6;\n        end\n        else if (a[14]) begin\n            b = a >> 5;\n            d = c >> 5;\n        end\n        else if (a[13]) begin\n            b = a >> 4;\n            d = c >> 4;\n        end\n        else if (a[12]) begin\n            b = a >> 3;\n            d = c >> 3;\n        end\n        else if (a[11]) begin\n            b = a >> 2;\n            d = c >> 2;\n        end\n        else if (a[10]) begin\n            b = a >> 1;\n            d = c >> 1;\n        end\n        else begin\n            b = a;\n            d = c;\n        end\n    end\nendmodule\n\n////////////////////////////////////////////////\n// Single-bit DFF\n////////////////////////////////////////////////\nmodule dff1 (\n    input  logic clk,\n    input  logic reset,\n    input  logic d,\n    output logic q\n);\n    always_ff @(posedge clk) begin\n        if (reset) \n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule\n\n\n////////////////////////////////////////////////\n// 18-bit register (parallel load)\n////////////////////////////////////////////////\nmodule reg18 (\n    input  logic        clk,\n    input  logic        reset,\n    input  logic [17:0] data_in,\n    output logic [17:0] data_out\n);\n    always_ff @(posedge clk) begin\n        if (reset) \n            data_out <= 18'd0;\n        else\n            data_out <= data_in;\n    end\nendmodule"}, "obj": true}}
{"cvdp_copilot_gaussian_rounding_div_0023": {"input": {"rtl/divider.sv": "`timescale 1ns/1ps\nmodule divider #\n(\n    parameter WIDTH = 32\n)\n(\n    input  wire                  clk,\n    input  wire                  rst_n,      // Active-low asynchronous reset\n    input  wire                  start,      // Start signal for new operation\n    input  wire [WIDTH-1 : 0]    dividend,   // Dividend (numerator)\n    input  wire [WIDTH-1 : 0]    divisor,    // Divisor (denominator)\n    output wire [WIDTH-1 : 0]    quotient,   // Result of the division\n    output wire [WIDTH-1 : 0]    remainder,  // Remainder after division\n    output wire                  valid       // Indicates output is valid\n);\n\n    // one extra bit for A\n    localparam AW = WIDTH + 1;\n    // Simple 3-state FSM\n    localparam IDLE = 2'b00;\n    localparam BUSY = 2'b01;\n    localparam DONE = 2'b10;\n\n    reg [1:0] state_reg, state_next;\n\n    // A+Q combined into one WIDTH + 1 + WIDTH register:\n    reg [AW+WIDTH-1 : 0] aq_reg,   aq_next;\n\n    // Divisor register\n    reg [AW-1 : 0]       m_reg,    m_next;\n\n    // Iterate exactly WIDTH times\n    reg [$clog2(WIDTH)-1:0] n_reg, n_next;\n\n    // Final outputs\n    reg [WIDTH-1:0] quotient_reg, quotient_next;\n    reg [WIDTH-1:0] remainder_reg, remainder_next;\n    reg valid_reg, valid_next;\n\n    // Assign the top-level outputs\n    assign quotient  = quotient_reg;\n    assign remainder = remainder_reg;\n    assign valid     = valid_reg;\n\n    //------------------------------------------------\n    // SEQUENTIAL: State & register updates\n    //------------------------------------------------\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state_reg     <= IDLE;\n            aq_reg        <= 0;\n            m_reg         <= 0;\n            n_reg         <= 0;\n            quotient_reg  <= 0;\n            remainder_reg <= 0;\n            valid_reg     <= 0;\n        end\n        else begin\n            state_reg     <= state_next;\n            aq_reg        <= aq_next;\n            m_reg         <= m_next;\n            n_reg         <= n_next;\n            quotient_reg  <= quotient_next;\n            remainder_reg <= remainder_next;\n            valid_reg     <= valid_next;\n        end\n    end\n\n    //------------------------------------------------\n    // COMBINATIONAL: Next-state logic\n    //------------------------------------------------\n    always @* begin\n        // Default \"hold\" behavior\n        state_next     = state_reg;\n        aq_next        = aq_reg;\n        m_next         = m_reg;\n        n_next         = n_reg;\n        quotient_next  = quotient_reg;\n        remainder_next = remainder_reg;\n        valid_next     = valid_reg;\n\n        case (state_reg)\n        //---------------------------------------------\n        // IDLE: Wait for start\n        //---------------------------------------------\n        IDLE: begin\n            // Outputs not valid yet\n            valid_next = 1'b0;\n\n            if (start) begin\n                // Step-1: Initialize\n                // A = 0 => upper AW bits all zero\n                // Q = dividend => lower WIDTH bits of aq\n                // so zero\u2010extend: { (AW)'b0, dividend }\n                aq_next = { {AW{1'b0}}, dividend };\n                // zero\u2010extend divisor into AW bits\n                m_next   = {1'b0, divisor};\n                n_next   = WIDTH;\n                // We do not set the final quotient/remainder yet\n                // Move to BUSY\n                state_next = BUSY;\n            end\n        end\n\n        //---------------------------------------------\n        // BUSY: Perform the N iterations\n        //---------------------------------------------\n        BUSY: begin\n            // 1) SHIFT LEFT\n            aq_next = aq_reg << 1;\n\n            // 2) If sign bit of old A == 1 => add M; else => subtract M.\n            if (aq_reg[AW+WIDTH-1] == 1'b1) begin\n                aq_next[AW+WIDTH-1 : WIDTH] = aq_next[AW+WIDTH-1 : WIDTH] + m_reg;\n            end\n            else begin\n                aq_next[AW+WIDTH-1 : WIDTH] = aq_next[AW+WIDTH-1 : WIDTH] - m_reg;\n            end\n\n            // 3) Check the new sign bit of A (after the add/sub).\n            //    If sign(A) = 1 => Q[0] = 0; else => Q[0] = 1.\n            if (aq_next[AW+WIDTH-1] == 1'b1) begin\n                aq_next[0] = 1'b0;\n            end\n            else begin\n                aq_next[0] = 1'b1;\n            end\n\n            // Decrement iteration count\n            n_next = n_reg - 1;\n\n            // Step-7: if n != 0 => repeat, else => next step\n            if (n_next == 0) begin\n                state_next = DONE;\n            end\n        end\n\n        //---------------------------------------------\n        // DONE: Final correction + output\n        //---------------------------------------------\n        DONE: begin\n            // Step-8: If sign bit of A == 1 => A = A + M\n            if (aq_reg[AW+WIDTH-1] == 1'b1) begin\n                aq_next = aq_reg;  // default\n                aq_next[AW+WIDTH-1 : WIDTH] = aq_reg[AW+WIDTH-1 : WIDTH] + m_reg;\n            end\n\n            // Step-9:\n            //   - The final quotient is the lower WIDTH bits of aq_reg\n            //   - The final remainder is the upper WIDTH bits of aq_reg\n            quotient_next  = aq_next[WIDTH-1 : 0];\n            remainder_next = aq_next[2*WIDTH-1 : WIDTH];\n\n            // Output becomes valid\n            valid_next = 1'b1;\n\n            // Return to IDLE when 'start' goes low\n            if (!start) begin\n                state_next = IDLE;\n            end else begin\n                state_next = DONE;\n            end\n        end\n\n        default: begin\n            state_next = IDLE;\n        end\n        endcase\n    end\n\nendmodule"}, "output": {"rtl/divider.sv": ""}, "obj": true}}
{"cvdp_copilot_gcd_0001": {"input": {}, "output": {"rtl/gcd_top.sv": ""}, "obj": true}}
{"cvdp_copilot_gcd_0009": {"input": {"rtl/gcd_top.sv": "module gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}, "output": {"rtl/gcd_top.sv": "module gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_gcd_0015": {"input": {"rtl/gcd_top.sv": "module gcd_3_ip #(\n   parameter WIDTH = 4\n   )(\n   input                     clk,\n   input                     rst,\n   input  [WIDTH-1:0]        A,\n   input  [WIDTH-1:0]        B,\n   input  [WIDTH-1:0]        C,\n   input                     go,\n   output logic  [WIDTH-1:0] OUT,\n   output logic              done\n);\n\nlogic [WIDTH-1:0] gcd_ab;\nlogic [WIDTH-1:0] gcd_bc;\nlogic             go_abc;\nlogic             done_ab;\nlogic             done_bc;\nlogic             done_ab_latched;\nlogic             done_bc_latched;\n\n// GCD is calculated for AB and BC in parallel. The GCD for two numbers is lower than the numbers themselves in most cases.\n// And calculating GCD for smaller numbers is comparatively faster using the implemented algorithm.\n// Hence in order to reduce GCD computation latency the calculation is broken up in this fashion.\n\ngcd_top\n#( .WIDTH(WIDTH)\n) gcd_A_B_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (A),\n   .B             (B),\n   .go            (go),\n   .OUT           (gcd_ab),\n   .done          (done_ab)\n);\n\ngcd_top\n#( .WIDTH(WIDTH)\n) gcd_B_C_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (B),\n   .B             (C),\n   .go            (go),\n   .OUT           (gcd_bc),\n   .done          (done_bc)\n);\n\ngcd_top\n#( .WIDTH(WIDTH)\n) gcd_ABC_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (gcd_ab),\n   .B             (gcd_bc),\n   .go            (go_abc),\n   .OUT           (OUT),\n   .done          (done)\n);\n\nalways_ff @ (posedge clk) begin\n   if (rst) begin\n      done_ab_latched    <= 0;\n      done_bc_latched    <= 0;\n   end else begin\n      if(done_ab) begin\n         done_ab_latched <= done_ab;\n      end else if (go_abc) begin\n         done_ab_latched <= 0;\n      end\n\n      if(done_bc) begin\n         done_bc_latched <= done_bc;\n      end else if (go_abc) begin\n         done_bc_latched <= 0;\n      end\n   end\nend\n\nassign go_abc = done_ab_latched & done_bc_latched;\n\nendmodule\n\nmodule gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}, "output": {"rtl/gcd_top.sv": "module gcd_3_ip #(\n   parameter WIDTH = 4\n   )(\n   input                     clk,\n   input                     rst,\n   input  [WIDTH-1:0]        A,\n   input  [WIDTH-1:0]        B,\n   input  [WIDTH-1:0]        C,\n   input                     go,\n   output logic  [WIDTH-1:0] OUT,\n   output logic              done\n);\n\nlogic [WIDTH-1:0] gcd_ab;\nlogic [WIDTH-1:0] gcd_bc;\nlogic             go_abc;\nlogic             done_ab;\nlogic             done_bc;\nlogic             done_ab_latched;\nlogic             done_bc_latched;\n\n// GCD is calculated for AB and BC in parallel. The GCD for two numbers is lower than the numbers themselves in most cases.\n// And calculating GCD for smaller numbers is comparatively faster using the implemented algorithm.\n// Hence in order to reduce GCD computation latency the calculation is broken up in this fashion.\n\ngcd_top\n#( .WIDTH(WIDTH)\n) gcd_A_B_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (A),\n   .B             (B),\n   .go            (go),\n   .OUT           (gcd_ab),\n   .done          (done_ab)\n);\n\ngcd_top\n#( .WIDTH(WIDTH)\n) gcd_B_C_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (B),\n   .B             (C),\n   .go            (go),\n   .OUT           (gcd_bc),\n   .done          (done_bc)\n);\n\ngcd_top\n#( .WIDTH(WIDTH)\n) gcd_ABC_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (gcd_ab),\n   .B             (gcd_bc),\n   .go            (go_abc),\n   .OUT           (OUT),\n   .done          (done)\n);\n\nalways_ff @ (posedge clk) begin\n   if (rst) begin\n      done_ab_latched    <= 0;\n      done_bc_latched    <= 0;\n   end else begin\n      if(done_ab) begin\n         done_ab_latched <= done_ab;\n      end else if (go_abc) begin\n         done_ab_latched <= 0;\n      end\n\n      if(done_bc) begin\n         done_bc_latched <= done_bc;\n      end else if (go_abc) begin\n         done_bc_latched <= 0;\n      end\n   end\nend\n\nassign go_abc = done_ab_latched & done_bc_latched;\n\nendmodule\n\nmodule gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_gcd_0023": {"input": {"rtl/gcd_top.sv": "module gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}, "output": {"rtl/gcd_top.sv": "module gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_gcd_0038": {"input": {"rtl/gcd_top.sv": "module gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}, "output": {"rtl/gcd_top.sv": "module gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [1:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_gcd_0040": {"input": {"rtl/gcd_top.sv": "module lcm_3_ip #(\n   parameter WIDTH = 4                    // Input bit-width\n   )(\n   input                         clk,\n   input                         rst,\n   input  [WIDTH-1:0]            A,\n   input  [WIDTH-1:0]            B,\n   input  [WIDTH-1:0]            C,\n   input                         go,\n   output logic  [3 * WIDTH-1:0] OUT,   // Updated output width\n   output logic                  done\n);\n\n   logic [2*WIDTH-1:0]      gcd_result;     // GCD result\n   logic [3*WIDTH-1:0]      product;        // Intermediate product\n   logic                    gcd_done;\n   logic                    product_ready;\n   logic [2*WIDTH-1:0]      A_int;\n   logic [2*WIDTH-1:0]      B_int;\n   logic [2*WIDTH-1:0]      C_int;\n\n   always_comb begin\n      A_int = A*B;\n      B_int = B*C;\n      C_int = C*A;\n   end\n\n   // Calculate GCD of A, B, and C\n   gcd_3_ip #(\n      .WIDTH(2*WIDTH)\n   ) gcd_inst (\n      .clk   (clk),\n      .rst   (rst),\n      .A     (A_int),\n      .B     (B_int),\n      .C     (C_int),\n      .go    (go),\n      .OUT   (gcd_result),\n      .done  (gcd_done)\n   );\n\n   // Sequential logic for LCM computation\n   always_ff @(posedge clk) begin\n      if (rst) begin\n         OUT <= 0;\n         done <= 0;\n         product_ready <= 0;\n      end else begin\n         if (gcd_done) begin\n            // Compute |A * B * C|\n            product <= A * B * C;\n            product_ready <= 1;\n         end\n\n         if (product_ready) begin\n            // Compute LCM = |A * B * C| / GCD\n            OUT <= product / gcd_result;\n            done <= 1;\n            product_ready <= 0;\n         end else begin\n            done <= 0;\n         end\n      end\n   end\nendmodule\n\nmodule gcd_3_ip #(\n   parameter WIDTH = 4\n   )(\n   input                     clk,\n   input                     rst,\n   input  [WIDTH-1:0]        A,\n   input  [WIDTH-1:0]        B,\n   input  [WIDTH-1:0]        C,\n   output                    go,\n   output logic  [WIDTH-1:0] OUT,\n   output logic              done\n);\n\nlogic [WIDTH-1:0] gcd_ab;\nlogic [WIDTH-1:0] gcd_bc;\nlogic             go_abc;\nlogic             done_ab;\nlogic             done_bc;\nlogic             done_ab_latched;\nlogic             done_bc_latched;\n\n// GCD is calculated for AB and BC in parallel. The GCD for two numbers is lower than the numbers themselves in most cases.\n// And calculating GCD for smaller numbers is comparatively faster using the implemented algorithm.\n// Hence in order to reduce GCD computation latency the calculation is broken up in this fashion.\n\ngcd_top\n#( .WIDTH(WIDTH)\n) gcd_A_B_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (A),\n   .B             (B),\n   .go            (go),\n   .OUT           (gcd_ab),\n   .done          (done_ab)\n);\n\ngcd_top\n#( .WIDTH(WIDTH)\n) gcd_B_C_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (B),\n   .B             (C),\n   .go            (go),\n   .OUT           (gcd_bc),\n   .done          (done_bc)\n);\n\ngcd_top\n#( .WIDTH(WIDTH)\n) gcd_ABC_inst (\n   .clk           (clk),\n   .rst           (rst),\n   .A             (gcd_ab),\n   .B             (gcd_bc),\n   .go            (go_abc),\n   .OUT           (OUT),\n   .done          (done)\n);\n\nalways_ff @ (posedge clk) begin\n   if (rst) begin\n      done_ab_latched    <= 0;\n      done_bc_latched    <= 0;\n   end else begin\n      if(done_ab) begin\n         done_ab_latched <= done_ab;\n      end else if (go_abc) begin\n         done_ab_latched <= 0;\n      end\n\n      if(done_bc) begin\n         done_bc_latched <= done_bc;\n      end else if (go_abc) begin\n         done_bc_latched <= 0;\n      end\n   end\nend\n\nassign go_abc = done_ab_latched & done_bc_latched;\n\nendmodule\n\nmodule gcd_top #(\n   parameter WIDTH = 4              // Parameter to define the bit-width of the input and output data\n   )(\n   input                     clk,   // Clock signal\n   input                     rst,   // Active High Synchronous reset signal\n   input  [WIDTH-1:0]        A,     // Input operand A\n   input  [WIDTH-1:0]        B,     // Input operand B\n   input                     go,    // Start signal to begin GCD computation\n   output logic  [WIDTH-1:0] OUT,   // Output for the GCD result\n   output logic              done   // Signal to indicate completion of computation\n);\n\n   // Internal signals to communicate between control path and data path\n   logic equal;                     // Signal indicating A == B\n   logic greater_than;              // Signal indicating A > B\n   logic [3:0] controlpath_state;   // Current state of the control FSM\n\n   // Instantiate the control path module\n   gcd_controlpath gcd_controlpath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .go                (go),                // Connect go signal\n      .equal             (equal),             // Connect equal signal from datapath\n      .greater_than      (greater_than),      // Connect greater_than signal from datapath\n      .controlpath_state (controlpath_state), // Output current state to datapath\n      .done              (done)               // Output done signal\n   );\n\n   // Instantiate the data path module\n   gcd_datapath\n   #( .WIDTH(WIDTH)\n   ) gcd_datapath_inst (\n      .clk               (clk),               // Connect clock signal\n      .rst               (rst),               // Connect reset signal\n      .A                 (A),                 // Connect input A\n      .B                 (B),                 // Connect input B\n      .controlpath_state (controlpath_state), // Connect current state from control path\n      .equal             (equal),             // Output equal signal to control path\n      .greater_than      (greater_than),      // Output greater_than signal to control path\n      .OUT               (OUT)                // Output GCD result\n   );\nendmodule\n\n\n// Datapath module for GCD computation\nmodule gcd_datapath  #(\n   parameter WIDTH = 4                           // Bit-width of operands\n   )(\n   input                     clk,                // Clock signal\n   input                     rst,                // Active High Synchronous reset\n   input  [WIDTH-1:0]        A,                  // Input operand A\n   input  [WIDTH-1:0]        B,                  // Input operand B\n   input  [1:0]              controlpath_state,  // Current state from control path\n   output logic              equal,              // Signal indicating A_ff == B_ff\n   output logic              greater_than,       // Signal indicating A_ff > B_ff\n   output logic  [WIDTH-1:0] OUT                 // Output GCD result\n);\n\n   // Registers to hold intermediate values of A and B\n   logic [WIDTH-1:0] A_ff;\n   logic [WIDTH-1:0] B_ff;\n   logic [WIDTH-1:0] controlpath_state_ff;\n\n   // State encoding for control signals\n   localparam S0 = 2'd0;    // State 0: Initialization state\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff, subtract B_ff from A_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff, subtract A_ff from B_ff\n\n   // Sequential logic to update registers based on controlpath_state\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         // On reset, initialize registers to zero\n         A_ff <= 'b0;\n         B_ff <= 'b0;\n         OUT  <= 'b0;\n      end else begin\n         case (controlpath_state)\n            S0: begin\n                // In state S0, load input values into registers\n                A_ff <= A;\n                B_ff <= B;\n             end\n            S1: begin\n                // In state S1, computation is done, output the result\n                OUT  <= A_ff;\n             end\n            S2: begin\n                // In state S2, A_ff > B_ff, subtract B_ff from A_ff\n                if (greater_than)\n                   A_ff <= A_ff - B_ff;\n             end\n            S3: begin\n                // In state S3, B_ff > A_ff, subtract A_ff from B_ff\n                if (!equal & !greater_than)\n                   B_ff <= B_ff - A_ff;\n             end\n            default: begin\n                A_ff <= 'b0;\n                B_ff <= 'b0;\n                OUT <= 'b0;\n            end\n         endcase\n      end\n   end\n\n   // Generating control response signals for the control path FSM\n   always_comb begin\n      case(controlpath_state)\n         S0: begin\n            // In state S0, compare initial input values A and B\n            equal        = (A == B)? 1'b1 : 1'b0;\n            greater_than = (A >  B)? 1'b1 : 1'b0;\n          end\n          default: begin\n            // In other states, compare the current values in registers A_ff and B_ff\n            equal        = (A_ff == B_ff)? 1'b1 : 1'b0;\n            greater_than = (A_ff >  B_ff)? 1'b1 : 1'b0;\n          end\n      endcase\n   end\nendmodule\n\n// Control path module for GCD computation FSM\nmodule gcd_controlpath (\n   input                    clk,               // Clock signal\n   input                    rst,               // Active High Synchronous reset\n   input                    go,                // Start GCD calculation signal\n   input                    equal,             // From Datapath: A_ff equals B_ff\n   input                    greater_than,      // From Datapath: A_ff is greater than B_ff\n   output logic [1:0]       controlpath_state, // Current state to Datapath\n   output logic             done               // Indicates completion of GCD calculation\n);\n\n   // Internal state registers\n   logic [1:0] curr_state;  // Current state of FSM\n   logic [1:0] next_state;  // Next state of FSM\n\n   // State encoding\n   localparam S0 = 2'd0;    // State 0: Initialization or waiting for 'go' signal\n   localparam S1 = 2'd1;    // State 1: Computation complete\n   localparam S2 = 2'd2;    // State 2: A_ff > B_ff\n   localparam S3 = 2'd3;    // State 3: B_ff > A_ff\n\n   // State latching logic: Update current state on clock edge\n   always_ff @ (posedge clk) begin\n      if (rst) begin\n         curr_state   <= S0;   // On reset, set state to S0\n      end else begin\n         curr_state   <= next_state;   // Transition to next state\n      end\n   end\n\n   // State transition logic: Determine next state based on current state and inputs\n   always_comb begin\n      case(curr_state)\n         S0: begin\n             // State S0: Waiting for 'go' signal\n             if(!go)\n                next_state = S0;         // Remain in S0 until 'go' is asserted\n             else if (equal)\n                next_state = S1;         // If A == B, computation is complete\n             else if (greater_than)\n                next_state = S2;         // If A > B, go to state S2\n             else\n                next_state = S3;         // If B > A, go to state S3\n         end\n         S1: begin\n             // State S1: Computation complete, output the result\n             next_state = S0;           // Return to S0 after completion\n         end\n         S2: begin\n             // State S2: A_ff > B_ff, subtract B_ff from A_ff\n             if(equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, stay in S2\n             else\n                next_state = S3;         // If B_ff > A_ff, go to S3\n         end\n         S3: begin\n             // State S3: B_ff > A_ff, subtract A_ff from B_ff\n             if (equal)\n                next_state = S1;         // If A_ff == B_ff after subtraction, go to S1\n             else if (greater_than)\n                next_state = S2;         // If A_ff > B_ff, go to S2\n             else\n                next_state = S3;         // If B_ff > A_ff, stay in S3\n         end\n         default: begin\n             next_state = S0;\n         end\n      endcase\n   end\n\n   // Output logic: Generate 'done' signal when computation is complete\n   always_ff @ (posedge clk) begin\n     if(rst) begin\n        done <= 1'b0;             // On reset, 'done' is low\n     end else begin\n        done <= (curr_state == S1); // 'done' is asserted when in state S1\n     end\n   end\n\n   // Assign current state to output for datapath\n   assign controlpath_state = curr_state;\n\nendmodule"}, "output": {"rtl/gcd_top.sv": ""}, "obj": true}}
{"cvdp_copilot_gcd_0045": {"input": {"rtl/gcd_top.sv": "module gcd_top #(\n   parameter WIDTH = 4\n)(\n   input                     clk,\n   input                     rst,\n   input  [WIDTH-1:0]        A,\n   input  [WIDTH-1:0]        B,\n   input                     go,\n   output logic [WIDTH-1:0]  OUT,\n   output logic              done\n);\n\n   logic equal;\n   logic [1:0] controlpath_state;\n\n   gcd_controlpath ctrl_inst (\n      .clk               (clk),\n      .rst               (rst),\n      .go                (go),\n      .equal             (equal),\n      .controlpath_state (controlpath_state),\n      .done              (done)\n   );\n\n   gcd_datapath #( .WIDTH(WIDTH) ) dp_inst (\n      .clk               (clk),\n      .rst               (rst),\n      .A                 (A),\n      .B                 (B),\n      .controlpath_state (controlpath_state),\n      .equal             (equal),\n      .OUT               (OUT)\n   );\n\nendmodule\n\n// Datapath for Stein's Algorithm\nmodule gcd_datapath  #(\n   parameter WIDTH = 4\n)(\n   input                     clk,\n   input                     rst,\n   input      [WIDTH-1:0]    A,\n   input      [WIDTH-1:0]    B,\n   input      [1:0]          controlpath_state,\n   output logic              equal,\n   output logic [WIDTH-1:0]  OUT\n);\n   // Internal registers\n   logic [WIDTH-1:0] A_ff, B_ff, OUT_ff;\n   logic [$clog2(WIDTH+1):0] k_ff;\n\n   // Next-state signals\n   logic [WIDTH-1:0] next_A_ff, next_B_ff, next_OUT;\n   logic [$clog2(WIDTH+1):0] next_k_ff;\n\n   logic [WIDTH-1:0] diff;\n   logic [WIDTH-1:0] gcd_val;\n   logic both_even, a_even, b_even;\n\n   // State encoding\n   localparam S0 = 2'd0; // Idle/Load\n   localparam S1 = 2'd1; // Compute done\n   localparam S2 = 2'd2; // Processing (Stein steps)\n\n   // Combinational logic for next states and outputs\n   always_comb begin\n      // Default next values\n      next_A_ff = A_ff;\n      next_B_ff = B_ff;\n      next_k_ff = k_ff;\n      next_OUT  = OUT_ff;\n      gcd_val   = OUT_ff; // Default to current OUT value\n      diff      = 'b0;\n\n      // Determine intermediate flags\n      a_even    = (A_ff[0] == 1'b0);\n      b_even    = (B_ff[0] == 1'b0);\n      both_even = a_even && b_even;\n      equal     = (A_ff == B_ff);\n\n      case (controlpath_state)\n         S0: begin\n            // Load inputs at S0\n            next_A_ff = A;\n            next_B_ff = B;\n            next_k_ff = 'b0;\n            next_OUT  = 'b0; \n         end\n\n         S1: begin\n            // Done state: finalize the GCD\n            // If A_ff == B_ff: gcd = A_ff << k_ff\n            // If both zero => gcd=0\n            // If one zero => gcd = nonzero << k_ff\n            if (A_ff == 0 && B_ff == 0) begin\n               gcd_val = 0;\n            end else if (A_ff == 0) begin\n               gcd_val = (B_ff << k_ff);\n            end else begin\n               // A_ff == B_ff\n               gcd_val = (A_ff << k_ff);\n            end\n            next_OUT = gcd_val;\n         end\n\n         S2: begin\n            // One step of Stein's algorithm\n            // If not done, apply rules:\n            // Both even: A=A/2, B=B/2, k++\n            // A even, B odd: A=A/2\n            // B even, A odd: B=B/2\n            // Both odd: larger = (larger - smaller)/2\n\n            if ((A_ff != 0) && (B_ff != 0)) begin\n               // Both nonzero\n               if (both_even) begin\n                  next_A_ff = A_ff >> 1;\n                  next_B_ff = B_ff >> 1;\n                  next_k_ff = k_ff + 1;\n               end else if (a_even && !b_even) begin\n                  next_A_ff = A_ff >> 1;\n               end else if (b_even && !a_even) begin\n                  next_B_ff = B_ff >> 1;\n               end else begin\n                  // both odd\n                  if (A_ff >= B_ff) begin\n                     diff = A_ff - B_ff;\n                     next_A_ff = diff >> 1;\n                     next_B_ff = B_ff;\n                  end else begin\n                     diff = B_ff - A_ff;\n                     next_B_ff = diff >> 1;\n                     next_A_ff = A_ff;\n                  end\n               end\n            end else if (A_ff == 0 && B_ff != 0) begin\n               // If one is zero and the other is nonzero, make them equal to move to done next cycle\n               next_A_ff = B_ff;\n               next_B_ff = B_ff;\n            end else if (B_ff == 0 && A_ff != 0) begin\n               next_B_ff = A_ff;\n               next_A_ff = A_ff;\n            end\n            // If both are zero, they are already equal, will move to done soon.\n         end\n\n         default: begin\n            // Default reset values\n            next_A_ff = 'b0;\n            next_B_ff = 'b0;\n            next_k_ff = 'b0;\n            next_OUT  = 'b0;\n         end\n      endcase\n   end\n\n   // Sequential updates\n   always_ff @(posedge clk) begin\n      if (rst) begin\n         A_ff  <= 'b0;\n         B_ff  <= 'b0;\n         k_ff  <= 'b0;\n         OUT_ff <= 'b0;\n      end else begin\n         A_ff  <= next_A_ff;\n         B_ff  <= next_B_ff;\n         k_ff  <= next_k_ff;\n         OUT_ff <= next_OUT;\n      end\n   end\n\n   // OUT is driven from register\n   assign OUT = OUT_ff;\n\nendmodule\n\n\n// Control Path for Stein's Algorithm GCD\nmodule gcd_controlpath (\n   input                    clk,\n   input                    rst,\n   input                    go,\n   input                    equal,\n   output logic [1:0]       controlpath_state,\n   output logic             done\n);\n   localparam S0 = 2'd0;\n   localparam S1 = 2'd1;\n   localparam S2 = 2'd2;\n\n   logic [1:0] curr_state, next_state;\n\n   // Combinational next state logic\n   always_comb begin\n      next_state = curr_state;\n      case (curr_state)\n         S0: begin\n            if (!go) \n               next_state = S0;\n            else \n               // After loading, we go to processing step\n               next_state = S2;\n         end\n         S1: begin\n            // Done state, return to idle\n            next_state = S0;\n         end\n         S2: begin\n            // While processing, if equal => done\n            if (equal) \n               next_state = S1;\n            else\n               next_state = S2; // continue processing\n         end\n         default: begin\n            next_state = S0;\n         end\n      endcase\n   end\n\n   // Sequential state update\n   always_ff @(posedge clk) begin\n      if (rst)\n         curr_state <= S0;\n      else\n         curr_state <= next_state;\n   end\n\n   // Done signal\n   always_ff @(posedge clk) begin\n      if (rst)\n         done <= 1'b0;\n      else\n         done <= (curr_state == S1);\n   end\n\n   assign controlpath_state = curr_state;\n\nendmodule"}, "output": {"rtl/gcd_top.sv": "module gcd_top #(\n   parameter WIDTH = 4\n)(\n   input                     clk,\n   input                     rst,\n   input  [WIDTH-1:0]        A,\n   input  [WIDTH-1:0]        B,\n   input                     go,\n   output logic [WIDTH-1:0]  OUT,\n   output logic              done\n);\n\n   logic equal;\n   logic [1:0] controlpath_state;\n\n   gcd_controlpath ctrl_inst (\n      .clk               (clk),\n      .rst               (rst),\n      .go                (go),\n      .equal             (equal),\n      .controlpath_state (controlpath_state),\n      .done              (done)\n   );\n\n   gcd_datapath #( .WIDTH(WIDTH) ) dp_inst (\n      .clk               (clk),\n      .rst               (rst),\n      .A                 (A),\n      .B                 (B),\n      .controlpath_state (controlpath_state),\n      .equal             (equal),\n      .OUT               (OUT)\n   );\n\nendmodule\n\n// Datapath for Stein's Algorithm\nmodule gcd_datapath  #(\n   parameter WIDTH = 4\n)(\n   input                     clk,\n   input                     rst,\n   input      [WIDTH-1:0]    A,\n   input      [WIDTH-1:0]    B,\n   input      [1:0]          controlpath_state,\n   output logic              equal,\n   output logic [WIDTH-1:0]  OUT\n);\n   // Internal registers\n   logic [WIDTH-1:0] A_ff, B_ff, OUT_ff;\n   logic [$clog2(WIDTH+1):0] k_ff;\n\n   // Next-state signals\n   logic [WIDTH-1:0] next_A_ff, next_B_ff, next_OUT;\n   logic [$clog2(WIDTH+1):0] next_k_ff;\n\n   logic [WIDTH-1:0] diff;\n   logic [WIDTH-1:0] gcd_val;\n   logic both_even, a_even, b_even;\n\n   // State encoding\n   localparam S0 = 2'd0; // Idle/Load\n   localparam S1 = 2'd1; // Compute done\n   localparam S2 = 2'd2; // Processing (Stein steps)\n\n   // Combinational logic for next states and outputs\n   always_comb begin\n      // Default next values\n      next_A_ff = A_ff;\n      next_B_ff = B_ff;\n      next_k_ff = k_ff;\n      next_OUT  = OUT_ff;\n      gcd_val   = OUT_ff; // Default to current OUT value\n      diff      = 'b0;\n\n      // Determine intermediate flags\n      a_even    = (A_ff[0] == 1'b0);\n      b_even    = (B_ff[0] == 1'b0);\n      both_even = a_even && b_even;\n      equal     = (A_ff == B_ff);\n\n      case (controlpath_state)\n         S0: begin\n            // Load inputs at S0\n            next_A_ff = A;\n            next_B_ff = B;\n            next_k_ff = 'b0;\n            next_OUT  = 'b0; \n         end\n\n         S1: begin\n            // Done state: finalize the GCD\n            // If A_ff == B_ff: gcd = A_ff << k_ff\n            // If both zero => gcd=0\n            // If one zero => gcd = nonzero << k_ff\n            if (A_ff == 0 && B_ff == 0) begin\n               gcd_val = 0;\n            end else if (A_ff == 0) begin\n               gcd_val = (B_ff << k_ff);\n            end else begin\n               // A_ff == B_ff\n               gcd_val = (A_ff << k_ff);\n            end\n            next_OUT = gcd_val;\n         end\n\n         S2: begin\n            // One step of Stein's algorithm\n            // If not done, apply rules:\n            // Both even: A=A/2, B=B/2, k++\n            // A even, B odd: A=A/2\n            // B even, A odd: B=B/2\n            // Both odd: larger = (larger - smaller)/2\n\n            if ((A_ff != 0) && (B_ff != 0)) begin\n               // Both nonzero\n               if (both_even) begin\n                  next_A_ff = A_ff >> 1;\n                  next_B_ff = B_ff >> 1;\n                  next_k_ff = k_ff + 1;\n               end else if (a_even && !b_even) begin\n                  next_A_ff = A_ff >> 1;\n               end else if (b_even && !a_even) begin\n                  next_B_ff = B_ff >> 1;\n               end else begin\n                  // both odd\n                  if (A_ff >= B_ff) begin\n                     diff = A_ff - B_ff;\n                     next_A_ff = diff >> 1;\n                     next_B_ff = B_ff;\n                  end else begin\n                     diff = B_ff - A_ff;\n                     next_B_ff = diff >> 1;\n                     next_A_ff = A_ff;\n                  end\n               end\n            end else if (A_ff == 0 && B_ff != 0) begin\n               // If one is zero and the other is nonzero, make them equal to move to done next cycle\n               next_A_ff = B_ff;\n               next_B_ff = B_ff;\n            end else if (B_ff == 0 && A_ff != 0) begin\n               next_B_ff = A_ff;\n               next_A_ff = A_ff;\n            end\n            // If both are zero, they are already equal, will move to done soon.\n         end\n\n         default: begin\n            // Default reset values\n            next_A_ff = 'b0;\n            next_B_ff = 'b0;\n            next_k_ff = 'b0;\n            next_OUT  = 'b0;\n         end\n      endcase\n   end\n\n   // Sequential updates\n   always_ff @(posedge clk) begin\n      if (rst) begin\n         A_ff  <= 'b0;\n         B_ff  <= 'b0;\n         k_ff  <= 'b0;\n         OUT_ff <= 'b0;\n      end else begin\n         A_ff  <= next_A_ff;\n         B_ff  <= next_B_ff;\n         k_ff  <= next_k_ff;\n         OUT_ff <= next_OUT;\n      end\n   end\n\n   // OUT is driven from register\n   assign OUT = OUT_ff;\n\nendmodule\n\n\n// Control Path for Stein's Algorithm GCD\nmodule gcd_controlpath (\n   input                    clk,\n   input                    rst,\n   input                    go,\n   input                    equal,\n   output logic [1:0]       controlpath_state,\n   output logic             done\n);\n   localparam S0 = 2'd0;\n   localparam S1 = 2'd1;\n   localparam S2 = 2'd2;\n\n   logic [1:0] curr_state, next_state;\n\n   // Combinational next state logic\n   always_comb begin\n      next_state = curr_state;\n      case (curr_state)\n         S0: begin\n            if (!go) \n               next_state = S0;\n            else \n               // After loading, we go to processing step\n               next_state = S2;\n         end\n         S1: begin\n            // Done state, return to idle\n            next_state = S0;\n         end\n         S2: begin\n            // While processing, if equal => done\n            if (equal) \n               next_state = S1;\n            else\n               next_state = S2; // continue processing\n         end\n         default: begin\n            next_state = S0;\n         end\n      endcase\n   end\n\n   // Sequential state update\n   always_ff @(posedge clk) begin\n      if (rst)\n         curr_state <= S0;\n      else\n         curr_state <= next_state;\n   end\n\n   // Done signal\n   always_ff @(posedge clk) begin\n      if (rst)\n         done <= 1'b0;\n      else\n         done <= (curr_state == S1);\n   end\n\n   assign controlpath_state = curr_state;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_generic_nbit_counter_0036": {"input": {"rtl/generic_counter.sv": "module generic_counter #(parameter N = 8) (\n    input logic clk_in,          // Clock input\n    input logic rst_in,          // Active HIGH Reset input\n    input logic [2:0] mode_in,   // Mode input (3 bits)\n    input logic enable_in,       // Enable input\n    input logic [N-1:0] ref_modulo, // Reference modulo value for Modulo-256 counter\n    output logic [N-1:0] o_count   // Output count (N bits)\n);\n\n    parameter BINARY_UP = 3'b000;\n    parameter BINARY_DOWN = 3'b001;\n    parameter MODULO_256 = 3'b010;\n    parameter JOHNSON = 3'b011;\n    parameter GRAY = 3'b100;\n    parameter RING = 3'b101;\n\n    logic [N-1:0] count;\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            count <= {N{1'b0}};\n        end else begin\n            case (mode_in)\n                BINARY_UP: begin\n                    count <= count + 1;\n                end\n                BINARY_DOWN: begin\n                    count <= count - 1;\n                end\n                MODULO_256: begin\n                    if (count == ref_modulo) begin\n                        count <= {N{1'b0}};\n                    end else begin\n                        count <= count + 2;  \n                    end\n                end\n                JOHNSON: begin\n                    count <= {~count[0], count[N-1:1]};\n                end\n                GRAY: begin\n                    count <= count >> 1;  \n                end\n                RING: begin\n                    if (count == {N{1'b0}}) begin\n                        count <= {{(N-1){1'b0}}, 1'b1};  \n                    end else begin\n                        count <= {count[N-2:0], count[N-1]};  \n                    end\n                end\t\t\n                default: begin\n                    count <= {N{1'b0}};\n                end\n            endcase\n        end\n    end\n\n    assign o_count = count;\n\nendmodule\n"}, "output": {"rtl/generic_counter.sv": "module generic_counter #(parameter N = 8) (\n    input logic clk_in,          // Clock input\n    input logic rst_in,          // Active HIGH Reset input\n    input logic [2:0] mode_in,   // Mode input (3 bits)\n    input logic enable_in,       // Enable input\n    input logic [N-1:0] ref_modulo, // Reference modulo value for Modulo-256 counter\n    output logic [N-1:0] o_count   // Output count (N bits)\n);\n\n    parameter BINARY_UP = 3'b000;\n    parameter BINARY_DOWN = 3'b001;\n    parameter MODULO_256 = 3'b010;\n    parameter JOHNSON = 3'b011;\n    parameter GRAY = 3'b100;\n    parameter RING = 3'b101;\n\n    logic [N-1:0] count;\n\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            count <= {N{1'b0}};\n        end else begin\n            case (mode_in)\n                BINARY_UP: begin\n                    count <= count + 1;\n                end\n                BINARY_DOWN: begin\n                    count <= count - 1;\n                end\n                MODULO_256: begin\n                    if (count == ref_modulo) begin\n                        count <= {N{1'b0}};\n                    end else begin\n                        count <= count + 2;  \n                    end\n                end\n                JOHNSON: begin\n                    count <= {~count[0], count[N-1:1]};\n                end\n                GRAY: begin\n                    count <= count >> 1;  \n                end\n                RING: begin\n                    if (count == {N{1'b0}}) begin\n                        count <= {{(N-1){1'b0}}, 1'b1};  \n                    end else begin\n                        count <= {count[N-2:0], count[N-1]};  \n                    end\n                end\t\t\n                default: begin\n                    count <= {N{1'b0}};\n                end\n            endcase\n        end\n    end\n\n    assign o_count = count;\n\nendmodule\n"}, "obj": true}}
{"cvdp_copilot_generic_nbit_counter_0039": {"input": {"rtl/generic_counter.sv": "module generic_counter #(parameter N = 8) (\n    input  logic         clk_in,          // Clock input\n    input  logic         rst_in,          // Active HIGH Reset input (synchronous)\n    input  logic [2:0]   mode_in,         // Mode input (3 bits)\n    input  logic         enable_in,       // Enable input\n    input  logic [N-1:0] ref_modulo,      // Reference modulo value for Modulo-N counter\n    output logic [N-1:0] o_count          // Output count (N bits)\n);\n\n    parameter BINARY_UP   = 3'b000;\n    parameter BINARY_DOWN = 3'b001;\n    parameter MODULO_N    = 3'b010;\n    parameter JOHNSON     = 3'b011;\n    parameter GRAY        = 3'b100;\n    parameter RING        = 3'b101;\n\n    logic [N-1:0] count_mux;\n    logic [N-1:0] count_bin_up;\n    logic [N-1:0] count_bin_down;\n    logic [N-1:0] count_modulo;\n    logic [N-1:0] count_johnson;\n    logic [N-1:0] count_gray;\n    logic [N-1:0] count_ring;\n\n    // BINARY_UP count logic\n    always_ff @(posedge clk_in) begin\n        if (rst_in)\n            count_bin_up <= {N{1'b0}};\n        else if (enable_in)\n            count_bin_up <= count_bin_up + 1;\n        else\n            count_bin_up <= count_bin_up;\n    end\n\n    // BINARY_DOWN count logic\n    always_ff @(posedge clk_in) begin\n        if (rst_in)\n            count_bin_down <= {N{1'b0}};\n        else if (enable_in)\n            count_bin_down <= count_bin_down - 1;\n        else\n            count_bin_down <= count_bin_down;\n    end\n\n    // MODULO_N count logic\n    always_ff @(posedge clk_in) begin\n        if (rst_in)\n            count_modulo <= {N{1'b0}};\n        else if (enable_in) begin\n            if (count_modulo == ref_modulo)\n                count_modulo <= {N{1'b0}};\n            else\n                count_modulo <= count_modulo + 1;\n        end else\n            count_modulo <= count_modulo;\n    end\n\n    // JOHNSON count logic\n    always_ff @(posedge clk_in) begin\n        if (rst_in)\n            count_johnson <= {N{1'b0}};\n        else if (enable_in)\n            count_johnson <= {~count_johnson[0], count_johnson[N-1:1]};\n        else\n            count_johnson <= count_johnson;\n    end\n\n    // GRAY count logic (internal count)\n    always_ff @(posedge clk_in) begin\n        if (rst_in)\n            count_gray <= {N{1'b0}};\n        else if (enable_in)\n            count_gray <= count_gray + 1;\n        else\n            count_gray <= count_gray;\n    end\n\n    // RING count logic\n    always_ff @(posedge clk_in) begin\n        if (rst_in)\n            count_ring <= {N{1'b0}};\n        else if (enable_in) begin\n            if (count_ring == {N{1'b0}})\n                count_ring <= {{(N-1){1'b0}}, 1'b1};\n            else\n                count_ring <= {count_ring[N-2:0], count_ring[N-1]};\n        end else\n            count_ring <= count_ring;\n    end\n\n    // Multiplexer to select the count based on mode_in\n    always_comb begin\n        case (mode_in)\n            BINARY_UP:   count_mux = count_bin_up;\n            BINARY_DOWN: count_mux = count_bin_down;\n            MODULO_N:    count_mux = count_modulo;\n            JOHNSON:     count_mux = count_johnson;\n            GRAY:        count_mux = count_gray;\n            RING:        count_mux = count_ring;\n            default:     count_mux = {N{1'b0}};\n        endcase\n    end\n\n    assign o_count = (mode_in == GRAY) ? (count_mux ^ (count_mux >> 1)) : count_mux;\n\nendmodule"}, "output": {"rtl/generic_counter.sv": ""}, "obj": true}}
{"cvdp_copilot_gf_multiplier_0001": {"input": {}, "output": {"rtl/gf_multiplier.sv": ""}, "obj": true}}
{"cvdp_copilot_gf_multiplier_0005": {"input": {"rtl/gf_multiplier.sv": "module gf_multiplier (\n    input [3:0] A,     // Multiplicand\n    input [3:0] B,     // Multiplier\n    output reg [3:0] result // Result\n);\n    reg [3:0] temp_result;\n    reg [4:0] multiplicand;\n    reg [4:0] irreducible_poly = 5'b10011; // Irreducible polynomial x^4 + x + 1\n\n    integer i;\n\n    always @(*) begin\n        temp_result = 4'b0000; // Initialize result to zero\n        multiplicand = {1'b0, A}; // Initialize multiplicand, adding an extra bit to handle overflow\n\n        // Perform multiplication using shift-and-add algorithm\n        for (i = 0; i < 4; i = i + 1) begin\n            if (B[i]) begin\n                temp_result = temp_result ^ multiplicand[3:0]; // XOR the multiplicand with result\n            end\n            multiplicand = multiplicand << 1; // Shift the multiplicand left by 1\n            if (multiplicand[4]) begin\n                multiplicand = multiplicand ^ irreducible_poly; // Polynomial reduction if overflow occurs\n            end\n        end\n\n        result = temp_result; // Output the final result\n    end\nendmodule"}, "output": {"rtl/gf_multiplier.sv": ""}, "obj": true}}
{"cvdp_copilot_gf_multiplier_0013": {"input": {"rtl/gf_multiplier.sv": "module gf_multiplier (\n    input [7:0] A,     // 8-bit Multiplicand\n    input [7:0] B,     // 8-bit Multiplier\n    output reg [7:0] result // 8-bit Result\n);\n    reg [7:0] temp_result;\n    reg [8:0] multiplicand;\n    reg [8:0] irreducible_poly = 9'b100011011; // Irreducible polynomial x^8 + x^4 + x^3 + x + 1\n\n    integer i;\n\n    always @(*) begin\n        temp_result = 8'b00000000; // Initialize result to zero\n        multiplicand = {1'b0, A};  // Initialize multiplicand with an extra bit for overflow\n\n        // Perform multiplication using shift-and-add algorithm\n        for (i = 0; i < 8; i = i + 1) begin\n            if (B[i]) begin\n                temp_result = temp_result ^ multiplicand[7:0]; // XOR multiplicand with result\n            end\n            multiplicand = multiplicand << 1; // Shift multiplicand left by 1\n            if (multiplicand[8]) begin\n                multiplicand = multiplicand ^ irreducible_poly; // Polynomial reduction if overflow occurs\n            end\n        end\n\n        result = temp_result; // Output the final result\n    end\nendmodule"}, "output": {"rtl/gf_mac.sv": ""}, "obj": true}}
{"cvdp_copilot_gf_multiplier_0021": {"input": {"rtl/gf_mac.sv": "module gf_mac #(\n    parameter WIDTH = 32  // Input width, should be a multiple of 8\n)(\n    input [WIDTH-1:0] a,  // Multiplicand\n    input [WIDTH-1:0] b,  // Multiplier\n    output reg [7:0] result // 8-bit XORed result of all GF multiplications\n);\n\n    integer i;\n    reg [7:0] temp_result;\n    wire [7:0] partial_results [(WIDTH/8)-1:0];\n\n    // Generate GF multipliers for each 8-bit segment\n    genvar j;\n    generate\n        for (j = 0; j < WIDTH/8; j = j + 1) begin : segment_mult\n            gf_multiplier segment_mult (\n                .A(a[(j+1)*8-1:j*8]),\n                .B(b[(j+1)*8-1:j*8]),\n                .result(partial_results[j])\n            );\n        end\n    endgenerate\n\n    // XOR all segment results\n    always @(*) begin\n        temp_result = 8'b0;\n        for (i = 0; i < WIDTH/8; i = i + 1) begin\n            temp_result = temp_result ^ partial_results[i];\n        end\n        result = temp_result;\n    end\nendmodule\n\nmodule gf_multiplier (\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] result\n);\n    reg [7:0] temp_result;\n    reg [8:0] multiplicand;\n    reg [8:0] irreducible_poly = 9'b100011011; // x^8 + x^4 + x^3 + x + 1\n\n    integer i;\n\n    always @(*) begin\n        temp_result = 8'b00000000;\n        multiplicand = {1'b0, A};\n        for (i = 0; i < 8; i = i + 1) begin\n            if (B[i]) begin\n                temp_result = temp_result ^ multiplicand[7:0];\n            end\n            multiplicand = multiplicand << 1;\n            if (multiplicand[8]) begin\n                multiplicand = multiplicand ^ irreducible_poly;\n            end\n        end\n        result = temp_result;\n    end\nendmodule"}, "output": {"rtl/gf_mac.sv": ""}, "obj": true}}
{"cvdp_copilot_gmii_axis_0001": {"input": {}, "output": {"rtl/gmii_rx_to_axi_stream.sv": ""}, "obj": true}}
{"cvdp_copilot_gray_to_binary_0001": {"input": {}, "output": {"rtl/gray_to_binary.sv": ""}, "obj": true}}
{"cvdp_copilot_grayscale_image_0014": {"input": {"rtl/conv3x3.sv": "module conv3x3 (\n    input logic          clk,               // Clock signal\n    input logic          rst_n,             // Reset signal, active low\n    input logic  [7:0]   image_data0,       // Individual pixel data inputs (8-bit each)\n    input logic  [7:0]   image_data1,\n    input logic  [7:0]   image_data2,\n    input logic  [7:0]   image_data3,\n    input logic  [7:0]   image_data4,\n    input logic  [7:0]   image_data5,\n    input logic  [7:0]   image_data6,\n    input logic  [7:0]   image_data7,\n    input logic  [7:0]   image_data8,\n    input logic  [7:0]   kernel0,           // Individual kernel inputs (8-bit each)\n    input logic  [7:0]   kernel1,\n    input logic  [7:0]   kernel2,\n    input logic  [7:0]   kernel3,\n    input logic  [7:0]   kernel4,\n    input logic  [7:0]   kernel5,\n    input logic  [7:0]   kernel6,\n    input logic  [7:0]   kernel7,\n    input logic  [7:0]   kernel8,\n    output logic [15:0]  convolved_data     // 16-bit convolved output\n);\n\n    // Stage 1: Element-wise multiplication results\n    logic [15:0] mult_result0, mult_result1, mult_result2;\n    logic [15:0] mult_result3, mult_result4, mult_result5;\n    logic [15:0] mult_result6, mult_result7, mult_result8;\n\n    // Stage 2: Row-wise partial sums\n    logic [19:0] pipeline_sum_stage10, pipeline_sum_stage11, pipeline_sum_stage12;\n\n    // Stage 3: Final total sum\n    logic [19:0] sum_result;\n\n    // Stage 4: Normalized result\n    logic [15:0] normalized_result;\n\n    // Stage 1: Element-wise multiplications\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            mult_result0 <= 0; mult_result1 <= 0; mult_result2 <= 0;\n            mult_result3 <= 0; mult_result4 <= 0; mult_result5 <= 0;\n            mult_result6 <= 0; mult_result7 <= 0; mult_result8 <= 0;\n        end else begin\n            mult_result0 <= image_data0 * kernel0;\n            mult_result1 <= image_data1 * kernel1;\n            mult_result2 <= image_data2 * kernel2;\n            mult_result3 <= image_data3 * kernel3;\n            mult_result4 <= image_data4 * kernel4;\n            mult_result5 <= image_data5 * kernel5;\n            mult_result6 <= image_data6 * kernel6;\n            mult_result7 <= image_data7 * kernel7;\n            mult_result8 <= image_data8 * kernel8;\n        end\n    end\n\n    // Stage 2: Row-wise summation\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pipeline_sum_stage10 <= 0;\n            pipeline_sum_stage11 <= 0;\n            pipeline_sum_stage12 <= 0;\n        end else begin\n            pipeline_sum_stage10 <= mult_result0 + mult_result1 + mult_result2;\n            pipeline_sum_stage11 <= mult_result3 + mult_result4; \n            pipeline_sum_stage12 <= mult_result6 + mult_result7 + mult_result8;\n        end\n    end\n\n    // Stage 3: Total summation\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sum_result <= 0;\n        end else begin\n            sum_result <= pipeline_sum_stage10 + pipeline_sum_stage11 + pipeline_sum_stage12;\n        end\n    end\n\n    // Stage 4: Normalization\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            convolved_data <= 0;\n        end else begin\n            convolved_data <= sum_result / 8; // Normalization\n        end\n    end\n\nendmodule"}, "output": {"rtl/conv3x3.sv": ""}, "obj": true}}
{"cvdp_copilot_halfband_fir_0005": {"input": {"rtl/halfband_fir.sv": "package my_unused_pkg;\n  typedef logic dummy_t;\nendpackage\nmodule halfband_fir #(\n    parameter LGNTAPS = 7,\n    parameter IW      = 16,\n    parameter TW      = 12,\n    parameter OW      = IW + TW + LGNTAPS,\n    parameter [LGNTAPS:0] NTAPS        = 107,\n    parameter [0:0]       FIXED_TAPS   = 1'b0,\n    parameter           INITIAL_COEFFS = \"\",\n    parameter [0:0]       OPT_HILBERT  = 1'b0,\n    localparam LGNMEM  = LGNTAPS - 1,\n    localparam LGNCOEF = LGNMEM - 1,\n    localparam [LGNTAPS-1:0] HALFTAPS = NTAPS[LGNTAPS:1],\n    localparam [LGNTAPS-2:0] QTRTAPS  = HALFTAPS[LGNTAPS-1:1] + 1,\n    localparam DMEMSZ = (1 << LGNMEM),\n    localparam CMEMSZ = (1 << LGNCOEF),\n    localparam UNUSED_PARAM = 42  // Unused parameter to simulate a warning\n)(\n    input  wire i_clk,\n    input  wire i_reset,\n    input  wire i_tap_wr,\n    input  wire [(TW-1):0] i_tap,\n    input  wire i_ce,\n    input  wire [(IW-1):0] i_sample,\n    output reg  o_ce,\n    output reg  [(OW-1):0] o_result\n);\n\n    import my_unused_pkg::*;\n      wire unused_wire;\n\n    reg [3:0] messy_flag;\n    \n    reg [TW-1:0] coef_mem_messy [0:CMEMSZ-1];\n    \n\n    reg [IW-1:0] dmem1_messy [0:DMEMSZ-1];\n    reg [IW-1:0] dmem2_messy [0:DMEMSZ-1];\n    \n    reg [LGNMEM-1:0] write_idx, left_idx, right_idx;\n    reg [LGNCOEF-1:0] tap_idx;\n    reg signed [IW-1:0] sample_left, sample_right, mid_sample_messy;\n    reg signed [IW:0]   sum_data;\n    reg clk_en, data_en, sum_en;\n    reg signed [IW+TW-1:0] mult_result;\n    reg signed [OW-1:0]    acc_result;\n    \n    // Control wires:\n    wire last_tap_warn, last_data_warn;\n    wire [LGNTAPS-2:0] remaining_taps;\n    \n    task BAD_TaskName;\n      input [7:0] dummy_input;\n      dummy_input = dummy_input + 1;\n    endtask\n    \n    function automatic [3:0] DummyFunction;\n      input [3:0] in_val;\n      begin\n         DummyFunction = in_val + 1;\n      end\n    endfunction\n    \n    generate\n      if (FIXED_TAPS || (INITIAL_COEFFS != \"\")) begin : LOAD_COEFFS\n         initial begin\n             $readmemh(INITIAL_COEFFS, coef_mem_messy);\n         end\n      end else begin : DYNAMIC_COEFFS\n         reg [LGNCOEF-1:0] tap_wr_idx;\n         initial tap_wr_idx = 0;\n         always @(posedge i_clk)\n            if (i_reset)\n                tap_wr_idx <= 0;\n            else if (i_tap_wr)\n                tap_wr_idx <= tap_wr_idx + 1'b1;\n         always @(posedge i_clk)\n            if (i_tap_wr)\n                coef_mem_messy[tap_wr_idx] <= i_tap;\n      end\n    endgenerate\n\n\n    initial write_idx = 0;\n    always @(posedge i_clk) begin\n        if (i_ce)\n            write_idx = write_idx + 1;  \n    end\n\n    always @(posedge i_clk)\n      if (i_ce) begin\n         dmem1_messy[write_idx] <= i_sample;\n         dmem2_messy[write_idx] <= mid_sample_messy;\n      end\n\n    always @(posedge i_clk)\n    begin\n      if (i_reset)\n         mid_sample_messy <= 0;\n      else if (i_ce)\n         mid_sample_messy <= sample_left;\n    end\n\n    assign remaining_taps = QTRTAPS - tap_idx;\n    assign last_tap_warn = (remaining_taps <= 1);\n    assign last_data_warn = (QTRTAPS - tap_idx <= 2);\n\n\n    initial messy_flag = 4'b0;\n    always @(posedge i_clk) begin\n      if (i_reset)\n        messy_flag[0] <= 1'b0;\n      else if (i_ce)\n        messy_flag[0] <= 1'b1;\n      else if (messy_flag[0] && !last_tap_warn)\n        messy_flag[0] <= 1'b1;\n      else if (!clk_en)\n        messy_flag[0] <= 1'b0;\n    end\n\n    always @(posedge i_clk)\n      if (i_reset)\n         messy_flag[3:1] <= 3'b0;\n      else\n         messy_flag[3:1] <= { messy_flag[2:1], (clk_en || (messy_flag[0] && !last_tap_warn)) };\n\n   \n    initial begin\n      left_idx = 0;\n      right_idx = 0;\n    end\n\n    always @(posedge i_clk) begin\n      if (i_reset) begin\n        left_idx <= 0;\n        right_idx <= 0;\n      end else if (i_ce) begin\n        left_idx <= write_idx;\n        right_idx <= write_idx - (HALFTAPS[LGNMEM-1:0]) + 1;\n      end else if (clk_en || !last_data_warn) begin\n        left_idx <= left_idx - 2;\n        right_idx <= right_idx + 2;\n      end\n    end\n\n   \n    initial tap_idx = 0;\n    always @(posedge i_clk) begin\n      if (i_reset)\n         tap_idx <= 0;\n      else if (clk_en)\n         tap_idx <= 0;\n      else if (!last_tap_warn)\n         tap_idx <= tap_idx + 1;\n    end\n\n   \n    initial clk_en = 1'b0;\n    always @(posedge i_clk) begin\n      clk_en <= (i_ce && !i_reset);\n    end\n\n    \n    initial begin\n        sample_left  = 0;\n        sample_right = 0;\n    end\n\n    always @(posedge i_clk) begin\n      sample_left  <= dmem1_messy[left_idx];\n      sample_right <= dmem2_messy[right_idx];\n    end\n\n    // --- Data Enable Update ---\n    initial data_en = 1'b0;\n    always @(posedge i_clk)\n       data_en <= (clk_en && !i_reset);\n\n    // --- Coefficient Read and Data Sum Computation ---\n    reg [TW-1:0] current_coef;\n    initial current_coef = 0;\n    always @(posedge i_clk)\n       current_coef <= coef_mem_messy[tap_idx[LGNCOEF-1:0]];\n\n    initial sum_data = 0;\n    always @(posedge i_clk) begin\n      if (i_reset)\n         sum_data <= 0;\n      else if (OPT_HILBERT)\n         sum_data <= sample_left - sample_right;\n      else\n         sum_data <= sample_left + sample_right;\n    end\n\n    // --- Summation Enable ---\n    initial sum_en = 1'b0;\n    always @(posedge i_clk)\n       sum_en <= (data_en && !i_reset);\n\n    // --- Multiply Operation ---\n    initial mult_result = 0;\n    always @(posedge i_clk)\n       mult_result <= current_coef * sum_data;\n\n       wire [OW-1:0] mid_prod;\n    generate\n      if (OPT_HILBERT) begin : NO_MIDPOINT\n         assign mid_prod = 0;\n      end else begin : GEN_MIDPOINT\n         reg [OW-1:0] mid_prod_reg;\n         initial mid_prod_reg = 0;\n         always @(posedge i_clk) begin\n            if (i_reset)\n               mid_prod_reg <= 0;\n            else if (clk_en)\n               mid_prod_reg <= { {(OW-IW-TW+1){mid_sample_messy[IW-1]}}, \n                                  mid_sample_messy, {(TW-1){1'b0}} }\n                              - { {(OW-IW){mid_sample_messy[IW-1]}}, \n                                  mid_sample_messy };\n         end\n         assign mid_prod = mid_prod_reg;\n      end\n    endgenerate\n\n    // --- Accumulation ---\n    initial acc_result = 0;\n    always @(posedge i_clk) begin\n      if (i_reset)\n         acc_result <= 0;\n      else if (sum_en)\n         acc_result <= mid_prod;\n      else if (messy_flag[3])\n         acc_result <= acc_result + { {(OW-(IW+TW)){mult_result[IW+TW-1]}}, mult_result };\n    end\n\n    // --- Output Assignments ---\n    initial o_result = 0;\n    always @(posedge i_clk)\n       if (sum_en)\n          o_result <= acc_result;\n\n    // --- Output Clock Enable Update ---\n    initial o_ce = 1'b0;\n    always @(posedge i_clk)\n       o_ce <= (sum_en && !i_reset);\n\nendmodule"}, "output": {"rtl/halfband_fir.sv": "package my_unused_pkg;\n  typedef logic dummy_t;\nendpackage\nmodule halfband_fir #(\n    parameter LGNTAPS = 7,\n    parameter IW      = 16,\n    parameter TW      = 12,\n    parameter OW      = IW + TW + LGNTAPS,\n    parameter [LGNTAPS:0] NTAPS        = 107,\n    parameter [0:0]       FIXED_TAPS   = 1'b0,\n    parameter           INITIAL_COEFFS = \"\",\n    parameter [0:0]       OPT_HILBERT  = 1'b0,\n    localparam LGNMEM  = LGNTAPS - 1,\n    localparam LGNCOEF = LGNMEM - 1,\n    localparam [LGNTAPS-1:0] HALFTAPS = NTAPS[LGNTAPS:1],\n    localparam [LGNTAPS-2:0] QTRTAPS  = HALFTAPS[LGNTAPS-1:1] + 1,\n    localparam DMEMSZ = (1 << LGNMEM),\n    localparam CMEMSZ = (1 << LGNCOEF),\n    localparam UNUSED_PARAM = 42  // Unused parameter to simulate a warning\n)(\n    input  wire i_clk,\n    input  wire i_reset,\n    input  wire i_tap_wr,\n    input  wire [(TW-1):0] i_tap,\n    input  wire i_ce,\n    input  wire [(IW-1):0] i_sample,\n    output reg  o_ce,\n    output reg  [(OW-1):0] o_result\n);\n\n    import my_unused_pkg::*;\n      wire unused_wire;\n\n    reg [3:0] messy_flag;\n    \n    reg [TW-1:0] coef_mem_messy [0:CMEMSZ-1];\n    \n\n    reg [IW-1:0] dmem1_messy [0:DMEMSZ-1];\n    reg [IW-1:0] dmem2_messy [0:DMEMSZ-1];\n    \n    reg [LGNMEM-1:0] write_idx, left_idx, right_idx;\n    reg [LGNCOEF-1:0] tap_idx;\n    reg signed [IW-1:0] sample_left, sample_right, mid_sample_messy;\n    reg signed [IW:0]   sum_data;\n    reg clk_en, data_en, sum_en;\n    reg signed [IW+TW-1:0] mult_result;\n    reg signed [OW-1:0]    acc_result;\n    \n    // Control wires:\n    wire last_tap_warn, last_data_warn;\n    wire [LGNTAPS-2:0] remaining_taps;\n    \n    task BAD_TaskName;\n      input [7:0] dummy_input;\n      dummy_input = dummy_input + 1;\n    endtask\n    \n    function automatic [3:0] DummyFunction;\n      input [3:0] in_val;\n      begin\n         DummyFunction = in_val + 1;\n      end\n    endfunction\n    \n    generate\n      if (FIXED_TAPS || (INITIAL_COEFFS != \"\")) begin : LOAD_COEFFS\n         initial begin\n             $readmemh(INITIAL_COEFFS, coef_mem_messy);\n         end\n      end else begin : DYNAMIC_COEFFS\n         reg [LGNCOEF-1:0] tap_wr_idx;\n         initial tap_wr_idx = 0;\n         always @(posedge i_clk)\n            if (i_reset)\n                tap_wr_idx <= 0;\n            else if (i_tap_wr)\n                tap_wr_idx <= tap_wr_idx + 1'b1;\n         always @(posedge i_clk)\n            if (i_tap_wr)\n                coef_mem_messy[tap_wr_idx] <= i_tap;\n      end\n    endgenerate\n\n\n    initial write_idx = 0;\n    always @(posedge i_clk) begin\n        if (i_ce)\n            write_idx = write_idx + 1;  \n    end\n\n    always @(posedge i_clk)\n      if (i_ce) begin\n         dmem1_messy[write_idx] <= i_sample;\n         dmem2_messy[write_idx] <= mid_sample_messy;\n      end\n\n    always @(posedge i_clk)\n    begin\n      if (i_reset)\n         mid_sample_messy <= 0;\n      else if (i_ce)\n         mid_sample_messy <= sample_left;\n    end\n\n    assign remaining_taps = QTRTAPS - tap_idx;\n    assign last_tap_warn = (remaining_taps <= 1);\n    assign last_data_warn = (QTRTAPS - tap_idx <= 2);\n\n\n    initial messy_flag = 4'b0;\n    always @(posedge i_clk) begin\n      if (i_reset)\n        messy_flag[0] <= 1'b0;\n      else if (i_ce)\n        messy_flag[0] <= 1'b1;\n      else if (messy_flag[0] && !last_tap_warn)\n        messy_flag[0] <= 1'b1;\n      else if (!clk_en)\n        messy_flag[0] <= 1'b0;\n    end\n\n    always @(posedge i_clk)\n      if (i_reset)\n         messy_flag[3:1] <= 3'b0;\n      else\n         messy_flag[3:1] <= { messy_flag[2:1], (clk_en || (messy_flag[0] && !last_tap_warn)) };\n\n   \n    initial begin\n      left_idx = 0;\n      right_idx = 0;\n    end\n\n    always @(posedge i_clk) begin\n      if (i_reset) begin\n        left_idx <= 0;\n        right_idx <= 0;\n      end else if (i_ce) begin\n        left_idx <= write_idx;\n        right_idx <= write_idx - (HALFTAPS[LGNMEM-1:0]) + 1;\n      end else if (clk_en || !last_data_warn) begin\n        left_idx <= left_idx - 2;\n        right_idx <= right_idx + 2;\n      end\n    end\n\n   \n    initial tap_idx = 0;\n    always @(posedge i_clk) begin\n      if (i_reset)\n         tap_idx <= 0;\n      else if (clk_en)\n         tap_idx <= 0;\n      else if (!last_tap_warn)\n         tap_idx <= tap_idx + 1;\n    end\n\n   \n    initial clk_en = 1'b0;\n    always @(posedge i_clk) begin\n      clk_en <= (i_ce && !i_reset);\n    end\n\n    \n    initial begin\n        sample_left  = 0;\n        sample_right = 0;\n    end\n\n    always @(posedge i_clk) begin\n      sample_left  <= dmem1_messy[left_idx];\n      sample_right <= dmem2_messy[right_idx];\n    end\n\n    // --- Data Enable Update ---\n    initial data_en = 1'b0;\n    always @(posedge i_clk)\n       data_en <= (clk_en && !i_reset);\n\n    // --- Coefficient Read and Data Sum Computation ---\n    reg [TW-1:0] current_coef;\n    initial current_coef = 0;\n    always @(posedge i_clk)\n       current_coef <= coef_mem_messy[tap_idx[LGNCOEF-1:0]];\n\n    initial sum_data = 0;\n    always @(posedge i_clk) begin\n      if (i_reset)\n         sum_data <= 0;\n      else if (OPT_HILBERT)\n         sum_data <= sample_left - sample_right;\n      else\n         sum_data <= sample_left + sample_right;\n    end\n\n    // --- Summation Enable ---\n    initial sum_en = 1'b0;\n    always @(posedge i_clk)\n       sum_en <= (data_en && !i_reset);\n\n    // --- Multiply Operation ---\n    initial mult_result = 0;\n    always @(posedge i_clk)\n       mult_result <= current_coef * sum_data;\n\n       wire [OW-1:0] mid_prod;\n    generate\n      if (OPT_HILBERT) begin : NO_MIDPOINT\n         assign mid_prod = 0;\n      end else begin : GEN_MIDPOINT\n         reg [OW-1:0] mid_prod_reg;\n         initial mid_prod_reg = 0;\n         always @(posedge i_clk) begin\n            if (i_reset)\n               mid_prod_reg <= 0;\n            else if (clk_en)\n               mid_prod_reg <= { {(OW-IW-TW+1){mid_sample_messy[IW-1]}}, \n                                  mid_sample_messy, {(TW-1){1'b0}} }\n                              - { {(OW-IW){mid_sample_messy[IW-1]}}, \n                                  mid_sample_messy };\n         end\n         assign mid_prod = mid_prod_reg;\n      end\n    endgenerate\n\n    // --- Accumulation ---\n    initial acc_result = 0;\n    always @(posedge i_clk) begin\n      if (i_reset)\n         acc_result <= 0;\n      else if (sum_en)\n         acc_result <= mid_prod;\n      else if (messy_flag[3])\n         acc_result <= acc_result + { {(OW-(IW+TW)){mult_result[IW+TW-1]}}, mult_result };\n    end\n\n    // --- Output Assignments ---\n    initial o_result = 0;\n    always @(posedge i_clk)\n       if (sum_en)\n          o_result <= acc_result;\n\n    // --- Output Clock Enable Update ---\n    initial o_ce = 1'b0;\n    always @(posedge i_clk)\n       o_ce <= (sum_en && !i_reset);\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_hamming_code_tx_and_rx_0001": {"input": {}, "output": {"rtl/hamming_code_tx_for_4bit.sv": ""}, "obj": true}}
{"cvdp_copilot_hamming_code_tx_and_rx_0003": {"input": {}, "output": {"rtl/hamming_code_receiver.sv": ""}, "obj": true}}
{"cvdp_copilot_hamming_code_tx_and_rx_0009": {"input": {"rtl/hamming_tx.sv": "module hamming_code_tx_for_4bit( \n  input[3:0] data_in,\n  output[7:0] data_out\n);\n  assign data_out[0] = 1'b0;\n  assign data_out[1] = data_in[0] ^ data_in[1] ^ data_in[3]; // 2^0\n  assign data_out[2] = data_in[0] ^ data_in[2] ^ data_in[3]; // 2^1\n  assign data_out[3] = data_in[0];\n  assign data_out[4] = data_in[1] ^ data_in[2] ^ data_in[3]; // 2^2\n  assign data_out[5] = data_in[1];\n  assign data_out[6] = data_in[2];\n  assign data_out[7] = data_in[3];\nendmodule "}, "output": {"rtl/hamming_tx.sv": "module hamming_code_tx_for_4bit( \n  input[3:0] data_in,\n  output[7:0] data_out\n);\n  assign data_out[0] = 1'b0;\n  assign data_out[1] = data_in[0] ^ data_in[1] ^ data_in[3]; // 2^0\n  assign data_out[2] = data_in[0] ^ data_in[2] ^ data_in[3]; // 2^1\n  assign data_out[3] = data_in[0];\n  assign data_out[4] = data_in[1] ^ data_in[2] ^ data_in[3]; // 2^2\n  assign data_out[5] = data_in[1];\n  assign data_out[6] = data_in[2];\n  assign data_out[7] = data_in[3];\nendmodule "}, "obj": true}}
{"cvdp_copilot_hamming_code_tx_and_rx_0011": {"input": {"rtl/hamming_rx.sv": "module hamming_code_receiver (\n  input[7:0] data_in,\n  output [3:0] data_out\n);\n \n  wire c1,c2,c3,error;\n  reg[7:0] correct_data;\n \n \n  assign c3 =  data_in[1] ^ data_in[3] ^ data_in[5] ^ data_in[7];\n  assign c2 =  data_in[2] ^ data_in[3] ^ data_in[6] ^ data_in[7];\n  assign c1 =  data_in[4] ^ data_in[5] ^ data_in[6] ^ data_in[7];\n \n  assign error = ({c3,c2,c1}==3'b000) ? 1'b0 : 1'b1;\n \n  always@(*)\n  begin\n    correct_data = 0;\n    if(error)\n    begin\n      correct_data             = data_in;\n      correct_data[{c1,c2,c3}] = ~correct_data[{c1,c2,c3}];\n    end\n    else\n    begin\n      correct_data             = data_in;\n    end\n  end\n \n assign data_out = {correct_data[7],correct_data[6],correct_data[5],correct_data[3]};\n \nendmodule"}, "output": {"rtl/hamming_rx.sv": ""}, "obj": true}}
{"cvdp_copilot_hamming_code_tx_and_rx_0013": {"input": {}, "output": {"rtl/hamming_tx.sv": ""}, "obj": true}}
{"cvdp_copilot_hebbian_rule_0012": {"input": {"rtl/hebb_gates.sv": "module hebb_gates(\n   input  logic               clk,\n   input  logic               rst,\n   input  logic               start, // To start the FSM\n   input  logic  signed [3:0] a, // First Input\n   input  logic  signed [3:0] b, // Second Input\n   input  logic         [1:0] gate_select, // To provide the targets for a selected gate in order to train\n   output logic  signed [3:0] w1, // Weight 1 obtained by training\n   output logic  signed [3:0] w2, // Weight 2 obtained by training\n   output logic  signed [3:0] bias,// Bias obtained by training\n   output logic [3:0] present_state,// Present State of the Training FSM\n   output logic [3:0] next_state // Next_State of the Training FSM\n   \n);\n   logic signed [3:0] t1;\n   logic signed [3:0] t2;\n   logic signed [3:0] t3;\n   logic signed [3:0] t4;\n   \n   gate_target dut(\n       .gate_select(gate_select),\n       .o_1        (t1),\n       .o_2        (t2),\n       .o_3        (t3),\n       .o_4        (t4)\n   );\n   \n   localparam [3:0] S0 = 4'd0;\n   localparam [3:0] S1 = 4'd1;\n   localparam [3:0] S2 = 4'd2;\n   localparam [3:0] S3 = 4'd3;\n   localparam [3:0] S4 = 4'd4;\n   localparam [3:0] S5 = 4'd5;\n   localparam [3:0] S6 = 4'd6;\n   localparam [3:0] S7 = 4'd7;\n   localparam [3:0] S8 = 4'd8;\n   localparam [3:0] S9 = 4'd9;\n   localparam [3:0] S10 = 4'd10;\n   \n   logic [2:0] iteration;\n   logic signed [3:0] x1;\n   logic signed [3:0] x2;\n   logic signed [3:0] delta_w1;\n   logic signed [3:0] delta_w2;\n   logic signed [3:0] delta_b;\n   logic signed [3:0] w1_reg;\n   logic signed [3:0] w2_reg;\n   logic signed [3:0] bias_reg;\n   logic signed [1:0] target;\n   logic delta_en;\n   logic sum_en;\n   logic clr_en;\n   logic cap_en;\n  \n   always_comb begin\n     if(cap_en ) begin\n        x1 = a;\n        x2 = b;\n     end else begin\n        x1 = x1 + 4'h0;\n        x2 = x2 + 4'h0;\n     end\n   \n   end\n   \n   always_comb begin\n     \n     if(delta_en) begin\n       delta_w1 = x1 * target;\n       delta_w2 = x2 * target;\n       delta_b  = target;\n     end else begin\n       delta_w1 = delta_w1 + 4'h0;\n       delta_w2 = delta_w2 + 4'h0;\n       delta_b  = delta_b + 4'h0; \n   end\n   \n  end\n   \n  always_comb begin\n     \n     if(sum_en) begin\n       w1_reg = w1_reg + delta_w1;\n       w2_reg = w2_reg + delta_w2;\n       bias_reg = bias_reg + delta_b;\n     end else begin\n       w1_reg = w1_reg + 4'h0;\n       w2_reg = w2_reg + 4'h0;\n       bias_reg = bias_reg + 4'h0;\n   end\n  end\n   \n   always_comb begin\n     \n     if(clr_en) begin\n       w1_reg = 0;\n       w2_reg = 0;\n       bias_reg = 0;\n     end else begin\n       w1_reg = w1_reg + 4'h0;\n       w2_reg = w2_reg + 4'h0;\n       bias_reg = bias_reg + 4'h0; \n    end\n   end\n   \n   always_ff@(posedge clk or negedge rst) begin\n       if(!rst) begin\n          present_state <= S0;\n          iteration <= 0;\n        end else\n          present_state <= next_state;\n   end\n\n   always_comb begin\n        next_state = present_state;\n        \n     case(present_state)\n             S0  : begin \n                      if(start)\n                         next_state = S1;\n                      else\n                         next_state = S0;\n                   end\n             S1  : begin \n                         next_state = S2;\n                   end\n             S2  : begin \n                      if(iteration == 0)\n                        next_state = S3;\n                     else if(iteration == 1)\n                        next_state = S4;\n                     else if(iteration == 2)\n                        next_state = S5;\n                     else \n                        next_state = S6;\n                   end\n             S3  : begin \n                         next_state = S7;\n                         \n                   end\n             S4  : begin \n                         next_state = S7;\n                  end\n             S5  : begin \n                         next_state = S7;\n                  end\n             S6  : begin \n                         next_state = S7;\n                  end\n             S7  :begin\n                         next_state = S8;\n                  end\n             S8  : begin\n                         next_state = S9;\n                  end\n             S9  : begin\n                      if(iteration < 4)\n                         next_state = S1;\n                      else\n                         next_state = S10;\n                   end\n             S10 : begin\n                      next_state = S0;\n                   end\n             default : ;\n     endcase\n   end \n   \n   always_comb begin\n        \n      case(present_state)\n             S0 : begin\n                    clr_en = 1;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en   = 0;\n                    iteration = 0;\n                    target = target + 4'h0;\n                  end \n             S1 : begin\n                    clr_en = 0;\n                    cap_en = 1;\n                    delta_en = 0;\n                    sum_en = 0;  \n                    iteration = iteration + 0;  \n                    target = target + 4'h0;              \n                  end\n             S2 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0; \n                    iteration = iteration + 0;     \n                    target = target + 4'h0;              \n                  end\n             S3 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = t1;\n                  end\n             S4 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = t2;\n                  end     \n             \n             S5 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = t3;\n                  end  \n             S6 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = t4;\n                  end        \n             S7 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 1;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = target + 4'h0;\n                  end\n             S8 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 1;\n                    iteration = iteration + 1;\n                    target = target + 4'h0;\n                  end\n             S9 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = target + 4'h0;\n                  end  \n             S10 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = target + 4'h0;\n                  end\n             \n             \n             \n           default : begin\n                      clr_en = 0;\n                      cap_en = 0;\n                      delta_en = 0;\n                      sum_en = 0;\n                      iteration = 0;\n                      target = target + 4'h0;\n                     end\n       endcase\n   end\n   assign w1 = w1_reg;\n   assign w2 = w2_reg;\n   assign bias = bias_reg;\n   \nendmodule\n\nmodule gate_target(\n   input  logic        [1:0] gate_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always_comb begin\n     case(gate_select)\n          2'b00 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n          2'b01 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b10 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b11 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n        default : begin\n                    o_1 =  0; \n                    o_2 =  0; \n                    o_3 =  0; \n                    o_4 =  0; \n                  end\n        endcase\n   end\nendmodule"}, "output": {"rtl/hebb_gates.sv": "module hebb_gates(\n   input  logic               clk,\n   input  logic               rst,\n   input  logic               start, // To start the FSM\n   input  logic  signed [3:0] a, // First Input\n   input  logic  signed [3:0] b, // Second Input\n   input  logic         [1:0] gate_select, // To provide the targets for a selected gate in order to train\n   output logic  signed [3:0] w1, // Weight 1 obtained by training\n   output logic  signed [3:0] w2, // Weight 2 obtained by training\n   output logic  signed [3:0] bias,// Bias obtained by training\n   output logic [3:0] present_state,// Present State of the Training FSM\n   output logic [3:0] next_state // Next_State of the Training FSM\n   \n);\n   logic signed [3:0] t1;\n   logic signed [3:0] t2;\n   logic signed [3:0] t3;\n   logic signed [3:0] t4;\n   \n   gate_target dut(\n       .gate_select(gate_select),\n       .o_1        (t1),\n       .o_2        (t2),\n       .o_3        (t3),\n       .o_4        (t4)\n   );\n   \n   localparam [3:0] S0 = 4'd0;\n   localparam [3:0] S1 = 4'd1;\n   localparam [3:0] S2 = 4'd2;\n   localparam [3:0] S3 = 4'd3;\n   localparam [3:0] S4 = 4'd4;\n   localparam [3:0] S5 = 4'd5;\n   localparam [3:0] S6 = 4'd6;\n   localparam [3:0] S7 = 4'd7;\n   localparam [3:0] S8 = 4'd8;\n   localparam [3:0] S9 = 4'd9;\n   localparam [3:0] S10 = 4'd10;\n   \n   logic [2:0] iteration;\n   logic signed [3:0] x1;\n   logic signed [3:0] x2;\n   logic signed [3:0] delta_w1;\n   logic signed [3:0] delta_w2;\n   logic signed [3:0] delta_b;\n   logic signed [3:0] w1_reg;\n   logic signed [3:0] w2_reg;\n   logic signed [3:0] bias_reg;\n   logic signed [1:0] target;\n   logic delta_en;\n   logic sum_en;\n   logic clr_en;\n   logic cap_en;\n  \n   always_comb begin\n     if(cap_en ) begin\n        x1 = a;\n        x2 = b;\n     end else begin\n        x1 = x1 + 4'h0;\n        x2 = x2 + 4'h0;\n     end\n   \n   end\n   \n   always_comb begin\n     \n     if(delta_en) begin\n       delta_w1 = x1 * target;\n       delta_w2 = x2 * target;\n       delta_b  = target;\n     end else begin\n       delta_w1 = delta_w1 + 4'h0;\n       delta_w2 = delta_w2 + 4'h0;\n       delta_b  = delta_b + 4'h0; \n   end\n   \n  end\n   \n  always_comb begin\n     \n     if(sum_en) begin\n       w1_reg = w1_reg + delta_w1;\n       w2_reg = w2_reg + delta_w2;\n       bias_reg = bias_reg + delta_b;\n     end else begin\n       w1_reg = w1_reg + 4'h0;\n       w2_reg = w2_reg + 4'h0;\n       bias_reg = bias_reg + 4'h0;\n   end\n  end\n   \n   always_comb begin\n     \n     if(clr_en) begin\n       w1_reg = 0;\n       w2_reg = 0;\n       bias_reg = 0;\n     end else begin\n       w1_reg = w1_reg + 4'h0;\n       w2_reg = w2_reg + 4'h0;\n       bias_reg = bias_reg + 4'h0; \n    end\n   end\n   \n   always_ff@(posedge clk or negedge rst) begin\n       if(!rst) begin\n          present_state <= S0;\n          iteration <= 0;\n        end else\n          present_state <= next_state;\n   end\n\n   always_comb begin\n        next_state = present_state;\n        \n     case(present_state)\n             S0  : begin \n                      if(start)\n                         next_state = S1;\n                      else\n                         next_state = S0;\n                   end\n             S1  : begin \n                         next_state = S2;\n                   end\n             S2  : begin \n                      if(iteration == 0)\n                        next_state = S3;\n                     else if(iteration == 1)\n                        next_state = S4;\n                     else if(iteration == 2)\n                        next_state = S5;\n                     else \n                        next_state = S6;\n                   end\n             S3  : begin \n                         next_state = S7;\n                         \n                   end\n             S4  : begin \n                         next_state = S7;\n                  end\n             S5  : begin \n                         next_state = S7;\n                  end\n             S6  : begin \n                         next_state = S7;\n                  end\n             S7  :begin\n                         next_state = S8;\n                  end\n             S8  : begin\n                         next_state = S9;\n                  end\n             S9  : begin\n                      if(iteration < 4)\n                         next_state = S1;\n                      else\n                         next_state = S10;\n                   end\n             S10 : begin\n                      next_state = S0;\n                   end\n             default : ;\n     endcase\n   end \n   \n   always_comb begin\n        \n      case(present_state)\n             S0 : begin\n                    clr_en = 1;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en   = 0;\n                    iteration = 0;\n                    target = target + 4'h0;\n                  end \n             S1 : begin\n                    clr_en = 0;\n                    cap_en = 1;\n                    delta_en = 0;\n                    sum_en = 0;  \n                    iteration = iteration + 0;  \n                    target = target + 4'h0;              \n                  end\n             S2 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0; \n                    iteration = iteration + 0;     \n                    target = target + 4'h0;              \n                  end\n             S3 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = t1;\n                  end\n             S4 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = t2;\n                  end     \n             \n             S5 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = t3;\n                  end  \n             S6 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = t4;\n                  end        \n             S7 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 1;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = target + 4'h0;\n                  end\n             S8 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 1;\n                    iteration = iteration + 1;\n                    target = target + 4'h0;\n                  end\n             S9 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = target + 4'h0;\n                  end  \n             S10 : begin\n                    clr_en = 0;\n                    cap_en = 0;\n                    delta_en = 0;\n                    sum_en = 0;\n                    iteration = iteration + 0;\n                    target = target + 4'h0;\n                  end\n             \n             \n             \n           default : begin\n                      clr_en = 0;\n                      cap_en = 0;\n                      delta_en = 0;\n                      sum_en = 0;\n                      iteration = 0;\n                      target = target + 4'h0;\n                     end\n       endcase\n   end\n   assign w1 = w1_reg;\n   assign w2 = w2_reg;\n   assign bias = bias_reg;\n   \nendmodule\n\nmodule gate_target(\n   input  logic        [1:0] gate_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always_comb begin\n     case(gate_select)\n          2'b00 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n          2'b01 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b10 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b11 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n        default : begin\n                    o_1 =  0; \n                    o_2 =  0; \n                    o_3 =  0; \n                    o_4 =  0; \n                  end\n        endcase\n   end\nendmodule"}, "obj": true}}
{"cvdp_copilot_hebbian_rule_0017": {"input": {}, "output": {"rtl/hebb_gates.sv": ""}, "obj": true}}
{"cvdp_copilot_hill_cipher_0001": {"input": {}, "output": {"rtl/hill_cipher.sv": ""}, "obj": true}}
{"cvdp_copilot_hill_cipher_0015": {"input": {"rtl/hill_cipher.sv": "module hill_cipher (\n    input logic clk,\n    input logic reset,\n    input logic start,\n    input logic [14:0] plaintext,   // 3 letters, 5 bits each\n    input logic [44:0] key,         // 9 elements, 5 bits each\n    output logic [14:0] ciphertext, // 3 letters, 5 bits each \n    output logic done\n);\n\n    logic [4:0] P0, P1, P2;\n    logic [4:0] K00, K01, K02;\n    logic [4:0] K10, K11, K12;\n    logic [4:0] K20, K21, K22;\n\n    logic [5:0] temp0, temp1, temp2;\n    logic [4:0] C0_reg, C1_reg, C2_reg;\n\n    typedef enum logic [1:0] {\n        IDLE        = 2'b00,\n        COMPUTE     = 2'b01,\n        COMPUTE_MOD = 2'b10,\n        DONE        = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    assign P0 = plaintext[14:10];\n    assign P1 = plaintext[9:5];\n    assign P2 = plaintext[4:0];\n\n    assign K00 = key[44:40];\n    assign K01 = key[39:35];\n    assign K02 = key[34:30];\n    assign K10 = key[29:25];\n    assign K11 = key[24:20];\n    assign K12 = key[19:15];\n    assign K20 = key[14:10];\n    assign K21 = key[9:5];\n    assign K22 = key[4:0];\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    always_comb begin\n        next_state = current_state;\n        done = 1'b0;\n\n        case (current_state)\n            IDLE: begin\n                if (start)\n                    next_state = COMPUTE;\n            end\n            COMPUTE: begin\n                next_state = COMPUTE_MOD;\n            end\n            COMPUTE_MOD: begin\n                next_state = DONE;\n            end\n            DONE: begin\n                done = 1'b1;\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            temp0 <= 12'b0;\n            temp1 <= 12'b0;\n            temp2 <= 12'b0;\n            C0_reg <= 5'b0;\n            C1_reg <= 5'b0;\n            C2_reg <= 5'b0;\n        end\n        else begin\n            case (current_state)\n                COMPUTE: begin\n                    temp0 <= (K00 * P0)%26 + (K01 * P1)%26 + (K02 * P2)%26;\n                    temp1 <= (K10 * P0)%26 + (K11 * P1)%26 + (K12 * P2)%26;\n                    temp2 <= (K20 * P0)%26 + (K21 * P1)%26 + (K22 * P2)%26;\n                end\n                COMPUTE_MOD: begin\n                    C0_reg <= temp0%26;\n                    C1_reg <= temp1%26;\n                    C2_reg <= temp2%26;\n                end\n                default: begin\n                    temp0 <= 12'b0;\n                    temp1 <= 12'b0;\n                    temp2 <= 12'b0;\n                    C0_reg <= 5'b0;\n                    C1_reg <= 5'b0;\n                    C2_reg <= 5'b0;\n                end\n            endcase\n        end\n    end\n\n    assign ciphertext = {C0_reg, C1_reg, C2_reg};\n\nendmodule"}, "output": {"rtl/hill_cipher.sv": "module hill_cipher (\n    input logic clk,\n    input logic reset,\n    input logic start,\n    input logic [14:0] plaintext,   // 3 letters, 5 bits each\n    input logic [44:0] key,         // 9 elements, 5 bits each\n    output logic [14:0] ciphertext, // 3 letters, 5 bits each \n    output logic done\n);\n\n    logic [4:0] P0, P1, P2;\n    logic [4:0] K00, K01, K02;\n    logic [4:0] K10, K11, K12;\n    logic [4:0] K20, K21, K22;\n\n    logic [5:0] temp0, temp1, temp2;\n    logic [4:0] C0_reg, C1_reg, C2_reg;\n\n    typedef enum logic [1:0] {\n        IDLE        = 2'b00,\n        COMPUTE     = 2'b01,\n        COMPUTE_MOD = 2'b10,\n        DONE        = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    assign P0 = plaintext[14:10];\n    assign P1 = plaintext[9:5];\n    assign P2 = plaintext[4:0];\n\n    assign K00 = key[44:40];\n    assign K01 = key[39:35];\n    assign K02 = key[34:30];\n    assign K10 = key[29:25];\n    assign K11 = key[24:20];\n    assign K12 = key[19:15];\n    assign K20 = key[14:10];\n    assign K21 = key[9:5];\n    assign K22 = key[4:0];\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    always_comb begin\n        next_state = current_state;\n        done = 1'b0;\n\n        case (current_state)\n            IDLE: begin\n                if (start)\n                    next_state = COMPUTE;\n            end\n            COMPUTE: begin\n                next_state = COMPUTE_MOD;\n            end\n            COMPUTE_MOD: begin\n                next_state = DONE;\n            end\n            DONE: begin\n                done = 1'b1;\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            temp0 <= 12'b0;\n            temp1 <= 12'b0;\n            temp2 <= 12'b0;\n            C0_reg <= 5'b0;\n            C1_reg <= 5'b0;\n            C2_reg <= 5'b0;\n        end\n        else begin\n            case (current_state)\n                COMPUTE: begin\n                    temp0 <= (K00 * P0)%26 + (K01 * P1)%26 + (K02 * P2)%26;\n                    temp1 <= (K10 * P0)%26 + (K11 * P1)%26 + (K12 * P2)%26;\n                    temp2 <= (K20 * P0)%26 + (K21 * P1)%26 + (K22 * P2)%26;\n                end\n                COMPUTE_MOD: begin\n                    C0_reg <= temp0%26;\n                    C1_reg <= temp1%26;\n                    C2_reg <= temp2%26;\n                end\n                default: begin\n                    temp0 <= 12'b0;\n                    temp1 <= 12'b0;\n                    temp2 <= 12'b0;\n                    C0_reg <= 5'b0;\n                    C1_reg <= 5'b0;\n                    C2_reg <= 5'b0;\n                end\n            endcase\n        end\n    end\n\n    assign ciphertext = {C0_reg, C1_reg, C2_reg};\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_hmac_register_0001": {"input": {}, "output": {"rtl/hmac_reg_interface.sv": ""}, "obj": true}}
{"cvdp_copilot_huffman_0001": {"input": {}, "output": {"rtl/single_port_ram.sv": "", "rtl/huffman_encoder.sv": ""}, "obj": true}}
{"cvdp_copilot_icache_controller_0001": {"input": {}, "output": {"rtl/instruction_cache_controller.sv": ""}, "obj": true}}
{"cvdp_copilot_image_rotate_0001": {"input": {}, "output": {"rtl/image_rotate.sv": ""}, "obj": true}}
{"cvdp_copilot_image_rotate_0014": {"input": {"rtl/image_rotate.sv": "module image_rotate #(\n  parameter IN_ROW     = 4,                                   // Number of rows in input image\n  parameter IN_COL     = 4,                                   // Number of columns in input image\n  parameter OUT_ROW    = (IN_ROW > IN_COL) ? IN_ROW : IN_COL, // Output rows after padding\n  parameter OUT_COL    = (IN_ROW > IN_COL) ? IN_ROW : IN_COL, // Output columns after padding\n  parameter DATA_WIDTH = 8,                                   // Bit-width of data\n  parameter OUTPUT_DATA_WIDTH = DATA_WIDTH\n) (\n  input  logic                                    clk,                // Clock Signal\n  input  logic                                    srst,               // Active-High Synchronous Reset\n  input  logic                                    valid_in,           // Indicates valid input image\n  input  logic                       [       1:0] rotation_angle,     // Rotation angle (00: 90\u00b0, 01: 180\u00b0, 10: 270\u00b0, 11: No Rotation)\n  input  logic   [(IN_ROW*IN_COL*DATA_WIDTH)-1:0] image_in,           // Flattened input image\n  output logic                                    valid_out,          // Indicates valid output image\n  output logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] image_out           // Flattened output image\n);\n\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] padded_image, padded_image_reg, padded_image_reg2, padded_image_reg3;     // Padded image stored in registers\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] transposed_image, transposed_image_reg, transposed_image_reg2, transposed_image_reg3; // Transposed image stored in registers\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] rotated_image, rotated_image_reg, rotated_image_reg2, rotated_image_reg3;    // Final rotated image (latency buffer)\n\n  logic [5:0] valid_out_reg;\n\n  always_ff @(posedge clk)\n    if (srst)\n      {valid_out, valid_out_reg} <= '0;\n    else\n      {valid_out, valid_out_reg} <= {valid_out_reg, valid_in}; \n\n  // Step 1: Pad the input image into a square image (Sequentially Stored)\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      padded_image <= '0;\n    end else begin\n      for (int pad_row = 0; pad_row < OUT_ROW; pad_row++) begin\n        for (int pad_col = 0; pad_col < OUT_COL; pad_col++) begin\n          if ((pad_row < IN_ROW) && (pad_col < IN_COL)) begin\n            // Copy input data into padded_image\n            padded_image[(pad_row * OUT_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH] = image_in[(pad_row * IN_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH];\n          end else begin\n            // Fill remaining positions with zeros\n            padded_image[(pad_row * OUT_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH] = '0;\n          end\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    padded_image_reg <= padded_image;\n    padded_image_reg2 <= padded_image_reg;\n    padded_image_reg3 <= padded_image_reg2;\n  end\n\n  // Step 2: Transpose the padded image (Stored in Registers)\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      transposed_image <= '0;\n    end else begin\n      for (int trans_row = 0; trans_row < OUT_ROW; trans_row++) begin\n        for (int trans_col = 0; trans_col < OUT_COL; trans_col++) begin\n          // Transpose logic: Swap rows and columns\n          transposed_image[(trans_col * OUT_ROW + trans_row) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg[(trans_row * OUT_COL + trans_col) * DATA_WIDTH +: DATA_WIDTH];\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    transposed_image_reg <= transposed_image;\n  end\n\n  // Step 3: Apply rotation logic with additional latency buffer\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      rotated_image <= 32'd0;\n    end else begin\n      for (int rot_row = 0; rot_row < OUT_ROW; rot_row++) begin\n        for (int rot_col = 0; rot_col < OUT_COL; rot_col++) begin\n          case (rotation_angle)\n            // 90\u00b0 Clockwise: Transpose + Reverse Rows\n            2'b00: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= transposed_image_reg[(rot_row * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n\n            // 180\u00b0 Clockwise: Reverse Rows and Columns\n            2'b01: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] = padded_image_reg3[((OUT_ROW-1-rot_row) * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n\n            // 270\u00b0 Clockwise: Transpose + Reverse Columns\n            2'b10: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] = transposed_image_reg[((OUT_ROW-1-rot_row) * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n\n            // No Rotation (Pass-through)\n            2'b11: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg3[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n\n            // No Rotation (Pass-through)\n            2'b11: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg3[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n          endcase\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    rotated_image_reg <= rotated_image;\n  end\n\n  // Step 4: Output Register for Added Latency\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      image_out <= '0;\n    end else begin\n      image_out <= rotated_image_reg;\n    end\n  end\n\nendmodule"}, "output": {"rtl/image_rotate.sv": "module image_rotate #(\n  parameter IN_ROW     = 4,                                   // Number of rows in input image\n  parameter IN_COL     = 4,                                   // Number of columns in input image\n  parameter OUT_ROW    = (IN_ROW > IN_COL) ? IN_ROW : IN_COL, // Output rows after padding\n  parameter OUT_COL    = (IN_ROW > IN_COL) ? IN_ROW : IN_COL, // Output columns after padding\n  parameter DATA_WIDTH = 8,                                   // Bit-width of data\n  parameter OUTPUT_DATA_WIDTH = DATA_WIDTH\n) (\n  input  logic                                    clk,                // Clock Signal\n  input  logic                                    srst,               // Active-High Synchronous Reset\n  input  logic                                    valid_in,           // Indicates valid input image\n  input  logic                       [       1:0] rotation_angle,     // Rotation angle (00: 90\u00b0, 01: 180\u00b0, 10: 270\u00b0, 11: No Rotation)\n  input  logic   [(IN_ROW*IN_COL*DATA_WIDTH)-1:0] image_in,           // Flattened input image\n  output logic                                    valid_out,          // Indicates valid output image\n  output logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] image_out           // Flattened output image\n);\n\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] padded_image, padded_image_reg, padded_image_reg2, padded_image_reg3;     // Padded image stored in registers\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] transposed_image, transposed_image_reg, transposed_image_reg2, transposed_image_reg3; // Transposed image stored in registers\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] rotated_image, rotated_image_reg, rotated_image_reg2, rotated_image_reg3;    // Final rotated image (latency buffer)\n\n  logic [5:0] valid_out_reg;\n\n  always_ff @(posedge clk)\n    if (srst)\n      {valid_out, valid_out_reg} <= '0;\n    else\n      {valid_out, valid_out_reg} <= {valid_out_reg, valid_in}; \n\n  // Step 1: Pad the input image into a square image (Sequentially Stored)\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      padded_image <= '0;\n    end else begin\n      for (int pad_row = 0; pad_row < OUT_ROW; pad_row++) begin\n        for (int pad_col = 0; pad_col < OUT_COL; pad_col++) begin\n          if ((pad_row < IN_ROW) && (pad_col < IN_COL)) begin\n            // Copy input data into padded_image\n            padded_image[(pad_row * OUT_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH] = image_in[(pad_row * IN_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH];\n          end else begin\n            // Fill remaining positions with zeros\n            padded_image[(pad_row * OUT_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH] = '0;\n          end\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    padded_image_reg <= padded_image;\n    padded_image_reg2 <= padded_image_reg;\n    padded_image_reg3 <= padded_image_reg2;\n  end\n\n  // Step 2: Transpose the padded image (Stored in Registers)\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      transposed_image <= '0;\n    end else begin\n      for (int trans_row = 0; trans_row < OUT_ROW; trans_row++) begin\n        for (int trans_col = 0; trans_col < OUT_COL; trans_col++) begin\n          // Transpose logic: Swap rows and columns\n          transposed_image[(trans_col * OUT_ROW + trans_row) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg[(trans_row * OUT_COL + trans_col) * DATA_WIDTH +: DATA_WIDTH];\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    transposed_image_reg <= transposed_image;\n  end\n\n  // Step 3: Apply rotation logic with additional latency buffer\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      rotated_image <= 32'd0;\n    end else begin\n      for (int rot_row = 0; rot_row < OUT_ROW; rot_row++) begin\n        for (int rot_col = 0; rot_col < OUT_COL; rot_col++) begin\n          case (rotation_angle)\n            // 90\u00b0 Clockwise: Transpose + Reverse Rows\n            2'b00: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= transposed_image_reg[(rot_row * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n\n            // 180\u00b0 Clockwise: Reverse Rows and Columns\n            2'b01: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] = padded_image_reg3[((OUT_ROW-1-rot_row) * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n\n            // 270\u00b0 Clockwise: Transpose + Reverse Columns\n            2'b10: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] = transposed_image_reg[((OUT_ROW-1-rot_row) * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n\n            // No Rotation (Pass-through)\n            2'b11: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg3[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n\n            // No Rotation (Pass-through)\n            2'b11: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg3[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n          endcase\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    rotated_image_reg <= rotated_image;\n  end\n\n  // Step 4: Output Register for Added Latency\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      image_out <= '0;\n    end else begin\n      image_out <= rotated_image_reg;\n    end\n  end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_image_rotate_0015": {"input": {"rtl/image_rotate.sv": "module image_rotate #(\n  parameter IN_ROW     = 4,                                   // Number of rows in input image\n  parameter IN_COL     = 4,                                   // Number of columns in input image\n  parameter OUT_ROW    = (IN_ROW > IN_COL) ? IN_ROW : IN_COL, // Output rows after padding\n  parameter OUT_COL    = (IN_ROW > IN_COL) ? IN_ROW : IN_COL, // Output columns after padding\n  parameter DATA_WIDTH = 8                                    // Bit-width of data\n) (\n  input  logic                                    clk,                // Clock Signal\n  input  logic                                    srst,               // Active-High Synchronous Reset\n  input  logic                                    valid_in,           // Indicates valid input image\n  input  logic                       [       1:0] rotation_angle,     // Rotation angle (00: 90\u00b0, 01: 180\u00b0, 10: 270\u00b0, 11: No Rotation)\n  input  logic   [(IN_ROW*IN_COL*DATA_WIDTH)-1:0] image_in,           // Flattened input image\n  output logic                                    valid_out,          // Indicates valid output image\n  output logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] image_out           // Flattened output image\n);\n\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] padded_image, padded_image_reg, padded_image_reg2, padded_image_reg3;     // Padded image stored in registers\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] transposed_image, transposed_image_reg; // Transposed image stored in registers\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] rotated_image, rotated_image_reg;    // Final rotated image (latency buffer)\n\n  logic [5:0] valid_out_reg;\n\n  always_ff @(posedge clk)\n    if (srst)\n      {valid_out, valid_out_reg} <= '0;\n    else\n      {valid_out, valid_out_reg} <= {valid_out_reg, valid_in}; \n\n  // Step 1: Pad the input image into a square image (Sequentially Stored)\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      padded_image <= '0;\n    end else begin\n      for (int pad_row = 0; pad_row < OUT_ROW; pad_row++) begin\n        for (int pad_col = 0; pad_col < OUT_COL; pad_col++) begin\n          if ((pad_row < IN_ROW) && (pad_col < IN_COL)) begin\n            // Copy input data into padded_image\n            padded_image[(pad_row * OUT_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH] <= image_in[(pad_row * IN_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH];\n          end else begin\n            // Fill remaining positions with zeros\n            padded_image[(pad_row * OUT_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH] <= '0;\n          end\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    padded_image_reg <= padded_image;\n    padded_image_reg2 <= padded_image_reg;\n    padded_image_reg3 <= padded_image_reg2;\n  end\n\n  // Step 2: Transpose the padded image (Stored in Registers)\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      transposed_image <= '0;\n    end else begin\n      for (int trans_row = 0; trans_row < OUT_ROW; trans_row++) begin\n        for (int trans_col = 0; trans_col < OUT_COL; trans_col++) begin\n          // Transpose logic: Swap rows and columns\n          transposed_image[(trans_col * OUT_ROW + trans_row) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg[(trans_row * OUT_COL + trans_col) * DATA_WIDTH +: DATA_WIDTH];\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    transposed_image_reg <= transposed_image;\n  end\n\n  // Step 3: Apply rotation logic with additional latency buffer\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      rotated_image <= '0;\n    end else begin\n      for (int rot_row = 0; rot_row < OUT_ROW; rot_row++) begin\n        for (int rot_col = 0; rot_col < OUT_COL; rot_col++) begin\n          case (rotation_angle)\n            // 90\u00b0 Clockwise: Transpose + Reverse Rows\n            2'b00: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= transposed_image_reg[(rot_row * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n\n            // 180\u00b0 Clockwise: Reverse Rows and Columns\n            2'b01: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg3[((OUT_ROW-1-rot_row) * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n\n            // 270\u00b0 Clockwise: Transpose + Reverse Columns\n            2'b10: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= transposed_image_reg[((OUT_ROW-1-rot_row) * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n\n            // No Rotation (Pass-through)\n            2'b11: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg3[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n\n          endcase\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    rotated_image_reg <= rotated_image;\n  end\n\n  // Step 4: Output Register for Added Latency\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      image_out <= '0;\n    end else begin\n      image_out <= rotated_image_reg;\n    end\n  end\n\nendmodule"}, "output": {"rtl/image_rotate.sv": "module image_rotate #(\n  parameter IN_ROW     = 4,                                   // Number of rows in input image\n  parameter IN_COL     = 4,                                   // Number of columns in input image\n  parameter OUT_ROW    = (IN_ROW > IN_COL) ? IN_ROW : IN_COL, // Output rows after padding\n  parameter OUT_COL    = (IN_ROW > IN_COL) ? IN_ROW : IN_COL, // Output columns after padding\n  parameter DATA_WIDTH = 8                                    // Bit-width of data\n) (\n  input  logic                                    clk,                // Clock Signal\n  input  logic                                    srst,               // Active-High Synchronous Reset\n  input  logic                                    valid_in,           // Indicates valid input image\n  input  logic                       [       1:0] rotation_angle,     // Rotation angle (00: 90\u00b0, 01: 180\u00b0, 10: 270\u00b0, 11: No Rotation)\n  input  logic   [(IN_ROW*IN_COL*DATA_WIDTH)-1:0] image_in,           // Flattened input image\n  output logic                                    valid_out,          // Indicates valid output image\n  output logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] image_out           // Flattened output image\n);\n\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] padded_image, padded_image_reg, padded_image_reg2, padded_image_reg3;     // Padded image stored in registers\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] transposed_image, transposed_image_reg; // Transposed image stored in registers\n  logic [(OUT_ROW*OUT_COL*DATA_WIDTH)-1:0] rotated_image, rotated_image_reg;    // Final rotated image (latency buffer)\n\n  logic [5:0] valid_out_reg;\n\n  always_ff @(posedge clk)\n    if (srst)\n      {valid_out, valid_out_reg} <= '0;\n    else\n      {valid_out, valid_out_reg} <= {valid_out_reg, valid_in}; \n\n  // Step 1: Pad the input image into a square image (Sequentially Stored)\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      padded_image <= '0;\n    end else begin\n      for (int pad_row = 0; pad_row < OUT_ROW; pad_row++) begin\n        for (int pad_col = 0; pad_col < OUT_COL; pad_col++) begin\n          if ((pad_row < IN_ROW) && (pad_col < IN_COL)) begin\n            // Copy input data into padded_image\n            padded_image[(pad_row * OUT_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH] <= image_in[(pad_row * IN_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH];\n          end else begin\n            // Fill remaining positions with zeros\n            padded_image[(pad_row * OUT_COL + pad_col) * DATA_WIDTH +: DATA_WIDTH] <= '0;\n          end\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    padded_image_reg <= padded_image;\n    padded_image_reg2 <= padded_image_reg;\n    padded_image_reg3 <= padded_image_reg2;\n  end\n\n  // Step 2: Transpose the padded image (Stored in Registers)\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      transposed_image <= '0;\n    end else begin\n      for (int trans_row = 0; trans_row < OUT_ROW; trans_row++) begin\n        for (int trans_col = 0; trans_col < OUT_COL; trans_col++) begin\n          // Transpose logic: Swap rows and columns\n          transposed_image[(trans_col * OUT_ROW + trans_row) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg[(trans_row * OUT_COL + trans_col) * DATA_WIDTH +: DATA_WIDTH];\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    transposed_image_reg <= transposed_image;\n  end\n\n  // Step 3: Apply rotation logic with additional latency buffer\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      rotated_image <= '0;\n    end else begin\n      for (int rot_row = 0; rot_row < OUT_ROW; rot_row++) begin\n        for (int rot_col = 0; rot_col < OUT_COL; rot_col++) begin\n          case (rotation_angle)\n            // 90\u00b0 Clockwise: Transpose + Reverse Rows\n            2'b00: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= transposed_image_reg[(rot_row * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n\n            // 180\u00b0 Clockwise: Reverse Rows and Columns\n            2'b01: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg3[((OUT_ROW-1-rot_row) * OUT_COL + (OUT_COL-1-rot_col)) * DATA_WIDTH +: DATA_WIDTH];\n\n            // 270\u00b0 Clockwise: Transpose + Reverse Columns\n            2'b10: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= transposed_image_reg[((OUT_ROW-1-rot_row) * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n\n            // No Rotation (Pass-through)\n            2'b11: rotated_image[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH] <= padded_image_reg3[(rot_row * OUT_COL + rot_col) * DATA_WIDTH +: DATA_WIDTH];\n\n          endcase\n        end\n      end\n    end\n  end\n\n  always_ff @(posedge clk) begin\n    rotated_image_reg <= rotated_image;\n  end\n\n  // Step 4: Output Register for Added Latency\n  always_ff @(posedge clk) begin\n    if (srst) begin\n      image_out <= '0;\n    end else begin\n      image_out <= rotated_image_reg;\n    end\n  end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_image_stego_0004": {"input": {"rtl/image_stego.sv": "module image_stego #(\n  parameter row = 2,\n  parameter col = 2\n)(\n  input  [(row*col*8)-1:0] img_in,\n  input  [(row*col*4)-1:0] data_in,\n  input  [1:0]             bpp,\n  output [(row*col*8)-1:0] img_out\n);\n\n  genvar i;\n  generate\n    for(i = 0; i < row*col; i++) begin\n      assign img_out[(i*8)+7:(i*8)] = (bpp[1] == 1'b0)\n                                      ? (bpp[0] == 1'b0\n                                         ? {img_in[(i*8)+7 : (i*8)+1], data_in[i]}\n                                         : {img_in[(i*8)+7 : (i*8)+2], data_in[(2*i)+1], data_in[2*i]}) \n                                      : img_in[(i*8)+7 : (i*8)]; \n    end\n  endgenerate\n\nendmodule"}, "output": {"rtl/image_stego.sv": "module image_stego #(\n  parameter row = 2,\n  parameter col = 2\n)(\n  input  [(row*col*8)-1:0] img_in,\n  input  [(row*col*4)-1:0] data_in,\n  input  [1:0]             bpp,\n  output [(row*col*8)-1:0] img_out\n);\n\n  genvar i;\n  generate\n    for(i = 0; i < row*col; i++) begin\n      assign img_out[(i*8)+7:(i*8)] = (bpp[1] == 1'b0)\n                                      ? (bpp[0] == 1'b0\n                                         ? {img_in[(i*8)+7 : (i*8)+1], data_in[i]}\n                                         : {img_in[(i*8)+7 : (i*8)+2], data_in[(2*i)+1], data_in[2*i]}) \n                                      : img_in[(i*8)+7 : (i*8)]; \n    end\n  endgenerate\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_interrupt_controller_0014": {"input": {}, "output": {"rtl/programmable_interrupt_controller.sv": ""}, "obj": true}}
{"cvdp_copilot_interrupt_controller_0017": {"input": {}, "output": {"rtl/pic_starvation_prevention.sv": ""}, "obj": true}}
{"cvdp_copilot_interrupt_controller_0019": {"input": {}, "output": {"rtl/interrupt_controller_apb.sv": ""}, "obj": true}}
{"cvdp_copilot_ir_receiver_0001": {"input": {}, "output": {"rtl/ir_receiver.sv": ""}, "obj": true}}
{"cvdp_copilot_ir_receiver_0005": {"input": {}, "output": {"rtl/ir_receiver.sv": ""}, "obj": true}}
{"cvdp_copilot_kogge_stone_adder_0007": {"input": {"rtl/kogge_stone_adder.sv": "module kogge_stone_adder (\n    input logic clk,   //buggy\n    input logic reset,\n    input logic [15:0] A,\n    input logic [15:0] B,\n    input logic start,\n    output logic [16:0] Sum,\n    output logic done\n);\n\n    logic [15:0] G0, G1, G2, G3;\n    logic [15:0] P0, P1, P2, P3;\n    logic [16:0] carry;\n    logic [16:0] sum_comb;\n    logic [3:0] stage;\n    logic active;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            Sum <= 0;\n            done <= 0;\n            active <= 0;\n            stage <= 0;\n        end else if (start && !active) begin\n            active <= 1;\n            stage <= 0;\n            done <= 0;\n            Sum <= 0;\n        end else if (active) begin\n            if (stage == 4) begin\n                Sum <= sum_comb;    \n                done <= 1;\n                active <= 0;\n            end else begin\n                stage <= stage + 1;\n            end\n        end else if (!start) begin\n            done <= 0;\n        end\n    end\n\n    always_comb begin\n        G1 = 0; G2 = 0; G3 = 0;\n        P1 = 0; P2 = 0; P3 = 0;\n        carry = 0;\n        sum_comb = 0;\n\n        for (int i = 0; i < 16; i++) begin\n            G0[i] = A[i] & B[i];\n            P0[i] = A[i] ^ B[i];\n        end\n\n        if (stage >= 0) begin\n            for (int i = 0; i < 16; i++) begin\n                if (i >= 1 && i != 3 && i != 7) begin  \n                    G1[i] = G0[i] | (P0[i] & G0[i - 1]);\n                    P1[i] = P0[i] & P0[i - 1];\n                end else begin\n                    G1[i] = G0[i];  \n                    P1[i] = P0[i];\n                end\n            end\n        end\n\n        \n        if (stage >= 1) begin\n            for (int i = 0; i < 16; i++) begin\n                if (i == 10) begin  \n                    G2[i] = 1'b0;\n                    P2[i] = 1'b1;\n                end else if (i >= 2) begin\n                    G2[i] = G1[i] | (P1[i] & G1[i - 2]);\n                    P2[i] = P1[i] & P1[i - 2];\n                end else begin\n                    G2[i] = G1[i];\n                    P2[i] = P1[i];\n                end\n            end\n        end\n\n        if (stage >= 2) begin\n            for (int i = 0; i < 16; i++) begin\n                if (i == 5) begin  \n                    G3[i] = P2[i];\n                    P3[i] = G2[i];\n                end else if (i >= 4) begin\n                    G3[i] = G2[i] | (P2[i] & G2[i - 4]);\n                    P3[i] = P2[i] & P2[i - 4];\n                end else begin\n                    G3[i] = G2[i];\n                    P3[i] = P2[i];\n                end\n            end\n        end\n\n        if (stage >= 3) begin\n            carry[0] = 0;\n            for (int i = 1; i <= 16; i++) begin\n                carry[i] = G3[i - 1] | (P3[i - 1] & carry[i - 1]);\n            end\n\n            for (int i = 0; i < 16; i++) begin\n                sum_comb[i] = P0[i] ^ carry[i];\n            end\n            sum_comb[16] = carry[16] ^ carry[5];  \n        end\n    end\nendmodule"}, "output": {"rtl/kogge_stone_adder.sv": ""}, "obj": true}}
{"cvdp_copilot_lfsr_0007": {"input": {"rtl/lfsr_8bit.sv": "module lfsr_8bit(input clock,reset,input [7:0] lfsr_seed, output reg [7:0] lfsr_out);\n\tlogic q1,q2,q3;\n\t//Primitive polynomial considered for 8-bit Linear Feedback Shift Register (LFSR) with Galois configuration is x^8+x^6+x^5+x+1 \n\t\n\t//Internal XORing based on primitive polynomial\n\tassign q1 = lfsr_out[6] ^ lfsr_out[0];\n\tassign q2 = lfsr_out[5] ^ lfsr_out[0];\n\tassign q3 = lfsr_out[1] ^ lfsr_out[0];\n\n\talways_ff @(posedge clock or negedge reset)\n\tbegin\n\t\tif (!reset)\n\t\t\tlfsr_out <= lfsr_seed;//If reset is at logic LOW, the initial seed will be loaded into LFSR's 8-bit output\n\t\telse\n\t\t\tlfsr_out <= {lfsr_out[0],lfsr_out[7],q1,q2,lfsr_out[4],lfsr_out[3],lfsr_out[2],q3};//Shift register based on the primitive polynomial\n\tend\nendmodule"}, "output": {"rtl/lfsr_8bit.sv": ""}, "obj": true}}
{"cvdp_copilot_line_buffer_0003": {"input": {"rtl/line_buffer.sv": "module line_buffer #(\n    parameter NBW_DATA  = 'd8,  // Bit width of grayscale input/output data\n    parameter NS_ROW    = 'd10, // Number of rows\n    parameter NS_COLUMN = 'd8,  // Number of columns\n    parameter NBW_ROW   = 'd4,  // log2(NS_ROW). Bit width of i_image_row_start\n    parameter NBW_COL   = 'd3,  // log2(NS_COLUMN). Bit width of i_image_col_start\n    parameter NBW_MODE  = 'd3,  // Bit width of mode input\n    parameter NS_R_OUT  = 'd4,  // Number of rows of the output window\n    parameter NS_C_OUT  = 'd3,  // Number of columns of the output window\n    parameter CONSTANT  = 'd255 // Constant value to use in PAD_CONSTANT mode\n) (\n    input  logic                                  clk,\n    input  logic                                  rst_async_n,\n    input  logic [NBW_MODE-1:0]                   i_mode,\n    input  logic                                  i_valid,\n    input  logic                                  i_update_window,\n    input  logic [NBW_DATA*NS_COLUMN-1:0]         i_row_image,\n    input  logic [NBW_ROW-1:0]                    i_image_row_start,\n    input  logic [NBW_COL-1:0]                    i_image_col_start,\n    output logic [NBW_DATA*NS_R_OUT*NS_C_OUT-1:0] o_image_window\n);\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nlogic [NBW_DATA-1:0] image_buffer_ff [NS_ROW][NS_COLUMN];\nlogic [NBW_DATA-1:0] row_image [NS_COLUMN];\nlogic [NBW_DATA-1:0] window [NS_R_OUT][NS_C_OUT];\nlogic [NBW_DATA*NS_R_OUT*NS_C_OUT-1:0] image_window_ff;\n\n// ----------------------------------------\n// - Output generation\n// ----------------------------------------\nalways_comb begin : window_assignment\n    case(i_mode)\n        3'd0: begin // NO_BOUND_PROCESS\n            for (int row = 0; row < NS_R_OUT; row++) begin\n                for (int col = 0; col < NS_C_OUT; col++) begin\n                    if(i_image_row_start + col >= NS_ROW) begin\n                        window[row][col] = 0;\n                    end else if (i_image_col_start + row >= NS_COLUMN) begin\n                        window[row][col] = 0;\n                    end else begin\n                        window[row][col] = image_buffer_ff[i_image_row_start + col][i_image_col_start + row];\n                    end\n                end\n            end\n        end\n        3'd1: begin // PAD_CONSTANT\n            for (int row = 0; row < NS_R_OUT; row++) begin\n                for (int col = 0; col < NS_C_OUT; col++) begin\n                    if(i_image_row_start + col >= NS_ROW) begin\n                        window[row][col] = CONSTANT;\n                    end else if (i_image_col_start + row >= NS_COLUMN) begin\n                        window[row][col] = CONSTANT;\n                    end else begin\n                        window[row][col] = image_buffer_ff[i_image_row_start + col][i_image_col_start + row];\n                    end\n                end\n            end\n        end\n        3'd2: begin // EXTEND_NEAR\n            for (int row = 0; row < NS_R_OUT; row++) begin\n                for (int col = 0; col < NS_C_OUT; col++) begin\n                    if(i_image_row_start + col >= NS_ROW) begin\n                        window[row][col] = image_buffer_ff[NS_ROW-1][i_image_col_start + row];\n                    end else if (i_image_col_start + row >= NS_COLUMN) begin\n                        window[row][col] = image_buffer_ff[i_image_row_start + col][NS_COLUMN-1];\n                    end else begin\n                        window[row][col] = image_buffer_ff[i_image_row_start + col][i_image_col_start + row];\n                    end\n                end\n            end\n        end\n        3'd3: begin // MIRROR_BOUND\n            for (int row = 0; row < NS_R_OUT; row++) begin\n                for (int col = 0; col < NS_C_OUT; col++) begin\n                    if(i_image_row_start + col >= NS_ROW) begin\n                        window[row][col] = image_buffer_ff[2*NS_ROW-1-(i_image_row_start + col)][i_image_col_start + row];\n                    end else if (i_image_col_start + row >= NS_COLUMN) begin\n                        window[row][col] = image_buffer_ff[i_image_row_start + col][NS_COLUMN-1-(i_image_col_start + row)];\n                    end else begin\n                        window[row][col] = image_buffer_ff[i_image_row_start + col][i_image_col_start + row];\n                    end\n                end\n            end\n        end\n        3'd4: begin // WRAP_AROUND\n            for (int row = 0; row < NS_R_OUT; row++) begin\n                for (int col = 0; col < NS_C_OUT; col++) begin\n                    if(i_image_row_start + col >= NS_ROW) begin\n                        window[row][col] = image_buffer_ff[(i_image_row_start + col)-NS_ROW][i_image_col_start + row];\n                    end else if (i_image_col_start + row >= NS_COLUMN) begin\n                        window[row][col] = image_buffer_ff[i_image_row_start + col][(i_image_col_start + row)-NS_COLUMN];\n                    end else begin\n                        window[row][col] = image_buffer_ff[i_image_row_start + col][i_image_col_start + row];\n                    end\n                end\n            end\n        end\n        default: begin\n            for (int row = 0; row < NS_R_OUT; row++) begin\n                for (int col = 0; col < NS_C_OUT; col++) begin\n                    window[row][col] = 0;\n                end\n            end\n        end\n    endcase\nend\n\n// ----------------------------------------\n// - Input control\n// ----------------------------------------\ngenerate\n    for (genvar col = 0; col < NS_COLUMN; col++) begin : unpack_row_image\n        assign row_image[NS_COLUMN-col-1] = i_row_image[(col+1)*NBW_DATA-1-:NBW_DATA];\n    end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : ctrl_regs\n    if(~rst_async_n) begin\n        image_window_ff <= 0;\n        for (int row = 0; row < NS_ROW; row++) begin\n            for (int col = 0; col < NS_COLUMN; col++) begin\n                image_buffer_ff[row][col] <= 0;\n            end\n        end\n    end else begin\n        if(i_valid) begin\n            for (int col = 0; col < NS_COLUMN; col++) begin\n                image_buffer_ff[0][col] <= row_image[col];\n            end\n\n            for (int row = 1; row < NS_ROW; row++) begin\n                for (int col = 0; col < NS_COLUMN; col++) begin\n                    image_buffer_ff[row][col] <= image_buffer_ff[row-1][col];\n                end\n            end\n        end\n\n        if(i_update_window) begin\n            image_window_ff <= o_image_window;\n        end\n    end\nend\n\n// ----------------------------------------\n// - Output packing\n// ----------------------------------------\ngenerate\n    for(genvar row = 0; row < NS_R_OUT; row++) begin : out_row\n        for(genvar col = 0; col < NS_C_OUT; col++) begin : out_col\n            always_comb begin\n                if(i_update_window) begin\n                    o_image_window[(row*NS_C_OUT+col+1)*NBW_DATA-1-:NBW_DATA] = window[row][col];\n                end else begin\n                    o_image_window[(row*NS_C_OUT+col+1)*NBW_DATA-1-:NBW_DATA] = image_window_ff[(row*NS_C_OUT+col+1)*NBW_DATA-1-:NBW_DATA];\n                end\n            end\n        end\n    end\nendgenerate\n\nendmodule : line_buffer"}, "output": {"rtl/line_buffer.sv": ""}, "obj": true}}
{"cvdp_copilot_load_store_unit_0001": {"input": {}, "output": {"rtl/load_store_unit.sv": ""}, "obj": true}}
{"cvdp_copilot_load_store_unit_0003": {"input": {"rtl/load_store_unit.sv": "module load_store_unit (\n    input  logic                 clk,\n    input  logic                 rst_n,\n\n    // EX stage interface\n    input  logic                 ex_if_req_i,           // LSU request\n    input  logic                 ex_if_we_i,            // Write enable: 0 (load), 1 (store)\n    input  logic     [ 1:0]      ex_if_type_i,          // Data type: 0x2 (word), 0x1 (halfword), 0x0 (byte)\n    input  logic     [31:0]      ex_if_wdata_i,         // Data to write to memory\n    input  logic     [31:0]      ex_if_addr_base_i,     // Base address\n    input  logic     [31:0]      ex_if_addr_offset_i,   // Offset address\n    output logic                 ex_if_ready_o    ,\n    \n    // Writeback stage interface\n    output logic     [31:0]      wb_if_rdata_o,         // Requested data\n    output logic                 wb_if_rvalid_o,        // Requested data valid\n\n    // Data memory (DMEM) interface\n    output logic                 dmem_req_o,\n    input  logic                 dmem_gnt_i,\n    output logic     [31:0]      dmem_req_addr_o,\n    output logic                 dmem_req_we_o,\n    output logic     [ 3:0]      dmem_req_be_o,\n    output logic     [31:0]      dmem_req_wdata_o,\n    input  logic     [31:0]      dmem_rsp_rdata_i,\n    input  logic                 dmem_rvalid_i\n    );\n\n  // Internal signals\n  logic ex_req_fire;\n  logic dmem_req_we_q;\n  logic [31:0] data_addr_int;\n  logic misaligned_addr;\n  logic [3:0] dmem_be, dmem_req_be_q;\n\n  logic busy_q;  // Sticky busy bit: Set with EX req and cleared with DMEM response\n  logic dmem_req_q ;\n\n\n\n  \n  logic [31:0] dmem_req_wdata_q;\n  logic [31:0] dmem_req_addr_q;\n\n  logic [31:0] wb_if_rdata_q;\n  logic wb_if_rvalid_q;\n\n  // Address calculation\n  assign data_addr_int = ex_if_addr_base_i + ex_if_addr_offset_i;\n\n  // EX request fire condition\n  assign ex_req_fire = ex_if_req_i && !busy_q && !misaligned_addr;\n  assign ex_if_ready_o = !busy_q;\n\n  ///////////////////////////////// Byte Enable Generation ////////////////////////////////\n  always_comb begin\n    misaligned_addr = 1'b0;\n    dmem_be = 4'b0000;\n    case (ex_if_type_i)  // 0x2 (word), 0x1 (halfword), 0x0 (byte)\n      2'b00: begin  // Writing a byte\n          case (data_addr_int[1:0])\n            2'b00:   dmem_be = 4'b0001;\n            2'b01:   dmem_be = 4'b0010;\n            2'b10:   dmem_be = 4'b0100;\n            2'b11:   dmem_be = 4'b1000;\n            default: dmem_be = 4'b0000;\n          endcase\n      end\n\n      2'b01: begin  // Writing a half-word\n          case (data_addr_int[1:0])\n            2'b00:   dmem_be = 4'b0011;\n            2'b10:   dmem_be = 4'b1100;\n            default: begin\n                dmem_be = 4'b0000;\n                misaligned_addr = 1'b1;\n            end\n          endcase\n      end\n\n      2'b10: begin  // Writing a word\n          case (data_addr_int[1:0])\n            2'b00:   dmem_be = 4'b1111;\n            default: begin\n                dmem_be = 4'b0000;\n                misaligned_addr = 1'b1;\n            end\n          endcase\n      end\n      default: begin\n          dmem_be = 4'b0000;\n          misaligned_addr = 1'b1;\n      end \n    endcase\n  end\n\n  \n  ///////////////////////////////// dmem_req ////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n      dmem_req_q <= 1'b0;\n      dmem_req_addr_q <= '0;\n      dmem_req_we_q <= '0 ;\n      dmem_req_be_q <= '0 ;\n      dmem_req_wdata_q <= '0 ;\n    end else if (ex_req_fire) begin\n      dmem_req_q <= 1'b1;\n      dmem_req_addr_q <= data_addr_int;\n      dmem_req_we_q <= ex_if_we_i;\n      dmem_req_be_q <= dmem_be ;\n      dmem_req_wdata_q <= ex_if_wdata_i ;\n    end else if (dmem_req_q && dmem_gnt_i) begin\n      dmem_req_q <= 1'b0;  // request granted\n      dmem_req_addr_q <= '0 ;\n      dmem_req_we_q <= '0 ;\n      dmem_req_be_q <= '0 ;\n      dmem_req_wdata_q <= '0 ;\n    end\n  end\n  \n\n  ///////////////////////////////// DMEM Request Interface ////////////////////////////////\n  always_comb begin : dmem_req\n    dmem_req_o        = dmem_req_q;\n    dmem_req_addr_o   = dmem_req_addr_q;\n    dmem_req_we_o     = dmem_req_we_q;\n    dmem_req_be_o     = dmem_req_be_q;\n    dmem_req_wdata_o  = dmem_req_wdata_q;\n  end\n\n  ///////////////////////////////// Read Response Handling ////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n      wb_if_rdata_q   <= 32'b0;\n      wb_if_rvalid_q  <= 1'b0;\n    end else if (dmem_rvalid_i) begin\n      wb_if_rdata_q   <= dmem_rsp_rdata_i;\n      wb_if_rvalid_q  <= 1'b1;\n    end else begin\n      wb_if_rvalid_q  <= 1'b0;\n    end\n  end\n\n  assign wb_if_rdata_o =  wb_if_rdata_q;\n  assign wb_if_rvalid_o = wb_if_rvalid_q;\n\n  ///////////////////////////////// Busy Logic ////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n      busy_q <= 1'b0;\n    end else if (ex_req_fire) begin\n      busy_q <= 1'b1;\n    end else if (dmem_req_we_q && dmem_gnt_i) begin\n      busy_q <= 1'b0;  // Write request granted\n    end else if (!dmem_req_we_q && dmem_rvalid_i) begin\n      busy_q <= 1'b0;  // Read request response received\n    end\n  end\n  \nendmodule"}, "output": {"rtl/load_store_unit.sv": "module load_store_unit (\n    input  logic                 clk,\n    input  logic                 rst_n,\n\n    // EX stage interface\n    input  logic                 ex_if_req_i,           // LSU request\n    input  logic                 ex_if_we_i,            // Write enable: 0 (load), 1 (store)\n    input  logic     [ 1:0]      ex_if_type_i,          // Data type: 0x2 (word), 0x1 (halfword), 0x0 (byte)\n    input  logic     [31:0]      ex_if_wdata_i,         // Data to write to memory\n    input  logic     [31:0]      ex_if_addr_base_i,     // Base address\n    input  logic     [31:0]      ex_if_addr_offset_i,   // Offset address\n    output logic                 ex_if_ready_o    ,\n    \n    // Writeback stage interface\n    output logic     [31:0]      wb_if_rdata_o,         // Requested data\n    output logic                 wb_if_rvalid_o,        // Requested data valid\n\n    // Data memory (DMEM) interface\n    output logic                 dmem_req_o,\n    input  logic                 dmem_gnt_i,\n    output logic     [31:0]      dmem_req_addr_o,\n    output logic                 dmem_req_we_o,\n    output logic     [ 3:0]      dmem_req_be_o,\n    output logic     [31:0]      dmem_req_wdata_o,\n    input  logic     [31:0]      dmem_rsp_rdata_i,\n    input  logic                 dmem_rvalid_i\n    );\n\n  // Internal signals\n  logic ex_req_fire;\n  logic dmem_req_we_q;\n  logic [31:0] data_addr_int;\n  logic misaligned_addr;\n  logic [3:0] dmem_be, dmem_req_be_q;\n\n  logic busy_q;  // Sticky busy bit: Set with EX req and cleared with DMEM response\n  logic dmem_req_q ;\n\n\n\n  \n  logic [31:0] dmem_req_wdata_q;\n  logic [31:0] dmem_req_addr_q;\n\n  logic [31:0] wb_if_rdata_q;\n  logic wb_if_rvalid_q;\n\n  // Address calculation\n  assign data_addr_int = ex_if_addr_base_i + ex_if_addr_offset_i;\n\n  // EX request fire condition\n  assign ex_req_fire = ex_if_req_i && !busy_q && !misaligned_addr;\n  assign ex_if_ready_o = !busy_q;\n\n  ///////////////////////////////// Byte Enable Generation ////////////////////////////////\n  always_comb begin\n    misaligned_addr = 1'b0;\n    dmem_be = 4'b0000;\n    case (ex_if_type_i)  // 0x2 (word), 0x1 (halfword), 0x0 (byte)\n      2'b00: begin  // Writing a byte\n          case (data_addr_int[1:0])\n            2'b00:   dmem_be = 4'b0001;\n            2'b01:   dmem_be = 4'b0010;\n            2'b10:   dmem_be = 4'b0100;\n            2'b11:   dmem_be = 4'b1000;\n            default: dmem_be = 4'b0000;\n          endcase\n      end\n\n      2'b01: begin  // Writing a half-word\n          case (data_addr_int[1:0])\n            2'b00:   dmem_be = 4'b0011;\n            2'b10:   dmem_be = 4'b1100;\n            default: begin\n                dmem_be = 4'b0000;\n                misaligned_addr = 1'b1;\n            end\n          endcase\n      end\n\n      2'b10: begin  // Writing a word\n          case (data_addr_int[1:0])\n            2'b00:   dmem_be = 4'b1111;\n            default: begin\n                dmem_be = 4'b0000;\n                misaligned_addr = 1'b1;\n            end\n          endcase\n      end\n      default: begin\n          dmem_be = 4'b0000;\n          misaligned_addr = 1'b1;\n      end \n    endcase\n  end\n\n  \n  ///////////////////////////////// dmem_req ////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n      dmem_req_q <= 1'b0;\n      dmem_req_addr_q <= '0;\n      dmem_req_we_q <= '0 ;\n      dmem_req_be_q <= '0 ;\n      dmem_req_wdata_q <= '0 ;\n    end else if (ex_req_fire) begin\n      dmem_req_q <= 1'b1;\n      dmem_req_addr_q <= data_addr_int;\n      dmem_req_we_q <= ex_if_we_i;\n      dmem_req_be_q <= dmem_be ;\n      dmem_req_wdata_q <= ex_if_wdata_i ;\n    end else if (dmem_req_q && dmem_gnt_i) begin\n      dmem_req_q <= 1'b0;  // request granted\n      dmem_req_addr_q <= '0 ;\n      dmem_req_we_q <= '0 ;\n      dmem_req_be_q <= '0 ;\n      dmem_req_wdata_q <= '0 ;\n    end\n  end\n  \n\n  ///////////////////////////////// DMEM Request Interface ////////////////////////////////\n  always_comb begin : dmem_req\n    dmem_req_o        = dmem_req_q;\n    dmem_req_addr_o   = dmem_req_addr_q;\n    dmem_req_we_o     = dmem_req_we_q;\n    dmem_req_be_o     = dmem_req_be_q;\n    dmem_req_wdata_o  = dmem_req_wdata_q;\n  end\n\n  ///////////////////////////////// Read Response Handling ////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n      wb_if_rdata_q   <= 32'b0;\n      wb_if_rvalid_q  <= 1'b0;\n    end else if (dmem_rvalid_i) begin\n      wb_if_rdata_q   <= dmem_rsp_rdata_i;\n      wb_if_rvalid_q  <= 1'b1;\n    end else begin\n      wb_if_rvalid_q  <= 1'b0;\n    end\n  end\n\n  assign wb_if_rdata_o =  wb_if_rdata_q;\n  assign wb_if_rvalid_o = wb_if_rvalid_q;\n\n  ///////////////////////////////// Busy Logic ////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n      busy_q <= 1'b0;\n    end else if (ex_req_fire) begin\n      busy_q <= 1'b1;\n    end else if (dmem_req_we_q && dmem_gnt_i) begin\n      busy_q <= 1'b0;  // Write request granted\n    end else if (!dmem_req_we_q && dmem_rvalid_i) begin\n      busy_q <= 1'b0;  // Read request response received\n    end\n  end\n  \nendmodule"}, "obj": true}}
{"cvdp_copilot_load_store_unit_0009": {"input": {"rtl/load_store_unit.sv": "module load_store_unit (\n    input  logic                 clk,\n    input  logic                 rst_n,\n\n    // EX stage interface\n    input  logic                 ex_if_req_i,           // LSU request\n    input  logic                 ex_if_we_i,            // Write enable: 0 (load), 1 (store)\n    input  logic     [ 1:0]      ex_if_type_i,          // Data type: 0x2 (word), 0x1 (halfword), 0x0 (byte)\n    input  logic     [31:0]      ex_if_wdata_i,         // Data to write to memory\n    input  logic     [31:0]      ex_if_addr_base_i,     // Base address\n    input  logic     [31:0]      ex_if_addr_offset_i,   // Offset address\n    input  logic                 ex_if_extend_mode_i,\n    output logic                 ex_if_ready_o    ,\n\n    \n    // Writeback stage interface\n    output logic     [31:0]      wb_if_rdata_o,         // Requested data\n    output logic                 wb_if_rvalid_o,        // Requested data valid\n\n    // Data memory (DMEM) interface\n    output logic                 dmem_req_o,\n    input  logic                 dmem_gnt_i,\n    output logic     [31:0]      dmem_req_addr_o,\n    output logic                 dmem_req_we_o,\n    output logic     [ 3:0]      dmem_req_be_o,\n    output logic     [31:0]      dmem_req_wdata_o,\n    input  logic     [31:0]      dmem_rsp_rdata_i,\n    input  logic                 dmem_rvalid_i\n    );\n\n  // Internal signals\n  logic ex_req_fire;\n  logic dmem_req_we_q;\n  logic [31:0] data_addr_int;\n  logic misaligned_addr;\n  logic [3:0] dmem_be, dmem_req_be_q;\n\n  logic busy_q;  \n  logic dmem_req_q ;\n\n\n\n  \n  logic [31:0] dmem_req_wdata_q;\n  logic [31:0] dmem_req_addr_q;\n\n  logic [31:0] wb_if_rdata_q;\n  logic wb_if_rvalid_q;\n\n  logic [1:0] rdata_offset_q ;\n  logic [31:0] rdata_w_ext , rdata_h_ext, rdata_b_ext, data_rdata_ext ;\n  logic [1:0] data_type_q ;\n  logic data_sign_ext_q ;\n\n  assign data_addr_int = ex_if_addr_base_i + ex_if_addr_offset_i;\n\n  assign ex_req_fire = ex_if_req_i && !busy_q && !misaligned_addr;\n  assign ex_if_ready_o = !busy_q;\n\n\n  always_comb begin\n    misaligned_addr = 1'b0;\n    dmem_be = 4'b0000;\n    case (ex_if_type_i)  \n      2'b00: begin  \n          case (data_addr_int[1:0])\n            2'b00:   dmem_be = 4'b0001;\n            2'b01:   dmem_be = 4'b0010;\n            2'b10:   dmem_be = 4'b0100;\n            2'b11:   dmem_be = 4'b1000;\n            default: dmem_be = 4'b0000;\n          endcase\n      end\n\n      2'b01: begin  \n          case (data_addr_int[1:0])\n            2'b00:   dmem_be = 4'b0011;\n            2'b10:   dmem_be = 4'b1100;\n            default: begin\n                dmem_be = 4'b0000;\n                misaligned_addr = 1'b1;\n            end\n          endcase\n      end\n\n      2'b10: begin  \n          case (data_addr_int[1:0])\n            2'b00:   dmem_be = 4'b1111;\n            default: begin\n                dmem_be = 4'b0000;\n                misaligned_addr = 1'b1;\n            end\n          endcase\n      end\n      default: begin\n          dmem_be = 4'b0000;\n          misaligned_addr = 1'b1;\n      end \n    endcase\n  end\n\n  \n  always_ff @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n      dmem_req_q <= 1'b0;\n      dmem_req_addr_q <= '0;\n      dmem_req_we_q <= '0 ;\n      dmem_req_be_q <= '0 ;\n      dmem_req_wdata_q <= '0 ;\n      rdata_offset_q <= '0 ;\n    end else if (ex_req_fire) begin\n      dmem_req_q <= 1'b1;\n      dmem_req_addr_q <= data_addr_int;\n      dmem_req_we_q <= ex_if_we_i;\n      dmem_req_be_q <= dmem_be ;\n      dmem_req_wdata_q <= ex_if_wdata_i ; \n\n      rdata_offset_q <= data_addr_int[1:0] ; \n      data_sign_ext_q <= ex_if_extend_mode_i ;\n      data_type_q <= ex_if_type_i ;\n    end else if (dmem_req_q && dmem_gnt_i) begin\n      dmem_req_q <= 1'b0;  \n      dmem_req_addr_q <= '0 ;\n      dmem_req_we_q <= '0 ;\n      dmem_req_be_q <= '0 ;\n      dmem_req_wdata_q <= '0 ;\n    end\n  end\n  \n  \n  \n  always_comb begin\n    case (rdata_offset_q)\n      2'b00: rdata_w_ext = dmem_rsp_rdata_i[31:0];\n      default: rdata_w_ext = '0 ;\n    endcase\n  end\n\n  always_comb begin\n    case (rdata_offset_q)\n      2'b00: begin\n        if (data_sign_ext_q) rdata_h_ext ={{16{dmem_rsp_rdata_i[15]}}, dmem_rsp_rdata_i[15:0]};\n        else rdata_h_ext =  {16'h0000, dmem_rsp_rdata_i[15:0]};\n      end\n\n      2'b10: begin\n        if (data_sign_ext_q) rdata_h_ext = {{16{dmem_rsp_rdata_i[31]}}, dmem_rsp_rdata_i[31:16]};\n        else rdata_h_ext = {16'h0000, dmem_rsp_rdata_i[31:16]}; \n      end\n\n      default: begin\n        rdata_h_ext = '0 ;  \n      end\n    endcase  \n  end\n  \n  always_comb begin\n    case (rdata_offset_q)\n      2'b00: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_rdata_i[7]}}, dmem_rsp_rdata_i[7:0]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_rdata_i[7:0]};\n      end\n\n      2'b01: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_rdata_i[15]}}, dmem_rsp_rdata_i[15:8]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_rdata_i[15:8]};\n      end\n\n      2'b10: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_rdata_i[23]}}, dmem_rsp_rdata_i[23:16]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_rdata_i[23:16]};\n      end\n\n      2'b11: begin\n        if (data_sign_ext_q) rdata_b_ext  = {{24{dmem_rsp_rdata_i[31]}}, dmem_rsp_rdata_i[31:24]}; \n        else rdata_b_ext = {24'h00_0000, dmem_rsp_rdata_i[31:24]};\n      end\n    endcase  \n  end\n\n  always_comb begin\n    case (data_type_q)\n      2'b00:        data_rdata_ext = rdata_b_ext ;\n      2'b01:        data_rdata_ext = rdata_h_ext;\n      2'b10:        data_rdata_ext = rdata_w_ext;\n      default:      data_rdata_ext = 32'b0;\n    endcase  \n  end\n\n\n  always_comb begin : dmem_req\n    dmem_req_o        = dmem_req_q;\n    dmem_req_addr_o   = dmem_req_addr_q;\n    dmem_req_we_o     = dmem_req_we_q;\n    dmem_req_be_o     = dmem_req_be_q;\n    dmem_req_wdata_o  = dmem_req_wdata_q;\n  end\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n      wb_if_rdata_q   <= 32'b0;\n      wb_if_rvalid_q  <= 1'b0;\n    end else if (dmem_rvalid_i) begin\n      wb_if_rdata_q   <= data_rdata_ext;\n      wb_if_rvalid_q  <= 1'b1;\n    end else begin\n      wb_if_rvalid_q  <= 1'b0;\n    end\n  end\n\n  assign wb_if_rdata_o =  wb_if_rdata_q;\n  assign wb_if_rvalid_o = wb_if_rvalid_q;\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n      busy_q <= 1'b0;\n    end else if (ex_req_fire) begin\n      busy_q <= 1'b1;\n    end else if (dmem_req_we_q && dmem_gnt_i) begin\n      busy_q <= 1'b0;  \n    end else if (!dmem_req_we_q && dmem_rvalid_i) begin\n      busy_q <= 1'b0;  \n    end\n  end\n  \nendmodule"}, "output": {"rtl/load_store_unit.sv": ""}, "obj": true}}
{"cvdp_copilot_manchester_enc_0005": {"input": {"docs/RTL_Summarization_top_manchester.md": "### High-Level & Detailed Specification for `top_manchester` Module\n\n#### 1. Module's Purpose and Overall Functionality\nThe `top_manchester` module integrates a Manchester encoder and decoder to facilitate the encoding and decoding of data using the Manchester coding scheme. This module is designed to transform N-bit data into 2N-bit Manchester encoded data and vice versa, making it suitable for communication protocols that require synchronization and error detection.\n\n#### 2. Input and Output Ports\n**Common Interfaces:**\n- **Clock Input (`clk_in`):** The module operates on the rising edge of this clock signal.\n- **Reset Input (`rst_in`):** An active high reset signal that initializes the module's outputs to zero and clears the valid signals.\n\n**Encoder Interfaces:**\n- **Input Valid Signal (`enc_valid_in`):** Indicates the validity of the encoder input data.\n- **Input Data (`enc_data_in`):** N-bit input data to be encoded.\n- **Output Valid Signal (`enc_valid_out`):** Indicates the validity of the encoder output data.\n- **Output Data (`enc_data_out`):** 2N-bit Manchester encoded output data.\n\n**Decoder Interfaces:**\n- **Input Valid Signal (`dec_valid_in`):** Indicates the validity of the decoder input data.\n- **Input Data (`dec_data_in`):** 2N-bit Manchester encoded input data to be decoded.\n- **Output Valid Signal (`dec_valid_out`):** Indicates the validity of the decoder output data.\n- **Output Data (`dec_data_out`):** N-bit decoded output data.\n\n#### 3. Module's Components\n- **Manchester Encoder (`manchester_encoder`):**\n  - Converts N-bit input data into 2N-bit Manchester encoded data.\n  - Each bit of the input data is encoded into two bits: a '1' is encoded as '10', and a '0' is encoded as '01'.\n  - Asserts `enc_valid_out` when the encoded data is valid.\n\n- **Manchester Decoder (`manchester_decoder`):**\n  - Converts 2N-bit Manchester encoded input data back into N-bit decoded data.\n  - Each pair of encoded bits is decoded back into a single bit: '10' is decoded as '1', and '01' is decoded as '0'.\n  - Asserts `dec_valid_out` when the decoded data is valid.\n\n#### 4. Encoding and Decoding\n- **Encoding Process:**\n  - On the rising edge of `clk_in`, if `enc_valid_in` is high, the encoder processes `enc_data_in`.\n  - Each bit of `enc_data_in` is transformed into a pair of bits according to the Manchester coding scheme.\n  - The resulting 2N-bit encoded data is assigned to `enc_data_out`, and `enc_valid_out` is asserted.\n\n- **Decoding Process:**\n  - On the rising edge of `clk_in`, if `dec_valid_in` is high, the decoder processes `dec_data_in`.\n  - Each pair of bits in `dec_data_in` is transformed back into a single bit according to the Manchester coding scheme.\n  - The resulting N-bit decoded data is assigned to `dec_data_out`, and `dec_valid_out` is asserted.\n\n#### 5. Module Behavior\n- **During Reset (`rst_in` high):**\n  - All outputs (`enc_data_out`, `enc_valid_out`, `dec_data_out`, `dec_valid_out`) are reset to zero.\n\n- **When Valid Data is Present:**\n  - If `enc_valid_in` is high, the encoder processes `enc_data_in` and produces valid `enc_data_out` with `enc_valid_out` asserted.\n  - If `dec_valid_in` is high, the decoder processes `dec_data_in` and produces valid `dec_data_out` with `dec_valid_out` asserted.\n\n- **When Valid Data is Not Present:**\n  - Both `enc_valid_out` and `dec_valid_out` are cleared to indicate that the outputs are not valid.\n\n### Summary\nThe `top_manchester` module serves as an integration point for a Manchester encoder and decoder, enabling the transformation of N-bit data into 2N-bit Manchester encoded data and vice versa. It includes interfaces for clock, reset, and valid signals for both encoding and decoding processes. The module's components, the Manchester encoder and decoder, handle the actual encoding and decoding according to the Manchester coding scheme. The module's behavior is defined by its response to reset conditions and the presence or absence of valid input data.", "rtl/manchester_decoder.sv": "// Manchester decoder module\nmodule manchester_decoder #(\n    parameter N = 8  // Default width of output data\n) (\n    input  logic clk_in,          // Clock input\n    input  logic rst_in,          // Active high reset input\n    input  logic dec_valid_in,        // Input valid signal\n    input  logic [2*N-1:0] dec_data_in, // 2N-bit Manchester encoded input data\n    output logic dec_valid_out,       // Output valid signal\n    output logic [N-1:0] dec_data_out  // N-bit output decoded data\n);\n\n    // Internal register to hold the decoded data\n    logic [N-1:0] decoded_data;\n\n    // Sequential logic to generate decoded data from Manchester encoded data\n    always_ff @(posedge clk_in or posedge rst_in) begin\n        if (rst_in) begin\n            dec_data_out <= '0; // Reset the output to zero\n            dec_valid_out <= 1'b0; // Reset the valid signal\n        end else if (dec_valid_in) begin\n            dec_data_out <= '0; // Initialize to zero\n            for (int i = 0; i < N; i++) begin\n                if (dec_data_in[2*i] == 1'b1 && dec_data_in[2*i + 1] == 1'b0) begin\n                    dec_data_out[i] <= 1'b1;\n                end else if (dec_data_in[2*i] == 1'b0 && dec_data_in[2*i + 1] == 1'b1) begin\n                    dec_data_out[i] <= 1'b0;\n                end else begin\n                    dec_data_out[i] <= 1'b0; // Default to 0 if invalid Manchester code\n                end\n            end\n            dec_valid_out <= 1'b1; // Set the valid signal\n        end else begin\n            dec_valid_out <= 1'b0; // Clear the valid signal if no valid input\n        end\n    end\n\nendmodule", "rtl/manchester_encoder.sv": "\n// Manchester encoder module\nmodule manchester_encoder #(\n    parameter N = 8  // Default width of input data\n) (\n    input  logic clk_in,          // Clock input\n    input  logic rst_in,          // Active high reset input\n    input  logic enc_valid_in,        // Input valid signal\n    input  logic [N-1:0] enc_data_in, // N-bit input data\n    output logic enc_valid_out,       // Output valid signal\n    output logic [2*N-1:0] enc_data_out // 2N-bit output encoded data\n);\n\n    // Internal register to hold the encoded data\n    logic [2*N-1:0] encoded_data;\n\n    // Combinational logic to generate Manchester encoded data\n    always_comb begin\n        if (enc_valid_in) begin\n            for (int i = 0; i < N; i++) begin\n                if (enc_data_in[i] == 1'b1) begin\n                    enc_data_out[2*i] = 1'b1;\n                    enc_data_out[2*i + 1] = 1'b0;\n                end else begin\n                    enc_data_out[2*i] = 1'b0;\n                    enc_data_out[2*i + 1] = 1'b1;\n                end\n            end\n            enc_valid_out = 1'b1; // Set the valid signal\n        end else begin\n            enc_valid_out = 1'b0; // Clear the valid signal if no valid input\n        end\n    end\n\nendmodule\n", "rtl/top_manchester.sv": "// Top Module integrating Encoder & decoder\nmodule top_manchester #(\n    parameter N = 8  // Default width of input and output data\n) (\n    input  logic clk_in,          // Clock input\n    input  logic rst_in,          // Active high reset input\n    // Encoder Signals\n    input  logic enc_valid_in,        // Input valid signal\n    input  logic [N-1:0] enc_data_in, // N-bit input data\n    output logic enc_valid_out,       // output valid signal\n    output logic [2*N-1:0] enc_data_out, // 2*N-bit encoder output data\n    \n    // Decoder Signals\n    input  logic dec_valid_in,        // Input valid signal\n    input  logic [2*N-1:0] dec_data_in, // 2*N-bit input data\n    output logic dec_valid_out,       // Output valid signal\n    output logic [N-1:0] dec_data_out // N-bit output decoded data\n);\n\n    // Instantiate the Manchester encoder module\n    manchester_encoder #(\n        .N(N)\n    ) encoder_dut (\n        .clk_in(clk_in),\n        .rst_in(rst_in),\n        .enc_valid_in(enc_valid_in),\n        .enc_data_in(enc_data_in),\n        .enc_valid_out(enc_valid_out),\n        .enc_data_out(enc_data_out)\n    );\n\n    // Instantiate the Manchester decoder module\n    manchester_decoder #(\n        .N(N)\n    ) decoder_dut (\n        .clk_in(clk_in),\n        .rst_in(rst_in),\n        .dec_valid_in(dec_valid_in),\n        .dec_data_in(dec_data_in),\n        .dec_valid_out(dec_valid_out),\n        .dec_data_out(dec_data_out)\n    );\n\nendmodule"}, "output": {"rtl/manchester_encoder.sv": "\n// Manchester encoder module\nmodule manchester_encoder #(\n    parameter N = 8  // Default width of input data\n) (\n    input  logic clk_in,          // Clock input\n    input  logic rst_in,          // Active high reset input\n    input  logic enc_valid_in,        // Input valid signal\n    input  logic [N-1:0] enc_data_in, // N-bit input data\n    output logic enc_valid_out,       // Output valid signal\n    output logic [2*N-1:0] enc_data_out // 2N-bit output encoded data\n);\n\n    // Internal register to hold the encoded data\n    logic [2*N-1:0] encoded_data;\n\n    // Combinational logic to generate Manchester encoded data\n    always_comb begin\n        if (enc_valid_in) begin\n            for (int i = 0; i < N; i++) begin\n                if (enc_data_in[i] == 1'b1) begin\n                    enc_data_out[2*i] = 1'b1;\n                    enc_data_out[2*i + 1] = 1'b0;\n                end else begin\n                    enc_data_out[2*i] = 1'b0;\n                    enc_data_out[2*i + 1] = 1'b1;\n                end\n            end\n            enc_valid_out = 1'b1; // Set the valid signal\n        end else begin\n            enc_valid_out = 1'b0; // Clear the valid signal if no valid input\n        end\n    end\n\nendmodule\n"}, "obj": true}}
{"cvdp_copilot_manchester_enc_0013": {"input": {"rtl/top_manchester.sv": "module top_manchester #(\n    parameter N = 8  // Default width of input and output data\n) (\n    input  logic clk_in,          // Clock input\n    input  logic rst_in,          // Active high reset input\n    // Encoder Signals\n    input  logic enc_valid_in,    // Input valid signal\n    input  logic [N-1:0] enc_data_in, // N-bit input data\n    output logic enc_valid_out,   // Output valid signal\n    output logic [2*N-1:0] enc_data_out, // 2*N-bit encoder output data\n    \n    // Decoder Signals\n    input  logic dec_valid_in,    // Input valid signal\n    input  logic [2*N-1:0] dec_data_in, // 2*N-bit input data\n    output logic dec_valid_out,   // Output valid signal\n    output logic [N-1:0] dec_data_out // N-bit output decoded data\n);\n\n    manchester_encoder #(\n        .N(N)\n    ) encoder_dut (\n        .clk_in(clk_in),\n        .rst_in(rst_in),\n        .enc_valid_in(enc_valid_in),\n        .enc_data_in(enc_data_in),\n        .enc_valid_out(enc_valid_out),\n        .enc_data_out(enc_data_out)\n    );\n\n    manchester_decoder #(\n        .N(N)\n    ) decoder_dut (\n        .clk_in(clk_in),\n        .rst_in(rst_in),\n        .dec_valid_in(dec_valid_in),\n        .dec_data_in(dec_data_in),\n        .dec_valid_out(dec_valid_out),\n        .dec_data_out(dec_data_out)\n    );\n\nendmodule\n\nmodule manchester_encoder #(\n    parameter N = 8  // Default width of input data\n) (\n    input  logic clk_in,          // Clock input\n    input  logic rst_in,          // Active high reset input\n    input  logic enc_valid_in,    // Input valid signal\n    input  logic [N-1:0] enc_data_in, // N-bit input data\n    output logic enc_valid_out,   // Output valid signal\n    output logic [2*N-1:0] enc_data_out // 2N-bit output encoded data\n);\n\n    logic [2*N-1:0] encoded_data;\n    logic encoded_data_valid;\n\n    always_ff @(posedge clk_in) begin\n        if (rst_in) begin\n            enc_data_out = '0; \n            enc_valid_out <= 1'b0; \n        end else if (enc_valid_in) begin\n            for (int i = 0; i < N; i++) begin\n                if (enc_data_in[i] == 1'b1) begin\n                    enc_data_out[2*i]   = 1'b1;\n                    enc_data_out[2*i+1] = 1'b0;\n                end else begin\n                    enc_data_out[2*i]   = 1'b0;\n                    enc_data_out[2*i+1] = 1'b1;\n                end\n            end\n            enc_valid_out <= 1'b1;\n        end else begin\n            enc_data_out = 'd0;\n            enc_valid_out <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule manchester_decoder #(\n    parameter N = 8  // Default width of output data\n) (\n    input  logic clk_in,          // Clock input\n    input  logic rst_in,          // Active high reset input\n    input  logic dec_valid_in,    // Input valid signal\n    input  logic [2*N-1:0] dec_data_in, // 2N-bit Manchester encoded input data\n    output logic dec_valid_out,   // Output valid signal\n    output logic [N-1:0] dec_data_out  // N-bit output decoded data\n);\n\n    logic [N-1:0] decoded_data;\n    logic decoded_data_valid;\n\n    always_ff @(posedge clk_in) begin\n        if (rst_in) begin\n            dec_data_out <= '0; \n            dec_valid_out = 1'b0;\n        end else if (dec_valid_in) begin\n            for (int i = 0; i < N; i++) begin\n                if (dec_data_in[2*i] == 1'b1 && dec_data_in[2*i+1] == 1'b0) begin\n                    dec_data_out[i] <= 1'b1;\n                end else if (dec_data_in[2*i] == 1'b0 && dec_data_in[2*i+1] == 1'b1) begin\n                    dec_data_out[i] <= 1'b0;\n                end else begin\n                    dec_data_out[i] <= 1'b0;\n                end\n            end\n            dec_valid_out = 1'b1;\n        end else begin\n            dec_data_out <= '0;\n            dec_valid_out = 1'b0;\n        end\n    end\n\nendmodule"}, "output": {"rtl/top_manchester.sv": ""}, "obj": true}}
{"cvdp_copilot_matrix_multiplier_0001": {"input": {}, "output": {"rtl/matrix_multiplier.sv": ""}, "obj": true}}
{"cvdp_copilot_matrix_multiplier_0007": {"input": {"rtl/matrix_multiplier.sv": "module matrix_multiplier #(\n  parameter ROW_A             = 4                                                   , // Number of rows in matrix A\n  parameter COL_A             = 4                                                   , // Number of columns in matrix A\n  parameter ROW_B             = 4                                                   , // Number of rows in matrix B\n  parameter COL_B             = 4                                                   , // Number of columns in matrix B\n  parameter INPUT_DATA_WIDTH  = 8                                                   , // Bit-width of input data\n  parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(COL_A)                // Bit-width of output data\n) (\n  input  logic [ (ROW_A*COL_A*INPUT_DATA_WIDTH)-1:0] matrix_a, // Input matrix A in 1D form\n  input  logic [ (ROW_B*COL_B*INPUT_DATA_WIDTH)-1:0] matrix_b, // Input matrix B in 1D form\n  output logic [(ROW_A*COL_B*OUTPUT_DATA_WIDTH)-1:0] matrix_c  // Output matrix C in 1D form\n);\n  genvar gv1;\n  genvar gv2;\n  genvar gv3;\n\n  generate\n      logic [(ROW_A*COL_B*COL_A*OUTPUT_DATA_WIDTH)-1:0] matrix_c_stage; // Temporary storage for intermediate results\n\n      for (gv1 = 0 ; gv1 < ROW_A ; gv1++) begin: row_a_gb\n        for (gv2 = 0 ; gv2 < COL_B ; gv2++) begin: col_b_gb\n          for (gv3 = 0 ; gv3 < COL_A ; gv3++) begin: col_a_gb\n            if (gv3 == 0)\n              assign matrix_c_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] = matrix_a[((gv1*COL_A)+gv3)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] * matrix_b[((gv3*COL_B)+gv2)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH];\n            else\n              assign matrix_c_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] = matrix_c_stage[((((gv1*COL_B)+gv2)*COL_A)+(gv3-1))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] + (matrix_a[((gv1*COL_A)+gv3)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] * matrix_b[((gv3*COL_B)+gv2)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH]);\n          end\n          // Assign the final result for matrix_c\n          assign matrix_c[((gv1*COL_B)+gv2)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] = matrix_c_stage[((((gv1*COL_B)+gv2)*COL_A)+(COL_A-1))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH];\n        end\n      end\n\n  endgenerate\n\nendmodule"}, "output": {"rtl/matrix_multiplier.sv": "module matrix_multiplier #(\n  parameter ROW_A             = 4                                                   , // Number of rows in matrix A\n  parameter COL_A             = 4                                                   , // Number of columns in matrix A\n  parameter ROW_B             = 4                                                   , // Number of rows in matrix B\n  parameter COL_B             = 4                                                   , // Number of columns in matrix B\n  parameter INPUT_DATA_WIDTH  = 8                                                   , // Bit-width of input data\n  parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(COL_A)                // Bit-width of output data\n) (\n  input  logic [ (ROW_A*COL_A*INPUT_DATA_WIDTH)-1:0] matrix_a, // Input matrix A in 1D form\n  input  logic [ (ROW_B*COL_B*INPUT_DATA_WIDTH)-1:0] matrix_b, // Input matrix B in 1D form\n  output logic [(ROW_A*COL_B*OUTPUT_DATA_WIDTH)-1:0] matrix_c  // Output matrix C in 1D form\n);\n  genvar gv1;\n  genvar gv2;\n  genvar gv3;\n\n  generate\n      logic [(ROW_A*COL_B*COL_A*OUTPUT_DATA_WIDTH)-1:0] matrix_c_stage; // Temporary storage for intermediate results\n\n      for (gv1 = 0 ; gv1 < ROW_A ; gv1++) begin: row_a_gb\n        for (gv2 = 0 ; gv2 < COL_B ; gv2++) begin: col_b_gb\n          for (gv3 = 0 ; gv3 < COL_A ; gv3++) begin: col_a_gb\n            if (gv3 == 0)\n              assign matrix_c_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] = matrix_a[((gv1*COL_A)+gv3)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] * matrix_b[((gv3*COL_B)+gv2)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH];\n            else\n              assign matrix_c_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] = matrix_c_stage[((((gv1*COL_B)+gv2)*COL_A)+(gv3-1))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] + (matrix_a[((gv1*COL_A)+gv3)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] * matrix_b[((gv3*COL_B)+gv2)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH]);\n          end\n          // Assign the final result for matrix_c\n          assign matrix_c[((gv1*COL_B)+gv2)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] = matrix_c_stage[((((gv1*COL_B)+gv2)*COL_A)+(COL_A-1))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH];\n        end\n      end\n\n  endgenerate\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_matrix_multiplier_0010": {"input": {"docs/matrix_multiplier_design_document.md": "# Matrix Multiplier Design Document\n\n## Introduction\n\nThe `matrix_multiplier` module is a parameterized SystemVerilog design that performs matrix multiplication over multiple clock cycles. It supports matrices with configurable dimensions, unsigned inputs, and a fixed multi-cycle latency. The design structure consists of three main computational stages: multiplication, accumulation, and output. This approach improves timing performance, making the design scalable for larger matrices, with the total latency of each multiplication operation being **`COL_A + 2` clock cycles**.\n\n---\n\n## Specifications for `matrix_multiplier` Module\n\n### Inputs\n\n- **clk**: Clock signal used to synchronize the computational stages.\n- **srst**: Active-high synchronous reset. When high, it clears internal registers and outputs.\n- **valid_in**: An active-high signal indicating that the input matrices are valid and ready to be processed.\n- **matrix_a[(ROW_A x COL_A x INPUT_DATA_WIDTH) -1 : 0]**: Flattened input matrix A, containing unsigned elements.\n- **matrix_b[(ROW_B x COL_B x INPUT_DATA_WIDTH) -1 : 0]**: Flattened input matrix B, containing unsigned elements.\n\n### Outputs\n\n- **valid_out**: An active-high signal indicating that the output matrix `matrix_c` is valid and ready.\n- **matrix_c[(ROW_A x COL_B x OUTPUT_DATA_WIDTH) -1 : 0]**: Flattened output matrix C, containing unsigned elements with the final results of the matrix multiplication. The output updates along with `valid_out` assertion.\n\n### Parameters\n\n- **ROW_A**: Number of rows in `matrix_a`. Default value: 4.\n- **COL_A**: Number of columns in `matrix_a`. Default value: 4.\n- **ROW_B**: Number of rows in `matrix_b`, which must be equal to `COL_A`. Default value: 4.\n- **COL_B**: Number of columns in `matrix_b`. Default value: 4.\n- **INPUT_DATA_WIDTH**: Bit-width of each unsigned input element in the matrices. Default value: 8.\n- **OUTPUT_DATA_WIDTH**: Bit-width of each element in `matrix_c`, calculated as `(INPUT_DATA_WIDTH * 2) + $clog2(COL_A)` to handle potential overflow during accumulation.\n\n### Design Details\n\nThe design operates across three main computational stages: **Multiplication**, **Accumulation**, and **Output**. Each stage processes data over a series of clock cycles to complete the matrix multiplication operation.\n\n### Computational Stages\n\n1. **Multiplication Stage**: \n   - In the **multiplication stage**, the module computes the unsigned products of all corresponding elements from `matrix_a` and `matrix_b` in 1 clock cycle. These results are stored in intermediate registers. \n\n2. **Accumulation Stage**: \n   - In the **accumulation stage**, the module adds the unsigned products across multiple cycles (over `COL_A` clock cycles) to obtain the final values for each element in `matrix_c`.\n\n3. **Output Stage**: \n   - In the output stage, the accumulated results in `add_stage` are transferred to `matrix_c`. The module asserts `valid_out`, signaling that the output matrix is ready. The `valid_out` signal aligns with `matrix_c` after the fixed latency of **`COL_A + 2` clock cycles**.\n\n### Valid Signal Propagation\n\nThe `valid_in` signal initiates the computation process and propagates through a shift register (`valid_out_reg`) to synchronize with the computation stages. This shift register delays `valid_out` by **`COL_A + 2` clock cycles**, aligning it with the availability of the final output matrix `matrix_c`. This delay mechanism ensures that `valid_out` asserts only when `matrix_c` is ready.\n\n### Reset Behavior\n\nWhen the synchronous reset (`srst`) is asserted, all registers (including intermediate multiplication and accumulation registers) and the outputs are reset to their initial state of 0 on the next rising clock edge.\n\n---\n\n### Example of Matrix Flattening:\n\nSuppose you have two input matrices A and B to multiply:\n\n- **Matrix A (2x3)**:\n\n```text\n| a11  a12  a13 |\n| a21  a22  a23 |\n```\n\n- **Matrix B (3x2)**:\n\n```text\n| b11  b12 |\n| b21  b22 |\n| b31  b32 |\n```\n\nThe resulting output matrix from the multiplication of the above matrices would be:\n\n- **Matrix C (2x2)**:\n\n```text\n| c11  c12 |\n| c21  c22 |\n```\n\nThe flattened representation of these matrices will be as follows:\n\n- **Flattened Matrix A (2x3)**:\n\n```text\nmatrix_a = {a23, a22, a21, a13, a12, a11}\n```\n\n- **Flattened Matrix B (3x2)**:\n\n```text\nmatrix_b = {b32, b31, b22, b21, b12, b11}\n```\n\n- **Flattened Matrix C (2x2)**:\n\n```text\nmatrix_c = {c22, c21, c12, c11}\n```\n\n### Timing and Synchronization:\n- **Clock Signal:** All stages (multiplication, accumulation, and output) should be synchronized to the rising edge of the clock (`clk`).\n- **Latency:** The total latency from `valid_in` to `valid_out` should be **`COL_A + 2` cycles** .\n\n### Constraints:\n- **Input Control:** New inputs will only be applied from the next cycle following the assertion of `valid_out`, signaling that the module is ready for a new calculation.", "rtl/matrix_multiplier.sv": "module matrix_multiplier #(\n  parameter ROW_A             = 4                                                   , // Number of rows in matrix A\n  parameter COL_A             = 4                                                   , // Number of columns in matrix A\n  parameter ROW_B             = 4                                                   , // Number of rows in matrix B\n  parameter COL_B             = 4                                                   , // Number of columns in matrix B\n  parameter INPUT_DATA_WIDTH  = 8                                                   , // Bit-width of input data\n  parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(COL_A)                // Bit-width of output data\n) (\n  input  logic                                       clk      , // Clock input\n  input  logic                                       srst     , // Active-high Synchronous reset\n  input  logic                                       valid_in , // Indicates valid input matrices\n  input  logic [ (ROW_A*COL_A*INPUT_DATA_WIDTH)-1:0] matrix_a , // Input matrix A in 1D form\n  input  logic [ (ROW_B*COL_B*INPUT_DATA_WIDTH)-1:0] matrix_b , // Input matrix B in 1D form\n  output logic                                       valid_out, // Indicates valid output matrix\n  output logic [(ROW_A*COL_B*OUTPUT_DATA_WIDTH)-1:0] matrix_c   // Output matrix C in 1D form\n);\n  genvar gv1;\n  genvar gv2;\n  genvar gv3;\n\n  generate\n    logic [                                  COL_A:0] valid_out_reg; // Pipeline valid signal shift register\n    logic [(ROW_A*COL_B*COL_A*OUTPUT_DATA_WIDTH)-1:0] mult_stage   ; // Intermediate multiplication results\n    logic [(ROW_A*COL_B*COL_A*OUTPUT_DATA_WIDTH)-1:0] add_stage    ; // Accumulated addition results\n\n    always_ff @(posedge clk)\n      if (srst)\n        {valid_out, valid_out_reg} <= '0;\n      else\n        {valid_out, valid_out_reg} <= {valid_out_reg, valid_in}; \n\n    for (gv1 = 0 ; gv1 < ROW_A ; gv1++) begin: row_a_gb\n      for (gv2 = 0 ; gv2 < COL_B ; gv2++) begin: col_b_gb\n        for (gv3 = 0 ; gv3 < COL_A ; gv3++) begin: col_a_gb\n          always_ff @(posedge clk)\n            if (srst)\n              mult_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; \n            else\n              mult_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= matrix_a[((gv1*COL_A)+gv3)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] * matrix_b[((gv3*COL_B)+gv2)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH]; \n\n          \n          always_ff @(posedge clk)\n            if (srst)\n              add_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; \n            else if (gv3 == 0)\n              add_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH];\n            else\n              add_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] + add_stage[((((gv1*COL_B)+gv2)*COL_A)+(gv3-1))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH];\n        end\n\n        \n        always_ff @(posedge clk)\n          if (srst)\n            matrix_c[((gv1*COL_B)+gv2)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; // Reset output matrix element\n          else if (valid_out_reg[COL_A])\n            matrix_c[((gv1*COL_B)+gv2)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= add_stage[((((gv1*COL_B)+gv2)*COL_A)+(COL_A-1))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH]; // Set output to the accumulated result\n      end\n    end\n\n  endgenerate\n\nendmodule"}, "output": {"rtl/matrix_multiplier.sv": "module matrix_multiplier #(\n  parameter ROW_A             = 4                                                   , // Number of rows in matrix A\n  parameter COL_A             = 4                                                   , // Number of columns in matrix A\n  parameter ROW_B             = 4                                                   , // Number of rows in matrix B\n  parameter COL_B             = 4                                                   , // Number of columns in matrix B\n  parameter INPUT_DATA_WIDTH  = 8                                                   , // Bit-width of input data\n  parameter OUTPUT_DATA_WIDTH = (INPUT_DATA_WIDTH * 2) + $clog2(COL_A)                // Bit-width of output data\n) (\n  input  logic                                       clk      , // Clock input\n  input  logic                                       srst     , // Active-high Synchronous reset\n  input  logic                                       valid_in , // Indicates valid input matrices\n  input  logic [ (ROW_A*COL_A*INPUT_DATA_WIDTH)-1:0] matrix_a , // Input matrix A in 1D form\n  input  logic [ (ROW_B*COL_B*INPUT_DATA_WIDTH)-1:0] matrix_b , // Input matrix B in 1D form\n  output logic                                       valid_out, // Indicates valid output matrix\n  output logic [(ROW_A*COL_B*OUTPUT_DATA_WIDTH)-1:0] matrix_c   // Output matrix C in 1D form\n);\n  genvar gv1;\n  genvar gv2;\n  genvar gv3;\n\n  generate\n    logic [                                  COL_A:0] valid_out_reg; // Pipeline valid signal shift register\n    logic [(ROW_A*COL_B*COL_A*OUTPUT_DATA_WIDTH)-1:0] mult_stage   ; // Intermediate multiplication results\n    logic [(ROW_A*COL_B*COL_A*OUTPUT_DATA_WIDTH)-1:0] add_stage    ; // Accumulated addition results\n\n    always_ff @(posedge clk)\n      if (srst)\n        {valid_out, valid_out_reg} <= '0;\n      else\n        {valid_out, valid_out_reg} <= {valid_out_reg, valid_in}; \n\n    for (gv1 = 0 ; gv1 < ROW_A ; gv1++) begin: row_a_gb\n      for (gv2 = 0 ; gv2 < COL_B ; gv2++) begin: col_b_gb\n        for (gv3 = 0 ; gv3 < COL_A ; gv3++) begin: col_a_gb\n          always_ff @(posedge clk)\n            if (srst)\n              mult_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; \n            else\n              mult_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= matrix_a[((gv1*COL_A)+gv3)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH] * matrix_b[((gv3*COL_B)+gv2)*INPUT_DATA_WIDTH+:INPUT_DATA_WIDTH]; \n\n          \n          always_ff @(posedge clk)\n            if (srst)\n              add_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; \n            else if (gv3 == 0)\n              add_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH];\n            else\n              add_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= mult_stage[((((gv1*COL_B)+gv2)*COL_A)+gv3)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] + add_stage[((((gv1*COL_B)+gv2)*COL_A)+(gv3-1))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH];\n        end\n\n        \n        always_ff @(posedge clk)\n          if (srst)\n            matrix_c[((gv1*COL_B)+gv2)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= '0; // Reset output matrix element\n          else if (valid_out_reg[COL_A])\n            matrix_c[((gv1*COL_B)+gv2)*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH] <= add_stage[((((gv1*COL_B)+gv2)*COL_A)+(COL_A-1))*OUTPUT_DATA_WIDTH+:OUTPUT_DATA_WIDTH]; // Set output to the accumulated result\n      end\n    end\n\n  endgenerate\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_mem_allocator_0001": {"input": {}, "output": {"rtl/cvdp_copilot_mem_allocator.sv": ""}, "obj": true}}
{"cvdp_copilot_microcode_sequencer_0001": {"input": {}, "output": {"rtl/microcode_sequencer.sv": ""}, "obj": true}}
{"cvdp_copilot_modified_booth_mul_0002": {"input": {"rtl/signed_sequential_booth_multiplier.sv": "module signed_sequential_booth_multiplier #(parameter WIDTH = 8) (\n    input  wire signed [WIDTH-1:0] A,\n    input  wire signed [WIDTH-1:0] B,\n    input  wire clk,\n    input  wire rst,\n    input  wire start,\n    output reg  signed [2*WIDTH-1:0] result,\n    output reg done\n);\n\n    // FSM states\n    typedef enum logic [2:0] {\n        IDLE     = 3'b000,\n        ENCODE   = 3'b001, \n        PARTIAL  = 3'b010, \n        ADDITION = 3'b011, \n        DONE     = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n\n    // Registers for control and data signals\n    reg signed [2*WIDTH-1:0] partial_products [0:WIDTH/2-1];\n    reg signed [2*WIDTH-1:0] multiplicand;\n    reg signed [WIDTH:0] booth_bits; \n    reg signed [2*WIDTH-1:0] accumulator;  \n    reg [2:0] encoding_bits [0:WIDTH/2-1];\n    reg [$clog2(WIDTH/2):0] addition_counter; // Counter for addition cycles\n    integer i;\n\n    // State machine: Sequential process for state transitions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // State machine: Combinational process for next-state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start) begin\n                    next_state = ENCODE;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n\n            ENCODE: begin\n                next_state = PARTIAL;\n            end\n\n            PARTIAL: begin\n                next_state = ADDITION;\n            end\n\n            ADDITION: begin\n                next_state = DONE;\n            end\n\n            DONE: begin\n                if (!start) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DONE;\n                end\n            end\n\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Signal assignments: Perform operations based on current state\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            result <= 0;\n            accumulator <= 0;\n            addition_counter <= 0;\n            multiplicand <= 0;\n            booth_bits <= 0;\n            for (i = 0; i < WIDTH/2; i = i + 1) begin\n                encoding_bits[i] <= 0;\n                partial_products[i] <= 0;\n            end\n        end else begin\n            case (state)\n                IDLE: begin\n                    // Prepare for new computation\n                    done <= 0;\n                    result <= 0;\n                    if (start) begin\n                        multiplicand <= {{(WIDTH){A[WIDTH-1]}}, A}; // Sign-extend A\n                        booth_bits <= {B, 1'b0};\n                        accumulator <= 0;\n                        for (i = 0; i < WIDTH/2; i = i + 1) begin\n                            partial_products[i] <= 0;\n                        end\n                    end\n                end\n\n                ENCODE: begin\n                    // Extract 3-bit Booth segments\n                    for (i = 0; i < WIDTH/2; i = i + 1) begin\n                        encoding_bits[i] <= booth_bits[2*i +: 3];\n                    end\n                end\n\n                PARTIAL: begin\n                    // Generate partial products based on Booth encoding\n                    for (i = 0; i < WIDTH/2; i = i + 1) begin\n                        case (encoding_bits[i])\n                            3'b001, 3'b010: partial_products[i] <= (multiplicand << (2 * i));\n                            3'b011:         partial_products[i] <= ((multiplicand << 1) << (2 * i));\n                            3'b100:         partial_products[i] <= -((multiplicand << 1) << (2 * i));\n                            3'b101, 3'b110: partial_products[i] <= -(multiplicand << (2 * i));\n                            default:        partial_products[i] <= 0;\n                        endcase\n                    end\n                end\n\n                ADDITION: begin\n                    accumulator <= 0;\n                    for (i = 0; i < WIDTH/2; i = i + 1) begin\n                      accumulator <= accumulator + partial_products[i];  \n                    end\n                end\n\n                DONE: begin\n                    // Output the result\n                    result <= accumulator;\n                    done <= 1;\n                end\n            endcase\n        end\n    end\nendmodule"}, "output": {"rtl/signed_sequential_booth_multiplier.sv": ""}, "obj": true}}
{"cvdp_copilot_modified_booth_mul_0005": {"input": {"rtl/pipelined_modified_booth_multiplier.sv": "module pipelined_modified_booth_multiplier (\n    input clk,\n    input rst,\n    input start,\n    input signed [15:0] X,\n    input signed [15:0] Y,\n    output reg signed  [31:0] result,\n    output reg done\n);\n\n    reg signed [31:0] partial_products [0:7];\n    reg signed [15:0] X_reg, Y_reg;\n    reg [4:0] valid_reg; // Extended valid register for more granular state control\n\n    integer i;\n\n    // Registers for pipelining the addition stages\n    reg signed [31:0] s1, s2, s3, s4;\n    reg signed [31:0] temp_products1, temp_products2;\n\n    always @(posedge clk or posedge rst) \n    begin\n        if (rst) \n        begin\n            X_reg <= 16'd0;\n            Y_reg <= 16'd0;\n            valid_reg <= 5'd0;\n            done <= 0;\n            for (i = 0; i < 8; i = i + 1) \n            begin\n                partial_products[i] <= 32'd0;\n            end\n            s1 <= 0; s2 <= 0; s3 <= 0; s4 <= 0;\n            temp_products1 <= 0; temp_products2 <= 0;\n            result <= 32'd0;\n            done <= 1'b0;\n        end \n        else \n        begin\n            if (start && !valid_reg[0]) begin\n                X_reg <= X;\n                Y_reg <= Y;\n                valid_reg[0] <= 1;  // Initiate state 1\n            end\n            else\n              valid_reg[0] <= 0;  // Initiate state 1 \n\n            // Process Booth multiplication\n            if (valid_reg[0]) begin\n                for (i = 0; i < 8; i = i + 1) begin\n                    case ({Y_reg[2*i+1], Y_reg[2*i], (i == 0) ? 1'b0 : Y_reg[2*i-1]})\n                        3'b000, 3'b111: partial_products[i] <= 32'd0;\n                        3'b001, 3'b010: partial_products[i] <= {{16{X_reg[15]}}, X_reg} >> (2*i);\n                        3'b011: partial_products[i] <= {{16{X_reg[15]}}, X_reg} >> (2*i + 1);\n                        3'b100: partial_products[i] <= -({{16{X_reg[15]}}, X_reg} >> (2*i + 1));\n                        3'b101, 3'b110: partial_products[i] <= -({{16{X_reg[15]}}, X_reg} >> (2*i));\n                        default: partial_products[i] <= 32'd0;\n                    endcase\n                end\n                valid_reg[1] <= 1; // State 1 done, mark State 2 as ready\n                valid_reg[0] <= 0; // Reset state 1 active flag\n            end \n            else\n              valid_reg[1] <= 0; // State 1 done, mark State 2 as ready\n\n            // State 3: Partial Summation\n            if (valid_reg[1]) begin \n                s1 <= partial_products[0] + partial_products[1] + partial_products[2];\n                s2 <= partial_products[3] + partial_products[4] + partial_products[5];\n                \n                valid_reg[2] <= 1; // State 3 done, mark State 4 as ready\n                valid_reg[1] <= 0; // Clear state 2 active flag\n            end \n            else\n              valid_reg[2] <= 0; // State 3 done, mark State 4 as ready \n\n            // State 4: Sum of Sums\n            if (valid_reg[2]) begin \n                s3 <= s1 + s2;\n                s4 <= partial_products[6] + partial_products[7];\n                \n                valid_reg[3] <= 1; // State 4 done, mark State 5 as ready\n                valid_reg[2] <= 0; // Clear state 3 active flag\n            end \n            else\n              valid_reg[3] <= 0; // State 4 done, mark State 5 as ready\n\n            \n            // State 5: Final Result\n            if (valid_reg[3]) begin\n                result <= s3 + s4;\n                done <= 1;  // Output done signal\n                valid_reg[3] <= 0; // Reset state 5 active flag after result computation\n            end \n            else\n            begin\n              result <= 0;\n              done <= 1'b0; \n            end \n            \n        end\n    end\n        \nendmodule"}, "output": {"rtl/pipelined_modified_booth_multiplier.sv": "module pipelined_modified_booth_multiplier (\n    input clk,\n    input rst,\n    input start,\n    input signed [15:0] X,\n    input signed [15:0] Y,\n    output reg signed  [31:0] result,\n    output reg done\n);\n\n    reg signed [31:0] partial_products [0:7];\n    reg signed [15:0] X_reg, Y_reg;\n    reg [4:0] valid_reg; // Extended valid register for more granular state control\n\n    integer i;\n\n    // Registers for pipelining the addition stages\n    reg signed [31:0] s1, s2, s3, s4;\n    reg signed [31:0] temp_products1, temp_products2;\n\n    always @(posedge clk or posedge rst) \n    begin\n        if (rst) \n        begin\n            X_reg <= 16'd0;\n            Y_reg <= 16'd0;\n            valid_reg <= 5'd0;\n            done <= 0;\n            for (i = 0; i < 8; i = i + 1) \n            begin\n                partial_products[i] <= 32'd0;\n            end\n            s1 <= 0; s2 <= 0; s3 <= 0; s4 <= 0;\n            temp_products1 <= 0; temp_products2 <= 0;\n            result <= 32'd0;\n            done <= 1'b0;\n        end \n        else \n        begin\n            if (start && !valid_reg[0]) begin\n                X_reg <= X;\n                Y_reg <= Y;\n                valid_reg[0] <= 1;  // Initiate state 1\n            end\n            else\n              valid_reg[0] <= 0;  // Initiate state 1 \n\n            // Process Booth multiplication\n            if (valid_reg[0]) begin\n                for (i = 0; i < 8; i = i + 1) begin\n                    case ({Y_reg[2*i+1], Y_reg[2*i], (i == 0) ? 1'b0 : Y_reg[2*i-1]})\n                        3'b000, 3'b111: partial_products[i] <= 32'd0;\n                        3'b001, 3'b010: partial_products[i] <= {{16{X_reg[15]}}, X_reg} >> (2*i);\n                        3'b011: partial_products[i] <= {{16{X_reg[15]}}, X_reg} >> (2*i + 1);\n                        3'b100: partial_products[i] <= -({{16{X_reg[15]}}, X_reg} >> (2*i + 1));\n                        3'b101, 3'b110: partial_products[i] <= -({{16{X_reg[15]}}, X_reg} >> (2*i));\n                        default: partial_products[i] <= 32'd0;\n                    endcase\n                end\n                valid_reg[1] <= 1; // State 1 done, mark State 2 as ready\n                valid_reg[0] <= 0; // Reset state 1 active flag\n            end \n            else\n              valid_reg[1] <= 0; // State 1 done, mark State 2 as ready\n\n            // State 3: Partial Summation\n            if (valid_reg[1]) begin \n                s1 <= partial_products[0] + partial_products[1] + partial_products[2];\n                s2 <= partial_products[3] + partial_products[4] + partial_products[5];\n                \n                valid_reg[2] <= 1; // State 3 done, mark State 4 as ready\n                valid_reg[1] <= 0; // Clear state 2 active flag\n            end \n            else\n              valid_reg[2] <= 0; // State 3 done, mark State 4 as ready \n\n            // State 4: Sum of Sums\n            if (valid_reg[2]) begin \n                s3 <= s1 + s2;\n                s4 <= partial_products[6] + partial_products[7];\n                \n                valid_reg[3] <= 1; // State 4 done, mark State 5 as ready\n                valid_reg[2] <= 0; // Clear state 3 active flag\n            end \n            else\n              valid_reg[3] <= 0; // State 4 done, mark State 5 as ready\n\n            \n            // State 5: Final Result\n            if (valid_reg[3]) begin\n                result <= s3 + s4;\n                done <= 1;  // Output done signal\n                valid_reg[3] <= 0; // Reset state 5 active flag after result computation\n            end \n            else\n            begin\n              result <= 0;\n              done <= 1'b0; \n            end \n            \n        end\n    end\n        \nendmodule"}, "obj": true}}
{"cvdp_copilot_montgomery_0001": {"input": {"rtl/montgomery_redc.sv": "module montgomery_redc #\n(\n    parameter N = 7,              \n    parameter R = 8,              \n    parameter R_INVERSE = 1,\n    parameter NWIDTH = $clog2(N), \n    parameter TWIDTH = $clog2(N*R)     \n)(\n    input  wire [TWIDTH-1:0] T,    \n    output wire [NWIDTH-1:0] result \n);\n    // Derived parameters\n    localparam RWIDTH = $clog2(R)+1;         \n              \n    localparam [RWIDTH-1:0] N_PRIME = (R * R_INVERSE - 1) / N;       \n\n    wire [RWIDTH-1:0] T_mod_R;               \n    wire [2*RWIDTH-1:0] T_mod_R_X_N_PRIME;      \n    wire [RWIDTH-1:0] m;                     \n    wire [NWIDTH:0] t;                      \n\n    assign T_mod_R = T[RWIDTH-1:0]; \n\n    assign T_mod_R_X_N_PRIME = T_mod_R * N_PRIME;\n\n    assign m = T_mod_R_X_N_PRIME[RWIDTH-1:0];\n\n    assign t = (T + m * N) >> RWIDTH;\n\n    assign result = (t >= N) ? (t - N) : t;\n\nendmodule"}, "output": {"rtl/montgomery_redc.sv": "module montgomery_redc #\n(\n    parameter N = 7,              \n    parameter R = 8,              \n    parameter R_INVERSE = 1,\n    parameter NWIDTH = $clog2(N), \n    parameter TWIDTH = $clog2(N*R)     \n)(\n    input  wire [TWIDTH-1:0] T,    \n    output wire [NWIDTH-1:0] result \n);\n    // Derived parameters\n    localparam RWIDTH = $clog2(R)+1;         \n              \n    localparam [RWIDTH-1:0] N_PRIME = (R * R_INVERSE - 1) / N;       \n\n    wire [RWIDTH-1:0] T_mod_R;               \n    wire [2*RWIDTH-1:0] T_mod_R_X_N_PRIME;      \n    wire [RWIDTH-1:0] m;                     \n    wire [NWIDTH:0] t;                      \n\n    assign T_mod_R = T[RWIDTH-1:0]; \n\n    assign T_mod_R_X_N_PRIME = T_mod_R * N_PRIME;\n\n    assign m = T_mod_R_X_N_PRIME[RWIDTH-1:0];\n\n    assign t = (T + m * N) >> RWIDTH;\n\n    assign result = (t >= N) ? (t - N) : t;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_montgomery_0002": {"input": {"rtl/montgomery_redc.sv": "module montgomery_mult #\n(\n    parameter N = 7,              \n    parameter R = 8,              \n    parameter R_INVERSE = 1,\n    parameter NWIDTH = $clog2(N)\n    )(\n    input clk ,\n    input rst_n,\n    input  wire [NWIDTH-1:0] a,b, \n    input valid_in,  \n    output wire [NWIDTH-1:0] result ,\n    output valid_out\n);\n    \n    \n    localparam  R_MOD_N  =  R%N       ;\n    localparam TWO_NWIDTH = $clog2(2*N)   ;\n\n    reg [NWIDTH-1:0] a_q,b_q;\n\n    wire [NWIDTH-1:0] a_redc, b_redc  ;\n    reg [NWIDTH-1:0] a_redc_q, b_redc_q  ;\n\n    wire [NWIDTH-1:0] result_d ;\n    reg [NWIDTH-1:0] result_q ;\n\n    reg valid_in_q, valid_in_q1, valid_in_q2;\n    reg valid_out_q ;\n    wire [2*NWIDTH-1:0] ar = a_q * R_MOD_N ; \n    wire [2*NWIDTH-1:0] br = b_q * R_MOD_N ; \n\n    wire [2*NWIDTH-1:0] a_redc_x_b_redc ;\n    \n    \n    assign a_redc_x_b_redc = a_redc_q * b_redc_q ;\n    assign result = result_q;\n    assign valid_out = valid_out_q ;\n    always_ff @( posedge clk or negedge rst_n ) begin : valid_out_pipeline\n        if (!rst_n) begin\n            valid_in_q      <=  0 ; \n            valid_in_q1     <=  0 ; \n            valid_in_q2     <=  0 ; \n            valid_out_q     <=  0 ; \n        end else begin\n            valid_in_q      <=  valid_in        ;     \n            valid_in_q1     <=  valid_in_q      ;   \n            valid_in_q2     <=  valid_in_q1     ; \n            valid_out_q     <=  valid_in_q2     ; \n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : input_registers\n        if (!rst_n) begin\n            a_q <= 0 ;\n            b_q <= 0 ;\n        end else begin\n            if(valid_in) begin\n                a_q <= a ;\n                b_q <= b ;\n            end\n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : a_b_reduction_pipeline\n        if (!rst_n) begin\n            a_redc_q <= 0 ;\n            b_redc_q <= 0 ;\n        end else begin\n            a_redc_q <= a_redc ;\n            b_redc_q <= b_redc ;\n        end \n    end\n\n    \n\n    always_ff @( posedge clk or negedge rst_n ) begin : output_register\n        if (!rst_n) begin\n            result_q <= 0 ;\n        end else begin\n            result_q <= result_d ;\n        end \n    end\n\n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) ar2_redc (\n        .T(ar),    \n        .result(a_redc) \n    );\n    \n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) br2_redc (\n        .T(br),    \n        .result(b_redc) \n    );\n\n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) prod_redc (\n        .T(a_redc_x_b_redc),    \n        .result(result_d) \n    );\n\n   \n\nendmodule\n\n\nmodule montgomery_redc #\n(\n    parameter N = 7,              \n    parameter R = 8,              \n    parameter R_INVERSE = 1,\n    parameter NWIDTH = $clog2(N), \n    parameter TWIDTH = $clog2(N*R)     \n)(\n    input  wire [TWIDTH-1:0] T,    \n    output wire [NWIDTH-1:0] result \n);\n    // Derived parameters\n    localparam RWIDTH = $clog2(R);          \n    localparam TWO_NWIDTH = $clog2(2*N)   ;              \n    localparam [RWIDTH-1:0] N_PRIME = (R * R_INVERSE - 1) / N; \n\n    wire [RWIDTH-1:0] T_mod_R;               \n    wire [2*RWIDTH-1:0] T_mod_R_X_N_PRIME;      \n    wire [RWIDTH-1:0] m;                     \n    wire [TWO_NWIDTH-1:0] t;                      \n\n    assign T_mod_R = T[RWIDTH-1:0];\n\n    assign T_mod_R_X_N_PRIME = T_mod_R * N_PRIME;\n\n    assign m = T_mod_R_X_N_PRIME[RWIDTH-1:0];\n\n    assign t = (T + m * N) >> RWIDTH;\n\n    assign result = (t >= N) ? (t - N) : t;\n\nendmodule"}, "output": {"rtl/montgomery_redc.sv": "module montgomery_mult #\n(\n    parameter N = 7,              \n    parameter R = 8,              \n    parameter R_INVERSE = 1,\n    parameter NWIDTH = $clog2(N)\n    )(\n    input clk ,\n    input rst_n,\n    input  wire [NWIDTH-1:0] a,b, \n    input valid_in,  \n    output wire [NWIDTH-1:0] result ,\n    output valid_out\n);\n    \n    \n    localparam  R_MOD_N  =  R%N       ;\n    localparam TWO_NWIDTH = $clog2(2*N)   ;\n\n    reg [NWIDTH-1:0] a_q,b_q;\n\n    wire [NWIDTH-1:0] a_redc, b_redc  ;\n    reg [NWIDTH-1:0] a_redc_q, b_redc_q  ;\n\n    wire [NWIDTH-1:0] result_d ;\n    reg [NWIDTH-1:0] result_q ;\n\n    reg valid_in_q, valid_in_q1, valid_in_q2;\n    reg valid_out_q ;\n    wire [2*NWIDTH-1:0] ar = a_q * R_MOD_N ; \n    wire [2*NWIDTH-1:0] br = b_q * R_MOD_N ; \n\n    wire [2*NWIDTH-1:0] a_redc_x_b_redc ;\n    \n    \n    assign a_redc_x_b_redc = a_redc_q * b_redc_q ;\n    assign result = result_q;\n    assign valid_out = valid_out_q ;\n    always_ff @( posedge clk or negedge rst_n ) begin : valid_out_pipeline\n        if (!rst_n) begin\n            valid_in_q      <=  0 ; \n            valid_in_q1     <=  0 ; \n            valid_in_q2     <=  0 ; \n            valid_out_q     <=  0 ; \n        end else begin\n            valid_in_q      <=  valid_in        ;     \n            valid_in_q1     <=  valid_in_q      ;   \n            valid_in_q2     <=  valid_in_q1     ; \n            valid_out_q     <=  valid_in_q2     ; \n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : input_registers\n        if (!rst_n) begin\n            a_q <= 0 ;\n            b_q <= 0 ;\n        end else begin\n            if(valid_in) begin\n                a_q <= a ;\n                b_q <= b ;\n            end\n        end \n    end\n\n    always_ff @( posedge clk or negedge rst_n ) begin : a_b_reduction_pipeline\n        if (!rst_n) begin\n            a_redc_q <= 0 ;\n            b_redc_q <= 0 ;\n        end else begin\n            a_redc_q <= a_redc ;\n            b_redc_q <= b_redc ;\n        end \n    end\n\n    \n\n    always_ff @( posedge clk or negedge rst_n ) begin : output_register\n        if (!rst_n) begin\n            result_q <= 0 ;\n        end else begin\n            result_q <= result_d ;\n        end \n    end\n\n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) ar2_redc (\n        .T(ar),    \n        .result(a_redc) \n    );\n    \n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) br2_redc (\n        .T(br),    \n        .result(b_redc) \n    );\n\n    montgomery_redc #\n    (\n        .N (N),\n        .R (R),\n        .R_INVERSE(R_INVERSE)     \n    ) prod_redc (\n        .T(a_redc_x_b_redc),    \n        .result(result_d) \n    );\n\n   \n\nendmodule\n\n\nmodule montgomery_redc #\n(\n    parameter N = 7,              \n    parameter R = 8,              \n    parameter R_INVERSE = 1,\n    parameter NWIDTH = $clog2(N), \n    parameter TWIDTH = $clog2(N*R)     \n)(\n    input  wire [TWIDTH-1:0] T,    \n    output wire [NWIDTH-1:0] result \n);\n    // Derived parameters\n    localparam RWIDTH = $clog2(R);          \n    localparam TWO_NWIDTH = $clog2(2*N)   ;              \n    localparam [RWIDTH-1:0] N_PRIME = (R * R_INVERSE - 1) / N; \n\n    wire [RWIDTH-1:0] T_mod_R;               \n    wire [2*RWIDTH-1:0] T_mod_R_X_N_PRIME;      \n    wire [RWIDTH-1:0] m;                     \n    wire [TWO_NWIDTH-1:0] t;                      \n\n    assign T_mod_R = T[RWIDTH-1:0];\n\n    assign T_mod_R_X_N_PRIME = T_mod_R * N_PRIME;\n\n    assign m = T_mod_R_X_N_PRIME[RWIDTH-1:0];\n\n    assign t = (T + m * N) >> RWIDTH;\n\n    assign result = (t >= N) ? (t - N) : t;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_morse_code_0001": {"input": {}, "output": {"rtl/morse_encoder.sv": ""}, "obj": true}}
{"cvdp_copilot_morse_code_0014": {"input": {"rtl/morse_encoder.sv": "module morse_encoder (\n    input wire [7:0] ascii_in,       // ASCII input character\n    output reg [5:0] morse_out,      // Morse code output (6 bits max for each letter)\n    output reg [3:0] morse_length    // Length of the Morse code sequence\n);\n\n    always @(*) begin\n        case (ascii_in)\n            8'h41: begin morse_out = 6'b100;      morse_length = 3; end  // A: .-\n            8'h42: begin morse_out = 6'b1000;     morse_length = 4; end  // B: -...\n            8'h43: begin morse_out = 6'b1010;     morse_length = 4; end  // C: -.-.\n            8'h44: begin morse_out = 6'b100;      morse_length = 3; end  // D: -..\n            8'h45: begin morse_out = 6'b1;        morse_length = 3; end  // E: .\n            8'h46: begin morse_out = 6'b0010;     morse_length = 4; end  // F: ..-.\n            8'h47: begin morse_out = 6'b110;      morse_length = 3; end  // G: --.\n            8'h48: begin morse_out = 6'b0000;     morse_length = 4; end  // H: ....\n            8'h49: begin morse_out = 6'b00;       morse_length = 2; end  // I: ..\n            8'h4A: begin morse_out = 6'b0111;     morse_length = 4; end  // J: .---\n            8'h4B: begin morse_out = 6'b101;      morse_length = 3; end  // K: -.-\n            8'h4C: begin morse_out = 6'b01;       morse_length = 2; end  // L: .-..\n            8'h4D: begin morse_out = 6'b11;       morse_length = 2; end  // M: --\n            8'h4E: begin morse_out = 6'b10;       morse_length = 2; end  // N: -.\n            8'h4F: begin morse_out = 6'b111;      morse_length = 3; end  // O: ---\n            8'h50: begin morse_out = 6'b0110;     morse_length = 4; end  // P: .--.\n            8'h51: begin morse_out = 6'b1101;     morse_length = 4; end  // Q: --.-\n            8'h52: begin morse_out = 6'b010;      morse_length = 3; end  // R: .-.\n            8'h53: begin morse_out = 6'b000;      morse_length = 3; end  // S: ...\n            8'h54: begin morse_out = 6'b1;        morse_length = 1; end  // T: -\n            8'h55: begin morse_out = 6'b001;      morse_length = 3; end  // U: ..-\n            8'h56: begin morse_out = 6'b0001;     morse_length = 4; end  // V: ...-\n            8'h57: begin morse_out = 6'b011;      morse_length = 3; end  // W: .--\n            8'h58: begin morse_out = 6'b1001;     morse_length = 4; end  // X: -..-\n            8'h59: begin morse_out = 6'b1011;     morse_length = 4; end  // Y: -.--\n            8'h5A: begin morse_out = 6'b1100;     morse_length = 4; end  // Z: --..\n            8'h30: begin morse_out = 6'b11111;    morse_length = 5; end  // 0: -----\n            8'h31: begin morse_out = 6'b01111;    morse_length = 5; end  // 1: .----\n            8'h32: begin morse_out = 6'b00111;    morse_length = 5; end  // 2: ..---\n            8'h33: begin morse_out = 6'b00011;    morse_length = 5; end  // 3: ...--\n            8'h34: begin morse_out = 6'b00001;    morse_length = 5; end  // 4: ....-\n            8'h35: begin morse_out = 6'b00000;    morse_length = 5; end  // 5: .....\n            8'h36: begin morse_out = 6'b10000;    morse_length = 5; end  // 6: -....\n            8'h37: begin morse_out = 6'b11000;    morse_length = 5; end  // 7: --...\n            8'h38: begin morse_out = 6'b11100;    morse_length = 5; end  // 8: ---..\n            8'h39: begin morse_out = 6'b11110;    morse_length = 5; end  // 9: ----.\n            default: begin\n                morse_out = 6'b0;                 \n                morse_length = 4'b0;\n            end\n        endcase\n    end\n\nendmodule"}, "output": {"rtl/morse_encoder.sv": ""}, "obj": true}}
{"cvdp_copilot_moving_average_0001": {"input": {}, "output": {"rtl/moving_average.v": ""}, "obj": true}}
{"cvdp_copilot_moving_average_0005": {"input": {"docs/RTL_documentation.md": "# Moving Average Module Documentation\n\n## Module Overview\n\nThe `moving_average` module is a hardware implementation designed to compute the moving average of a sequence of 12-bit data inputs with a window width of 8 samples. This module is typically used in digital signal processing (DSP) applications such as noise reduction, data smoothing, and signal conditioning.\n\n## Inputs and Outputs\n\n- **clk (input, wire)**: Clock signal that drives the memory updates and computations within the module.\n- **reset (input, wire)**: Synchronous reset signal, which, when high, resets the module\n- **data_in (input, wire[11:0])**: 12-bit input data signal.\n- **data_out (output, wire[11:0])**: 12-bit output data signal representing the moving average of the last 8 input data values.\n\n## Internal Components and Implementation\n\n### Memory\n- **memory[7:0]**: An array of 8 registers, each storing a 12-bit value, used to hold the last 8 input values for averaging.\n\n### Summation Logic\n- **sum[14:0]**: A 15-bit register to maintain the running sum of the values stored in the memory. The latest input is added and the oldest input is subtracted to get the current average value.\n\n### Average Logic\n-   **data_out[11:0]**: A 12-bit output representing the average value is calculated by using shift operation on **sum[14:0]**. Window size of 8, requires the summation to be divided by 8, which is implemented by shifting the **sum[14:0]** 3 bits to the right.\n\n### Address Management\n- **write_address[2:0]**: A 3-bit register pointing to the location that the new input will be written to.\n- **next_address[2:0]**: A 3-bit value pointing to the location of the oldest element in the memory.\n\n###", "rtl/moving_average.v": "module moving_average(\n    input wire clk,\n    input wire reset,\n    input  wire [11 : 0] data_in,\n    output wire [11 : 0] data_out\n);\n\nreg [11 : 0] memory [7 : 0];\nreg [14 : 0] sum;\nreg [2  : 0] write_address;\nwire [2 : 0] next_address;\nreg [11 : 0] read_data;\n\nassign next_address=write_address + 1'b1;\nassign data_out=sum[14 : 3];\n\n    // write current input to memory\n    integer i;\n    always @(posedge clk ) begin\n        if (reset == 1'b1) begin\n            for (i = 0 ;i < 8 ; i = i + 1 ) begin\n                memory[i]<='h0;\n            end\n        end else begin\n            memory[write_address]<=data_in;\n        end\n    end\n\n    // read the oldest element written to memory\n    always @(posedge clk ) begin\n        if(reset == 1'b1)begin\n            read_data<='h0;\n        end else begin\n            read_data<=memory[next_address];\n        end\n    end\n\n    // increase the write address to move onto the next data\n    always @(posedge clk ) begin\n        if(reset == 1'b1)begin\n            write_address<='h0;\n        end else begin\n            write_address<=write_address + 1'b1;\n        end\n    end\n\n    // calculate sum by adding the latest data to the sum and substracting the oldest data\n    always @(posedge clk ) begin\n        if(reset == 1'b1)begin\n            sum<='h0;\n        end else begin\n            sum<=sum+data_in-read_data;\n        end\n    end\n\nendmodule"}, "output": {"rtl/moving_average.v": ""}, "obj": true}}
{"cvdp_copilot_mux_synch_0001": {"input": {}, "output": {"rtl/mux_synch.sv": ""}, "obj": true}}
{"cvdp_copilot_mux_synch_0011": {"input": {"rtl/mux_synch.sv": "module mux_synch (\n\ninput [7:0] data_in,   \t\t\t//asynchronous data input\ninput req,                  \t\t//indicating that data is available at the data_in input\ninput dst_clk,                 \t\t//destination clock\ninput src_clk,                 \t\t//source clock\ninput nrst,                    \t\t//asynchronous reset \noutput reg [7:0] data_out,              //synchronized version of data_in to the destination clock domain\noutput ack_out ); \t\t\n\n\nwire syncd_req,anded_req,syncd_ack;\nreg syncd_req_1,ack;\n\n                        \t\t\t\t\t\t\nnff  req_synch_0 (.d_in(req),.dst_clk(dst_clk),.rst(nrst),.syncd(syncd_req)) ;\t\t//2-flop synchronizer for the enable input\n\n                                \nalways_ff @(posedge dst_clk)                     \t\t\t\t\t//one clock cycle delayed synced_enable\nbegin\n    syncd_req_1 <= syncd_req;\nend\n\nassign anded_req = (!syncd_req_1 && syncd_req);    \t\t\t\t\t//posedge detector\n\n\t\nalways_ff @(posedge dst_clk or negedge nrst)\nbegin                                                   \n\tif(!nrst)\n\t\tdata_out <= 1'b0;               \t\t\t\t\t//forcing the output data_in to zero when an active-low asynchronous reset is detected.\n\n\telse if (anded_req==1'b1)\n\t\tdata_out <= data_in;                    \t\t\t\t//latching data_in to data_out when the enable signal is available.\n\t\n\telse\n\t\tdata_out <= data_out;                   \t\t\t\t//holds the data till next req comes.\nend\n\n\n// acknowledgment signal generation\nalways_ff@(posedge dst_clk or negedge nrst)\nbegin\n\tif(!nrst)\n\t\tack <= 1'b0; \n\n\telse if (anded_req==1'b1)\n\t\tack <= 1'b1;\n\t\n\telse\n\t\tack <= 1'b0;\nend\n\n//changing the clock domain of the ack signal\nnff  enable_synch_1 (.d_in(ack),.dst_clk(src_clk),.rst(nrst),.syncd(syncd_ack)) ;\n\n//edge detector circuit\nassign ack_out = syncd_ack;\n\n\nendmodule\n\nmodule nff  (\n\t\n\tinput d_in,   \t\t\t\t\t\t\t\t\t//input data that needs to be synchronized to the dst_clk domain.\n\tinput dst_clk,     \t\t\t\t\t\t\t\t//destination domain clock.\n\tinput rst,         \t\t\t\t\t\t\t\t//asynchronous active-low reset\n\toutput reg  syncd \t\t\t\t\t\t\t\t//synced output, which is a 2-clock-cycle delayed version of d_in.\n\t                   );\n\nreg   dmeta;             \t\t\t\t\t\t\t\t//register to hold output.\n\n\n\nalways@(posedge dst_clk or negedge rst)  \nbegin\n\tif(!rst)              \t\t\t\t\t\t\t\t//active-low asynchronous reset\n  begin\n    syncd <= 1'b0;      \t\t\t\t\t\t\t\t//resetting the synced register to 0\n    dmeta <= 1'b0;      \t\t\t\t\t\t\t\t//resetting dmeta register to 0\n  end\n  else\n  begin\n    dmeta <= d_in;      \t\t\t\t\t\t\t\t//passing d_in to dmeta\n    syncd <= dmeta;     \t\t\t\t\t\t\t\t//passing dmeta to syncd\n  end\nend\n\nendmodule"}, "output": {"rtl/mux_synch.sv": "module mux_synch (\n\ninput [7:0] data_in,   \t\t\t//asynchronous data input\ninput req,                  \t\t//indicating that data is available at the data_in input\ninput dst_clk,                 \t\t//destination clock\ninput src_clk,                 \t\t//source clock\ninput nrst,                    \t\t//asynchronous reset \noutput reg [7:0] data_out,              //synchronized version of data_in to the destination clock domain\noutput ack_out ); \t\t\n\n\nwire syncd_req,anded_req,syncd_ack;\nreg syncd_req_1,ack;\n\n                        \t\t\t\t\t\t\nnff  req_synch_0 (.d_in(req),.dst_clk(dst_clk),.rst(nrst),.syncd(syncd_req)) ;\t\t//2-flop synchronizer for the enable input\n\n                                \nalways_ff @(posedge dst_clk)                     \t\t\t\t\t//one clock cycle delayed synced_enable\nbegin\n    syncd_req_1 <= syncd_req;\nend\n\nassign anded_req = (!syncd_req_1 && syncd_req);    \t\t\t\t\t//posedge detector\n\n\t\nalways_ff @(posedge dst_clk or negedge nrst)\nbegin                                                   \n\tif(!nrst)\n\t\tdata_out <= 1'b0;               \t\t\t\t\t//forcing the output data_in to zero when an active-low asynchronous reset is detected.\n\n\telse if (anded_req==1'b1)\n\t\tdata_out <= data_in;                    \t\t\t\t//latching data_in to data_out when the enable signal is available.\n\t\n\telse\n\t\tdata_out <= data_out;                   \t\t\t\t//holds the data till next req comes.\nend\n\n\n// acknowledgment signal generation\nalways_ff@(posedge dst_clk or negedge nrst)\nbegin\n\tif(!nrst)\n\t\tack <= 1'b0; \n\n\telse if (anded_req==1'b1)\n\t\tack <= 1'b1;\n\t\n\telse\n\t\tack <= 1'b0;\nend\n\n//changing the clock domain of the ack signal\nnff  enable_synch_1 (.d_in(ack),.dst_clk(src_clk),.rst(nrst),.syncd(syncd_ack)) ;\n\n//edge detector circuit\nassign ack_out = syncd_ack;\n\n\nendmodule\n\nmodule nff  (\n\t\n\tinput d_in,   \t\t\t\t\t\t\t\t\t//input data that needs to be synchronized to the dst_clk domain.\n\tinput dst_clk,     \t\t\t\t\t\t\t\t//destination domain clock.\n\tinput rst,         \t\t\t\t\t\t\t\t//asynchronous active-low reset\n\toutput reg  syncd \t\t\t\t\t\t\t\t//synced output, which is a 2-clock-cycle delayed version of d_in.\n\t                   );\n\nreg   dmeta;             \t\t\t\t\t\t\t\t//register to hold output.\n\n\n\nalways@(posedge dst_clk or negedge rst)  \nbegin\n\tif(!rst)              \t\t\t\t\t\t\t\t//active-low asynchronous reset\n  begin\n    syncd <= 1'b0;      \t\t\t\t\t\t\t\t//resetting the synced register to 0\n    dmeta <= 1'b0;      \t\t\t\t\t\t\t\t//resetting dmeta register to 0\n  end\n  else\n  begin\n    dmeta <= d_in;      \t\t\t\t\t\t\t\t//passing d_in to dmeta\n    syncd <= dmeta;     \t\t\t\t\t\t\t\t//passing dmeta to syncd\n  end\nend\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_nbit_swizzling_0001": {"input": {}, "output": {"rtl/nbit_swizzling.sv": ""}, "obj": true}}
{"cvdp_copilot_nbit_swizzling_0014": {"input": {"rtl/nbit_swizzling.sv": "module nbit_swizzling #(parameter DATA_WIDTH = 64)(\n    input [DATA_WIDTH-1:0] data_in,                                         // Input data of size DATA_WIDTH \n    input [1:0] sel,                \t                                    //  2-bit selection signal \n    output reg [DATA_WIDTH-1:0] data_out                                    // Output data of size DATA_WIDTH \n);\n\ninteger i; \n\nalways @(*) begin\n    case(sel)\n        2'b00: begin\n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH-1-i];                      \n            end\n        end\n        \n        2'b01: begin\n            for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n                data_out[i]                = data_in[DATA_WIDTH/2-1-i];     \n                data_out[DATA_WIDTH/2 + i] = data_in[DATA_WIDTH-1-i];       \n            end\n        end\n        \n        2'b10: begin\n            for (i = 0; i < DATA_WIDTH/4; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH/4-1-i]; \t\t            \n                data_out[DATA_WIDTH/4 + i]   = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n        end\n        \n        2'b11: begin\n            for (i = 0; i < DATA_WIDTH/8; i = i + 1) begin\n                data_out[i]                  = data_in[DATA_WIDTH/8-1-i];   \n                data_out[DATA_WIDTH/8 + i]   = data_in[DATA_WIDTH/4-1-i];   \n                data_out[DATA_WIDTH/4 + i]   = data_in[3*DATA_WIDTH/8-1-i]; \n                data_out[3*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[5*DATA_WIDTH/8-1-i]; \n                data_out[5*DATA_WIDTH/8 + i] = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[7*DATA_WIDTH/8-1-i]; \n                data_out[7*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n        end\n        default: begin\n            data_out = data_in;\t\t\t\t\t\t                        \n        end\n    endcase\nend\n\nendmodule "}, "output": {"rtl/nbit_swizzling.sv": "module nbit_swizzling #(parameter DATA_WIDTH = 64)(\n    input [DATA_WIDTH-1:0] data_in,                                         // Input data of size DATA_WIDTH \n    input [1:0] sel,                \t                                    //  2-bit selection signal \n    output reg [DATA_WIDTH-1:0] data_out                                    // Output data of size DATA_WIDTH \n);\n\ninteger i; \n\nalways @(*) begin\n    case(sel)\n        2'b00: begin\n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH-1-i];                      \n            end\n        end\n        \n        2'b01: begin\n            for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n                data_out[i]                = data_in[DATA_WIDTH/2-1-i];     \n                data_out[DATA_WIDTH/2 + i] = data_in[DATA_WIDTH-1-i];       \n            end\n        end\n        \n        2'b10: begin\n            for (i = 0; i < DATA_WIDTH/4; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH/4-1-i]; \t\t            \n                data_out[DATA_WIDTH/4 + i]   = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n        end\n        \n        2'b11: begin\n            for (i = 0; i < DATA_WIDTH/8; i = i + 1) begin\n                data_out[i]                  = data_in[DATA_WIDTH/8-1-i];   \n                data_out[DATA_WIDTH/8 + i]   = data_in[DATA_WIDTH/4-1-i];   \n                data_out[DATA_WIDTH/4 + i]   = data_in[3*DATA_WIDTH/8-1-i]; \n                data_out[3*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[5*DATA_WIDTH/8-1-i]; \n                data_out[5*DATA_WIDTH/8 + i] = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[7*DATA_WIDTH/8-1-i]; \n                data_out[7*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n        end\n        default: begin\n            data_out = data_in;\t\t\t\t\t\t                        \n        end\n    endcase\nend\n\nendmodule "}, "obj": true}}
{"cvdp_copilot_nbit_swizzling_0020": {"input": {"rtl/nbit_swizzling.sv": "module nbit_swizzling #(parameter DATA_WIDTH = 64)(\n    input [DATA_WIDTH-1:0] data_in,                                         // Input data of size DATA_WIDTH \n    input [1:0] sel,                \t                                    //  2-bit selection signal \n    output reg [DATA_WIDTH:0] data_out                                      // Output data of size DATA_WIDTH \n);\n\ninteger i; \nwire parity_bit;                                                            \n\n\nassign parity_bit = ^data_in;\n\nalways @(*) begin\n    case(sel)\n        2'b00: begin\n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH-1-i];                      \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b01: begin\n            for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n                data_out[i]                = data_in[DATA_WIDTH/2-1-i];     \n                data_out[DATA_WIDTH/2 + i] = data_in[DATA_WIDTH-1-i];       \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b10: begin\n            for (i = 0; i < DATA_WIDTH/4; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH/4-1-i]; \t\t            \n                data_out[DATA_WIDTH/4 + i]   = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b11: begin\n            for (i = 0; i < DATA_WIDTH/8; i = i + 1) begin\n                data_out[i]                  = data_in[DATA_WIDTH/8-1-i];   \n                data_out[DATA_WIDTH/8 + i]   = data_in[DATA_WIDTH/4-1-i];   \n                data_out[DATA_WIDTH/4 + i]   = data_in[3*DATA_WIDTH/8-1-i]; \n                data_out[3*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[5*DATA_WIDTH/8-1-i]; \n                data_out[5*DATA_WIDTH/8 + i] = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[7*DATA_WIDTH/8-1-i]; \n                data_out[7*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        default: begin\n            data_out = data_in;\t\n            data_out[DATA_WIDTH] = parity_bit; \t\t\t\t\t                        \n        end\n    endcase\nend\n\nendmodule "}, "output": {"rtl/nbit_swizzling.sv": "module nbit_swizzling #(parameter DATA_WIDTH = 64)(\n    input [DATA_WIDTH-1:0] data_in,                                         // Input data of size DATA_WIDTH \n    input [1:0] sel,                \t                                    //  2-bit selection signal \n    output reg [DATA_WIDTH:0] data_out                                      // Output data of size DATA_WIDTH \n);\n\ninteger i; \nwire parity_bit;                                                            \n\n\nassign parity_bit = ^data_in;\n\nalways @(*) begin\n    case(sel)\n        2'b00: begin\n            for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH-1-i];                      \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b01: begin\n            for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n                data_out[i]                = data_in[DATA_WIDTH/2-1-i];     \n                data_out[DATA_WIDTH/2 + i] = data_in[DATA_WIDTH-1-i];       \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b10: begin\n            for (i = 0; i < DATA_WIDTH/4; i = i + 1) begin\n                data_out[i] = data_in[DATA_WIDTH/4-1-i]; \t\t            \n                data_out[DATA_WIDTH/4 + i]   = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        \n        2'b11: begin\n            for (i = 0; i < DATA_WIDTH/8; i = i + 1) begin\n                data_out[i]                  = data_in[DATA_WIDTH/8-1-i];   \n                data_out[DATA_WIDTH/8 + i]   = data_in[DATA_WIDTH/4-1-i];   \n                data_out[DATA_WIDTH/4 + i]   = data_in[3*DATA_WIDTH/8-1-i]; \n                data_out[3*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH/2-1-i];   \n                data_out[DATA_WIDTH/2 + i]   = data_in[5*DATA_WIDTH/8-1-i]; \n                data_out[5*DATA_WIDTH/8 + i] = data_in[3*DATA_WIDTH/4-1-i]; \n                data_out[3*DATA_WIDTH/4 + i] = data_in[7*DATA_WIDTH/8-1-i]; \n                data_out[7*DATA_WIDTH/8 + i] = data_in[DATA_WIDTH-1-i];     \n            end\n            data_out[DATA_WIDTH] = parity_bit; \n        end\n        default: begin\n            data_out = data_in;\t\n            data_out[DATA_WIDTH] = parity_bit; \t\t\t\t\t                        \n        end\n    endcase\nend\n\nendmodule "}, "obj": true}}
{"cvdp_copilot_neuromorphic_array_0001": {"input": {}, "output": {"rtl/neuromorphic_array.sv": ""}, "obj": true}}
{"cvdp_copilot_one_hot_address_0001": {"input": {"rtl/one_hot_gen.sv": "module one_hot_gen #(\n    parameter NS_A = 'd8,\n    parameter NS_B = 'd4\n) (\n    input  logic                 clk,\n    input  logic                 rst_async_n,\n    input  logic [1:0]           i_config,\n    input  logic                 i_start,\n    input  logic                 o_ready,\n    output logic [NS_A+NS_B-1:0] o_address_one_hot\n);\n\ntypedef enum logic [2:0] {IDLE = 2'b00, REGION_A = 2'b01, REGION_B = 2'b10} state_t;\n\n// ----------------------------------------\n// - Wires/Registers creation\n// ----------------------------------------\nstate_t state_ff, state_nx;\nlogic [NS_A-1:0] region_A_ff, region_A_nx;\nlogic [NS_B-1:0] region_B_ff, region_B_nx;\nlogic A_to_B, B_to_A, only_A, only_B;\n\n// Input register\nlogic [2:0] config_ff;\n\n// ----------------------------------------\n// - Wire connections\n// ----------------------------------------\n\n// Region change flags\nassign A_to_B = ( config_ff[1] & ~config_ff[0]);\nassign B_to_A = ( config_ff[1] &  config_ff[0]);\nassign only_A = (~config_ff[0] & ~config_ff[0]);\nassign only_B = (~config_ff[0] &  config_ff[0]);\n\n// Output assignment (Region A concatenated with Region B)\nassign o_address_one_hot = {region_A_ff, region_B_ff};\n\n// ----------------------------------------\n// - Registers\n// ----------------------------------------\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : input_register\n    if(~rst_async_n) begin\n        config_ff <= 0;\n    end else begin\n        if(i_start && state_ff == IDLE) begin\n            config_ff <= i_config;\n        end\n    end\nend\n\nalways_ff @(posedge clk or negedge rst_async_n) begin : reset_regs\n    if(~rst_async_n) begin\n        o_ready <= 1;\n        state_ff <= IDLE;\n        region_A_ff <= {NS_A{1'b0}};\n        region_B_ff <= {NS_B{1'b0}};\n    end else begin\n        o_ready <= (state_nx == IDLE);\n        state_ff <= state_nx;\n        region_A_ff <= region_A_nx;\n        region_B_ff <= region_B_nx;\n    end\nend\n\n// ----------------------------------------\n// - One-hot address generation\n// ----------------------------------------\n\nalways_comb begin : drive_regions\n    case(state_ff)\n        IDLE: begin\n            if(i_start) begin\n                region_A_nx[NS_A] = (~i_config[0]);\n                region_B_nx[NS_B] = (i_config[0]);\n            end else begin\n                region_A_nx[NS_A] = 1'b0;\n                region_B_nx[NS_B] = 1'b0;\n            end\n\n            region_A_nx[NS_A-2:0] = {(NS_A-1){1'b0}};\n            region_B_nx[NS_B-2:0] = {(NS_B-1){1'b0}};\n        end\n        REGION_A: begin\n            region_A_nx = region_A_ff >> 1;\n\n            if(region_A_ff[0]) begin\n                region_B_nx[NS_B] = A_to_B;\n            end else begin\n                region_B_nx[NS_B] = 1'b0;\n            end\n            region_B_nx[NS_B-2:0] = {(NS_B-1){1'b0}};\n        end\n        REGION_B: begin\n            if(region_B_ff[0]) begin\n                region_A_nx[NS_A] = B_to_A;\n            end else begin\n                region_A_nx[NS_A] = 1'b0;\n            end\n            region_A_nx[NS_A-2:0] = {(NS_A-1){1'b0}};\n\n            region_B_nx = region_B_ff >> 1;\n        end\n        default: begin\n            region_A_nx = {NS_A{1'b0}};\n            region_B_nx = {NS_B{1'b0}};\n        end\n    endcase\nend\n\n// ----------------------------------------\n// - FSM update\n// ----------------------------------------\n\nalways_comb begin : update_state\n    case(state_ff)\n        IDLE: begin\n            if(i_start) begin\n                if(i_config[0]) begin\n                    state_nx = REGION_B;\n                end else begin\n                    state_nx = REGION_A;\n                end\n            end else begin\n                state_nx = IDLE;\n            end\n        end\n        REGION_A: begin\n            if(region_A_ff[0]) begin\n                if(A_to_B) begin\n                    state_nx = REGION_B;\n                end else begin\n                    state_nx = IDLE;\n                end\n            end else begin\n                state_nx = REGION_A;\n            end\n        end\n        REGION_B: begin\n            if(region_B_ff[0]) begin\n                if(B_to_A) begin\n                    state_nx = REGION_A;\n                end else begin\n                    state_nx = IDLE;\n                end\n            end else begin\n                state_nx = REGION_B;\n            end\n        end\n        default: begin\n            state_nx = IDLE;\n        end\n    endcase\nend\n\nendmodule : one_hot_gen"}, "output": {"rtl/one_hot_gen.sv": ""}, "obj": true}}
{"cvdp_copilot_packet_controller_0001": {"input": {}, "output": {"rtl/packet_controller.sv": ""}, "obj": true}}
{"cvdp_copilot_palindrome_3b_0002": {"input": {}, "output": {"rtl/palindrome_detect.sv": ""}, "obj": true}}
{"cvdp_copilot_password_generator_0001": {"input": {}, "output": {"rtl/password_generator.sv": ""}, "obj": true}}
{"cvdp_copilot_perceptron_0001": {"input": {}, "output": {"rtl/perceptron_gates.sv": ""}, "obj": true}}
{"cvdp_copilot_perceptron_0006": {"input": {"rtl/perceptron_gates.sv": "module perceptron_gates (\n   input  logic clk,// Posedge clock\n   input  logic rst_n,// Negedge reset\n   input  logic signed [3:0] x1, // First Input of the Perceptron\n   input  logic signed [3:0] x2, // Second Input of the Perceptron\n   input  logic learning_rate, // Learning rate (alpha)\n   input  logic signed [3:0] threshold, // Threshold value\n   input  logic [1:0] gate_select, // Gate selection for target values\n   output logic signed [3:0] percep_w1, // Trained Weight 1 \n   output logic signed [3:0] percep_w2, // Trained Weight 2\n   output logic signed [3:0] percep_bias, // Trained Bias\n   output logic [3:0] present_addr, // Current address in microcode ROM\n   output logic stop, // Condition to indicate no learning has occurred(i.e. no weight change between iterations)\n   output logic [2:0] input_index,// Vector to track the selection of target for a given input combination for a gate\n   output logic signed [3:0] y_in, // Calculated Response\n   output logic signed [3:0] y, // Calculated Response obtained by comparing y_in against a threshold value\n   output logic signed [3:0] prev_percep_wt_1,//Value of Weight 1 during a previous iteration\n   output logic signed [3:0] prev_percep_wt_2,//Value of Weight 2 during a previous iteration\n   output logic signed [3:0] prev_percep_bias // Value of Bias during a previous iteration\n);\n\n   logic [15:0] microcode_rom [0:5];\n   logic [3:0]  next_addr;\n   logic [3:0]  train_action;\n   logic [3:0]  microcode_addr;\n   logic [15:0] microinstruction;\n   logic signed [3:0] t1, t2, t3, t4;\n   \n   gate_target dut (\n       .gate_select(gate_select),\n       .o_1(t1),\n       .o_2(t2),\n       .o_3(t3),\n       .o_4(t4)\n   );\n\n   logic signed [3:0] percep_wt_1_reg;\n   logic signed [3:0] percep_wt_2_reg;\n   logic signed [3:0] percep_bias_reg;\n\n   \n   logic signed [3:0] target;\n   logic signed [3:0] prev_wt1_update;\n   logic signed [3:0] prev_wt2_update;\n   logic signed [3:0] prev_bias_update;\n   \n   logic signed [3:0] wt1_update;\n   logic signed [3:0] wt2_update;\n   logic signed [3:0] bias_update;\n   logic [7:0] epoch_counter;\n   \n   assign  prev_percep_wt_1 = prev_wt1_update;\n   assign  prev_percep_wt_2 = prev_wt2_update;\n   assign  prev_percep_bias = prev_bias_update;\n\n   initial begin \n      microcode_rom[0] = 16'b0001_0000_0000_0000; \n      microcode_rom[1] = 16'b0010_0001_0000_0000; \n      microcode_rom[2] = 16'b0011_0010_0000_0000; \n      microcode_rom[3] = 16'b0100_0011_0000_0000; \n      microcode_rom[4] = 16'b0101_0100_0000_0000; \n      microcode_rom[5] = 16'b0000_0101_0000_0000; \n   end  \n   \n   always@(*) begin\n      microinstruction = microcode_rom[microcode_addr];\n      next_addr        = microinstruction[15:12];\n      train_action     = microinstruction[11:8];\n   end\n\n   always_ff @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         present_addr    <= 4'd0;\n         microcode_addr  <= 4'd0;\n         percep_wt_1_reg <= 4'd0;\n         percep_wt_2_reg <= 4'd0;\n         percep_bias_reg <= 4'd0;\n         input_index     <= 2'd0;\n         stop            <= 1'b0;\n      end else begin\n         present_addr    <= next_addr;\n         microcode_addr  <= present_addr;\n      end\n   end\n\n   always_comb begin\n      case (train_action)\n         4'd0:  begin \n                   percep_wt_1_reg = 4'd0;\n                   percep_wt_2_reg = 4'd0;\n                   percep_bias_reg = 4'd0;\n                   stop = 1'b0;\n                   next_addr = next_addr + 4'd0;\n                   y_in = 4'd0;\n                   y    = 4'd0;\n                   prev_wt1_update = 4'd0;\n                   prev_wt2_update = 4'd0;\n                   prev_bias_update = 4'd0;\n                   input_index = 0;\n                   target = 0;\n                   wt1_update = 0;\n                   wt2_update = 0;\n                   bias_update = 0;\n                   epoch_counter = 0;\n                end\n         4'd1 : begin \n                   y_in = percep_bias_reg + (x1 * percep_wt_1_reg) + (x2 * percep_wt_2_reg); \n                   if (y_in > threshold)\n                      y = 4'd1;\n                   else if (y_in >= -threshold && y_in <= threshold)\n                      y = 4'd0;\n                   else\n                      y = -4'd1;\n                \n                   percep_wt_1_reg  = percep_wt_1_reg  + 4'd0;\n                   percep_wt_2_reg  = percep_wt_2_reg  + 4'd0;\n                   percep_bias_reg  = percep_bias_reg  + 4'd0;\n                   prev_wt1_update  = prev_wt1_update  + 4'd0;\n                   prev_wt2_update  = prev_wt2_update  + 4'd0;\n                   prev_bias_update = prev_bias_update + 4'd0;\n                   input_index = input_index + 0;\n                   next_addr = next_addr + 4'd0;\n                   stop = stop + 1'b0;\n                   target = target + 4'd0;\n                   wt1_update = wt1_update + 4'd0 ;\n                   wt2_update = wt2_update + 4'd0 ;\n                   bias_update = bias_update + 4'd0 ;\n                   epoch_counter = epoch_counter + 0;\n                end\n         4'd2 : begin\n                   if(input_index == 0)\n                        target = t1;\n                   else if(input_index == 1)\n                        target = t2;\n                   else if(input_index == 2)\n                        target = t3;\n                   else if(input_index == 3)\n                        target = t4;\n                   else begin\n                        input_index = 0;\n                        target = 0;\n                   end\n                   stop = stop + 1'b0;\n                   input_index = input_index + 0;\n                   next_addr = next_addr + 4'd0;\n                   target = target + 4'd0;\n                   prev_wt1_update  = prev_wt1_update  + 4'd0;\n                   prev_wt2_update  = prev_wt2_update  + 4'd0;\n                   prev_bias_update = prev_bias_update + 4'd0;\n                   \n                   percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                   percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                   percep_bias_reg = percep_bias_reg + 4'd0;\n                   y_in = y_in + 4'd0;\n                   y = y + 4'd0;\n                   wt1_update = wt1_update + 4'd0 ;\n                   wt2_update = wt2_update + 4'd0 ;\n                   bias_update = bias_update + 4'd0 ;\n                   epoch_counter = epoch_counter + 0;\n                end\n         4'd3 : begin\n                   if (y != target) begin\n                        wt1_update = learning_rate * x1 * target ;\n                        wt2_update = learning_rate * x2 * target ;\n                        bias_update = learning_rate * target ; \n                    end else begin\n                        wt1_update = 0 ;\n                        wt2_update = 0 ;\n                        bias_update = 0 ;     \n                    end    \n                    percep_wt_1_reg = percep_wt_1_reg + wt1_update;\n                    percep_wt_2_reg = percep_wt_2_reg + wt2_update;\n                    percep_bias_reg = percep_bias_reg + bias_update;\n                    prev_wt1_update  = prev_wt1_update  + 4'd0;\n                    prev_wt2_update  = prev_wt2_update  + 4'd0;\n                    prev_bias_update = prev_bias_update + 4'd0;\n                    y_in = y_in + 4'd0;\n                    y = y + 4'd0;\n                    stop = stop + 1'b0;\n                    input_index = input_index + 0;\n                    next_addr = next_addr + 4'd0;\n                    target = target + 4'd0;\n                    epoch_counter = epoch_counter + 0;\n                end\n         4'd4 : begin\n                  if ((prev_wt1_update == wt1_update) & (prev_wt2_update == wt2_update) & (input_index == 4'd3)) begin \n                          epoch_counter = 0;\n                          stop = 1'b1; \n                          input_index = 0;\n                          next_addr = 4'd0;\n                          percep_wt_1_reg = 0;\n                          percep_wt_2_reg = 0;\n                          percep_bias_reg = 0;\n                          prev_wt1_update =  0;\n                          prev_wt2_update =  0;\n                          prev_bias_update = 0;\n                          y_in = 0;\n                          y = 0;\n                          target = 0;\n                          wt1_update = 0 ;\n                          wt2_update = 0 ;\n                          bias_update = 0 ;\n                  end else begin\n                          stop = 1'b0; \n                          input_index = input_index + 0;\n                          epoch_counter = epoch_counter + 1;    \n                          next_addr = 4'd5;    \n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update = prev_wt1_update + 4'd0;\n                          prev_wt2_update = prev_wt2_update + 4'd0;\n                          prev_bias_update = prev_bias_update + 4'd0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0 ;\n                          wt2_update = wt2_update + 4'd0 ;\n                          bias_update = bias_update + 4'd0 ;\n                  end\n                end\n         4'd5 : begin\n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update  = wt1_update;\n                          prev_wt2_update  = wt2_update;\n                          prev_bias_update = bias_update;\n                          next_addr = 4'd1;\n                          input_index = input_index + 1;\n                          stop = stop + 1'b0;\n                          epoch_counter = epoch_counter + 0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0;\n                          wt2_update = wt2_update + 4'd0;\n                          bias_update = bias_update + 4'd0;\n                end   \n      default : begin\n                          next_addr = next_addr + 4'd0;\n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update = prev_wt1_update + 4'd0;\n                          prev_wt2_update = prev_wt2_update + 4'd0;\n                          prev_bias_update = prev_bias_update + 4'd0;\n                          stop = stop + 1'b0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          input_index = input_index + 0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0 ;\n                          wt2_update = wt2_update + 4'd0 ;\n                          bias_update = bias_update + 4'd0 ;\n                          epoch_counter = epoch_counter + 0;\n                end\n      endcase\n   end\n   assign percep_w1 = percep_wt_1_reg;\n   assign percep_w2 = percep_wt_2_reg;\n   assign percep_bias = percep_bias_reg;\n\nendmodule\n\nmodule gate_target(\n   input  logic        [1:0] gate_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always_comb begin\n     case(gate_select)\n          2'b00 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n          2'b01 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b10 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b11 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n        default : begin\n                    o_1 =  0; \n                    o_2 =  0; \n                    o_3 =  0; \n                    o_4 =  0; \n                  end\n        endcase\n   end\nendmodule"}, "output": {"rtl/perceptron_gates.sv": "module perceptron_gates (\n   input  logic clk,// Posedge clock\n   input  logic rst_n,// Negedge reset\n   input  logic signed [3:0] x1, // First Input of the Perceptron\n   input  logic signed [3:0] x2, // Second Input of the Perceptron\n   input  logic learning_rate, // Learning rate (alpha)\n   input  logic signed [3:0] threshold, // Threshold value\n   input  logic [1:0] gate_select, // Gate selection for target values\n   output logic signed [3:0] percep_w1, // Trained Weight 1 \n   output logic signed [3:0] percep_w2, // Trained Weight 2\n   output logic signed [3:0] percep_bias, // Trained Bias\n   output logic [3:0] present_addr, // Current address in microcode ROM\n   output logic stop, // Condition to indicate no learning has occurred(i.e. no weight change between iterations)\n   output logic [2:0] input_index,// Vector to track the selection of target for a given input combination for a gate\n   output logic signed [3:0] y_in, // Calculated Response\n   output logic signed [3:0] y, // Calculated Response obtained by comparing y_in against a threshold value\n   output logic signed [3:0] prev_percep_wt_1,//Value of Weight 1 during a previous iteration\n   output logic signed [3:0] prev_percep_wt_2,//Value of Weight 2 during a previous iteration\n   output logic signed [3:0] prev_percep_bias // Value of Bias during a previous iteration\n);\n\n   logic [15:0] microcode_rom [0:5];\n   logic [3:0]  next_addr;\n   logic [3:0]  train_action;\n   logic [3:0]  microcode_addr;\n   logic [15:0] microinstruction;\n   logic signed [3:0] t1, t2, t3, t4;\n   \n   gate_target dut (\n       .gate_select(gate_select),\n       .o_1(t1),\n       .o_2(t2),\n       .o_3(t3),\n       .o_4(t4)\n   );\n\n   logic signed [3:0] percep_wt_1_reg;\n   logic signed [3:0] percep_wt_2_reg;\n   logic signed [3:0] percep_bias_reg;\n\n   \n   logic signed [3:0] target;\n   logic signed [3:0] prev_wt1_update;\n   logic signed [3:0] prev_wt2_update;\n   logic signed [3:0] prev_bias_update;\n   \n   logic signed [3:0] wt1_update;\n   logic signed [3:0] wt2_update;\n   logic signed [3:0] bias_update;\n   logic [7:0] epoch_counter;\n   \n   assign  prev_percep_wt_1 = prev_wt1_update;\n   assign  prev_percep_wt_2 = prev_wt2_update;\n   assign  prev_percep_bias = prev_bias_update;\n\n   initial begin \n      microcode_rom[0] = 16'b0001_0000_0000_0000; \n      microcode_rom[1] = 16'b0010_0001_0000_0000; \n      microcode_rom[2] = 16'b0011_0010_0000_0000; \n      microcode_rom[3] = 16'b0100_0011_0000_0000; \n      microcode_rom[4] = 16'b0101_0100_0000_0000; \n      microcode_rom[5] = 16'b0000_0101_0000_0000; \n   end  \n   \n   always@(*) begin\n      microinstruction = microcode_rom[microcode_addr];\n      next_addr        = microinstruction[15:12];\n      train_action     = microinstruction[11:8];\n   end\n\n   always_ff @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n         present_addr    <= 4'd0;\n         microcode_addr  <= 4'd0;\n         percep_wt_1_reg <= 4'd0;\n         percep_wt_2_reg <= 4'd0;\n         percep_bias_reg <= 4'd0;\n         input_index     <= 2'd0;\n         stop            <= 1'b0;\n      end else begin\n         present_addr    <= next_addr;\n         microcode_addr  <= present_addr;\n      end\n   end\n\n   always_comb begin\n      case (train_action)\n         4'd0:  begin \n                   percep_wt_1_reg = 4'd0;\n                   percep_wt_2_reg = 4'd0;\n                   percep_bias_reg = 4'd0;\n                   stop = 1'b0;\n                   next_addr = next_addr + 4'd0;\n                   y_in = 4'd0;\n                   y    = 4'd0;\n                   prev_wt1_update = 4'd0;\n                   prev_wt2_update = 4'd0;\n                   prev_bias_update = 4'd0;\n                   input_index = 0;\n                   target = 0;\n                   wt1_update = 0;\n                   wt2_update = 0;\n                   bias_update = 0;\n                   epoch_counter = 0;\n                end\n         4'd1 : begin \n                   y_in = percep_bias_reg + (x1 * percep_wt_1_reg) + (x2 * percep_wt_2_reg); \n                   if (y_in > threshold)\n                      y = 4'd1;\n                   else if (y_in >= -threshold && y_in <= threshold)\n                      y = 4'd0;\n                   else\n                      y = -4'd1;\n                \n                   percep_wt_1_reg  = percep_wt_1_reg  + 4'd0;\n                   percep_wt_2_reg  = percep_wt_2_reg  + 4'd0;\n                   percep_bias_reg  = percep_bias_reg  + 4'd0;\n                   prev_wt1_update  = prev_wt1_update  + 4'd0;\n                   prev_wt2_update  = prev_wt2_update  + 4'd0;\n                   prev_bias_update = prev_bias_update + 4'd0;\n                   input_index = input_index + 0;\n                   next_addr = next_addr + 4'd0;\n                   stop = stop + 1'b0;\n                   target = target + 4'd0;\n                   wt1_update = wt1_update + 4'd0 ;\n                   wt2_update = wt2_update + 4'd0 ;\n                   bias_update = bias_update + 4'd0 ;\n                   epoch_counter = epoch_counter + 0;\n                end\n         4'd2 : begin\n                   if(input_index == 0)\n                        target = t1;\n                   else if(input_index == 1)\n                        target = t2;\n                   else if(input_index == 2)\n                        target = t3;\n                   else if(input_index == 3)\n                        target = t4;\n                   else begin\n                        input_index = 0;\n                        target = 0;\n                   end\n                   stop = stop + 1'b0;\n                   input_index = input_index + 0;\n                   next_addr = next_addr + 4'd0;\n                   target = target + 4'd0;\n                   prev_wt1_update  = prev_wt1_update  + 4'd0;\n                   prev_wt2_update  = prev_wt2_update  + 4'd0;\n                   prev_bias_update = prev_bias_update + 4'd0;\n                   \n                   percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                   percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                   percep_bias_reg = percep_bias_reg + 4'd0;\n                   y_in = y_in + 4'd0;\n                   y = y + 4'd0;\n                   wt1_update = wt1_update + 4'd0 ;\n                   wt2_update = wt2_update + 4'd0 ;\n                   bias_update = bias_update + 4'd0 ;\n                   epoch_counter = epoch_counter + 0;\n                end\n         4'd3 : begin\n                   if (y != target) begin\n                        wt1_update = learning_rate * x1 * target ;\n                        wt2_update = learning_rate * x2 * target ;\n                        bias_update = learning_rate * target ; \n                    end else begin\n                        wt1_update = 0 ;\n                        wt2_update = 0 ;\n                        bias_update = 0 ;     \n                    end    \n                    percep_wt_1_reg = percep_wt_1_reg + wt1_update;\n                    percep_wt_2_reg = percep_wt_2_reg + wt2_update;\n                    percep_bias_reg = percep_bias_reg + bias_update;\n                    prev_wt1_update  = prev_wt1_update  + 4'd0;\n                    prev_wt2_update  = prev_wt2_update  + 4'd0;\n                    prev_bias_update = prev_bias_update + 4'd0;\n                    y_in = y_in + 4'd0;\n                    y = y + 4'd0;\n                    stop = stop + 1'b0;\n                    input_index = input_index + 0;\n                    next_addr = next_addr + 4'd0;\n                    target = target + 4'd0;\n                    epoch_counter = epoch_counter + 0;\n                end\n         4'd4 : begin\n                  if ((prev_wt1_update == wt1_update) & (prev_wt2_update == wt2_update) & (input_index == 4'd3)) begin \n                          epoch_counter = 0;\n                          stop = 1'b1; \n                          input_index = 0;\n                          next_addr = 4'd0;\n                          percep_wt_1_reg = 0;\n                          percep_wt_2_reg = 0;\n                          percep_bias_reg = 0;\n                          prev_wt1_update =  0;\n                          prev_wt2_update =  0;\n                          prev_bias_update = 0;\n                          y_in = 0;\n                          y = 0;\n                          target = 0;\n                          wt1_update = 0 ;\n                          wt2_update = 0 ;\n                          bias_update = 0 ;\n                  end else begin\n                          stop = 1'b0; \n                          input_index = input_index + 0;\n                          epoch_counter = epoch_counter + 1;    \n                          next_addr = 4'd5;    \n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update = prev_wt1_update + 4'd0;\n                          prev_wt2_update = prev_wt2_update + 4'd0;\n                          prev_bias_update = prev_bias_update + 4'd0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0 ;\n                          wt2_update = wt2_update + 4'd0 ;\n                          bias_update = bias_update + 4'd0 ;\n                  end\n                end\n         4'd5 : begin\n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update  = wt1_update;\n                          prev_wt2_update  = wt2_update;\n                          prev_bias_update = bias_update;\n                          next_addr = 4'd1;\n                          input_index = input_index + 1;\n                          stop = stop + 1'b0;\n                          epoch_counter = epoch_counter + 0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0;\n                          wt2_update = wt2_update + 4'd0;\n                          bias_update = bias_update + 4'd0;\n                end   \n      default : begin\n                          next_addr = next_addr + 4'd0;\n                          percep_wt_1_reg = percep_wt_1_reg + 4'd0;\n                          percep_wt_2_reg = percep_wt_2_reg + 4'd0;\n                          percep_bias_reg = percep_bias_reg + 4'd0;\n                          prev_wt1_update = prev_wt1_update + 4'd0;\n                          prev_wt2_update = prev_wt2_update + 4'd0;\n                          prev_bias_update = prev_bias_update + 4'd0;\n                          stop = stop + 1'b0;\n                          y_in = y_in + 4'd0;\n                          y = y + 4'd0;\n                          input_index = input_index + 0;\n                          target = target + 4'd0;\n                          wt1_update = wt1_update + 4'd0 ;\n                          wt2_update = wt2_update + 4'd0 ;\n                          bias_update = bias_update + 4'd0 ;\n                          epoch_counter = epoch_counter + 0;\n                end\n      endcase\n   end\n   assign percep_w1 = percep_wt_1_reg;\n   assign percep_w2 = percep_wt_2_reg;\n   assign percep_bias = percep_bias_reg;\n\nendmodule\n\nmodule gate_target(\n   input  logic        [1:0] gate_select,\n   output logic signed [3:0] o_1,\n   output logic signed [3:0] o_2,\n   output logic signed [3:0] o_3,\n   output logic signed [3:0] o_4\n);\n   always_comb begin\n     case(gate_select)\n          2'b00 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n          2'b01 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b10 : begin \n                    o_1 =  1; \n                    o_2 =  1; \n                    o_3 =  1; \n                    o_4 = -1; \n                  end\n          2'b11 : begin \n                    o_1 =  1; \n                    o_2 = -1; \n                    o_3 = -1; \n                    o_4 = -1; \n                  end\n        default : begin\n                    o_1 =  0; \n                    o_2 =  0; \n                    o_3 =  0; \n                    o_4 =  0; \n                  end\n        endcase\n   end\nendmodule"}, "obj": true}}
{"cvdp_copilot_perceptron_0013": {"input": {}, "output": {"rtl/perceptron_gates.sv": ""}, "obj": true}}
{"cvdp_copilot_perf_counters_0001": {"input": {}, "output": {"rtl/cvdp_copilot_perf_counters.sv": ""}, "obj": true}}
{"cvdp_copilot_perfect_squares_0001": {"input": {}, "output": {"rtl/perfect_squares_generator.sv": ""}, "obj": true}}
{"cvdp_copilot_ping_pong_buffer_0001": {"input": {"rtl/dual_port_memory.sv": "module dual_port_memory (\n    input logic clk,\n    input logic we,\n    input logic [7:0] write_addr,\n    input logic [7:0] din,\n    input logic [7:0] read_addr,\n    output logic [7:0] dout\n);\n\n    logic [7:0] mem [255:0];\n\n    always_ff @(posedge clk) begin\n        if (we) begin\n            mem[write_addr] <= din;\n        end\n    end\n\n    assign dout = mem[read_addr];\nendmodule"}, "output": {"rtl/ping_pong_buffer.sv": "", "rtl/dual_port_memory.sv": ""}, "obj": true}}
{"cvdp_copilot_pipeline_mac_0017": {"input": {}, "output": {"rtl/pipeline_mac.sv": ""}, "obj": true}}
{"cvdp_copilot_piso_0001": {"input": {}, "output": {"rtl/piso_8bit.sv": ""}, "obj": true}}
{"cvdp_copilot_pkt_detector_0001": {"input": {}, "output": {"rtl/pkt_detector.sv": ""}, "obj": true}}
{"cvdp_copilot_prbs_gen_0003": {"input": {}, "output": {"rtl/cvdp_prbs_gen.sv": ""}, "obj": true}}
{"cvdp_copilot_prim_max_0001": {"input": {"rtl/prim_max_find.sv": "module prim_max_find #(\n  parameter int NumSrc = 8,\n  parameter int Width = 8,\n  // Derived parameters\n  localparam int SrcWidth = $clog2(NumSrc),\n  localparam int NumLevels = $clog2(NumSrc) - 1,\n  localparam int NumNodes = 2**(NumLevels+1)\n) (\n  input                         clk_i,\n  input                         rst_ni,\n  input [Width*NumSrc-1:0]      values_i,    // Flattened Input values\n  input [NumSrc-1:0]            valid_i,     // Input valid bits\n  output wire [Width-1:0]       max_value_o, // Maximum value\n  output wire [SrcWidth-1:0]    max_idx_o,   // Index of the maximum value\n  output wire                   max_valid_o  // Whether any of the inputs is valid\n);\n\n  reg [NumNodes-1:0]                vld_tree [0:NumLevels];\n  reg [SrcWidth-1:0]                 idx_tree [0:NumLevels][NumNodes-1:0];\n  reg [Width-1:0]                    max_tree [0:NumLevels][NumNodes-1:0];\n\n  generate\n    for (genvar level = 0; level <= NumLevels; level++) begin : gen_tree\n      localparam int Base0 = (2**level);\n      localparam int Base1 = (2**(level+1));\n\n      for (genvar offset = 0; offset < 2**level; offset++) begin : gen_level\n        localparam int Pa = Base0 + offset;\n        localparam int C0 = Base1 + 2*offset;\n        localparam int C1 = Base1 + 2*offset + 1;\n\n        if (level == NumLevels) begin : gen_leafs\n          if (offset < NumSrc) begin : gen_assign\n            always @(posedge clk_i or negedge rst_ni) begin\n              if (!rst_ni) begin\n                vld_tree[level][Pa] <= 1'b0;\n                idx_tree[level][Pa] <= '0;\n                max_tree[level][Pa] <= '0;\n              end else begin\n                vld_tree[level][Pa] <= valid_i[offset];\n                idx_tree[level][Pa] <= offset;\n                max_tree[level][Pa] <= values_i[(offset+1)*Width : offset*Width];\n              end\n            end\n          end else begin : gen_tie_off\n            always @(posedge clk_i or negedge rst_ni) begin\n              if (!rst_ni) begin\n                vld_tree[level][Pa] <= 1'b0;\n                idx_tree[level][Pa] <= '0;\n                max_tree[level][Pa] <= '0;\n              end\n            end\n          end\n        end\n\n        else begin : gen_nodes\n          reg sel; \n          always @(posedge clk_i or negedge rst_ni) begin\n            if (!rst_ni) begin\n              vld_tree[level][Pa] <= 1'b0;\n              idx_tree[level][Pa] <= '0;\n              max_tree[level][Pa] <= '0;\n            end else begin\n              sel = (~vld_tree[level+1][C0] & vld_tree[level+1][C1]) |\n                    (vld_tree[level+1][C0] & vld_tree[level+1][C1] & (max_tree[level+1][C1] > max_tree[level+1][C0]));\n\n              vld_tree[level][Pa] <= (sel) ? vld_tree[level+1][C1] : vld_tree[level+1][C0];\n              idx_tree[level][Pa] <= (sel) ? idx_tree[level+1][C1] : idx_tree[level+1][C0];\n              max_tree[level][Pa] <= (sel) ? max_tree[level+1][C1] : max_tree[level+1][C0];\n            end\n          end\n        end\n      end : gen_level\n    end : gen_tree\n  endgenerate\n\n  assign max_valid_o = vld_tree[0][0];\n  assign max_idx_o   = idx_tree[0][0];\n  assign max_value_o = max_tree[0][0];\n\nendmodule"}, "output": {"rtl/prim_max_find.sv": ""}, "obj": true}}
{"cvdp_copilot_radix2_div_0001": {"input": {"rtl/radix2_div.sv": "module radix2_div(\n    input            clk,\n    input            rst_n,\n    input            start,\n    input      [7:0] dividend,\n    input      [7:0] divisor,\n    output reg [7:0] quotient,\n    output reg [7:0] remainder,\n    output reg       done\n);\n\n    reg [7:0] rem;\n    reg [3:0] bit_counter;\n    reg [7:0] divisor_reg;\n    reg       busy;\n\n    // Normal, correct shift and compare logic\n    wire [8:0] shifted_rem = {rem, dividend[bit_counter]};\n    wire       bit_set     = shifted_rem >= {1'b0, divisor_reg};\n    wire [8:0] next_rem    = bit_set ? (shifted_rem - {1'b0, divisor_reg}) : shifted_rem;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            quotient <= 8'd0;\n        else if (start && !busy) begin\n            if (divisor == 8'd0)\n                quotient <= 8'hFF;\n            else\n                quotient <= 8'd0;\n        end\n        else if (busy) begin\n            quotient[bit_counter] <= bit_set;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            rem <= 8'd0;\n        else if (start && !busy)\n            rem <= 8'd0;\n        else if (busy)\n            rem <= next_rem[7:0];\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            remainder <= 8'd0;\n        else if (start && !busy && divisor == 8'd0)\n            remainder <= 8'hFF;\n        else if (busy && bit_counter == 4'd0) begin\n            if (next_rem[7:0] != 8'd0)\n                remainder <= next_rem[7:0] + 1'b1;\n            else\n                remainder <= next_rem[7:0];\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            bit_counter <= 4'd0;\n        else if (start && !busy) begin\n            if (divisor != 8'd0)\n                bit_counter <= 4'd7;  // Start from MSB\n        end\n        else if (busy && bit_counter != 4'd0) begin\n            bit_counter <= bit_counter - 4'd1; // Normal decrement\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            divisor_reg <= 8'd0;\n        else if (start && !busy && divisor != 8'd0)\n            divisor_reg <= divisor;\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            done <= 1'b0;\n        else if (start && !busy) begin\n            if (divisor == 8'd0)\n                done <= 1'b1;\n            else\n                done <= 1'b0;\n        end\n        else if (busy && bit_counter == 4'd0)\n            done <= 1'b1;\n        else\n            done <= 1'b0;\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            busy <= 1'b0;\n        else if (start && !busy) begin\n            if (divisor != 8'd0)\n                busy <= 1'b1;\n            else\n                busy <= 1'b0;\n        end\n        else if (busy && bit_counter == 4'd0)\n            busy <= 1'b0;\n    end\n\nendmodule"}, "output": {"rtl/radix2_div.sv": "module radix2_div(\n    input            clk,\n    input            rst_n,\n    input            start,\n    input      [7:0] dividend,\n    input      [7:0] divisor,\n    output reg [7:0] quotient,\n    output reg [7:0] remainder,\n    output reg       done\n);\n\n    reg [7:0] rem;\n    reg [3:0] bit_counter;\n    reg [7:0] divisor_reg;\n    reg       busy;\n\n    // Normal, correct shift and compare logic\n    wire [8:0] shifted_rem = {rem, dividend[bit_counter]};\n    wire       bit_set     = shifted_rem >= {1'b0, divisor_reg};\n    wire [8:0] next_rem    = bit_set ? (shifted_rem - {1'b0, divisor_reg}) : shifted_rem;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            quotient <= 8'd0;\n        else if (start && !busy) begin\n            if (divisor == 8'd0)\n                quotient <= 8'hFF;\n            else\n                quotient <= 8'd0;\n        end\n        else if (busy) begin\n            quotient[bit_counter] <= bit_set;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            rem <= 8'd0;\n        else if (start && !busy)\n            rem <= 8'd0;\n        else if (busy)\n            rem <= next_rem[7:0];\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            remainder <= 8'd0;\n        else if (start && !busy && divisor == 8'd0)\n            remainder <= 8'hFF;\n        else if (busy && bit_counter == 4'd0) begin\n            if (next_rem[7:0] != 8'd0)\n                remainder <= next_rem[7:0] + 1'b1;\n            else\n                remainder <= next_rem[7:0];\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            bit_counter <= 4'd0;\n        else if (start && !busy) begin\n            if (divisor != 8'd0)\n                bit_counter <= 4'd7;  // Start from MSB\n        end\n        else if (busy && bit_counter != 4'd0) begin\n            bit_counter <= bit_counter - 4'd1; // Normal decrement\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            divisor_reg <= 8'd0;\n        else if (start && !busy && divisor != 8'd0)\n            divisor_reg <= divisor;\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            done <= 1'b0;\n        else if (start && !busy) begin\n            if (divisor == 8'd0)\n                done <= 1'b1;\n            else\n                done <= 1'b0;\n        end\n        else if (busy && bit_counter == 4'd0)\n            done <= 1'b1;\n        else\n            done <= 1'b0;\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            busy <= 1'b0;\n        else if (start && !busy) begin\n            if (divisor != 8'd0)\n                busy <= 1'b1;\n            else\n                busy <= 1'b0;\n        end\n        else if (busy && bit_counter == 4'd0)\n            busy <= 1'b0;\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_reed_solomon_encoder_and_decoder_0005": {"input": {}, "output": {"rtl/reed_solomon_encoder.sv": ""}, "obj": true}}
{"cvdp_copilot_register_file_2R1W_0006": {"input": {"rtl/cvdp_copilot_register_file_2R1W.sv": "module cvdp_copilot_register_file_2R1W #(\n    parameter DATA_WIDTH = 32  // Configurable data width\n) (\n    // Inputs\n    input  logic [DATA_WIDTH-1:0] din,    // Input data\n    input  logic [4:0] wad1,              // Write address\n    input  logic [4:0] rad1,              // Read address 1\n    input  logic [4:0] rad2,              // Read address 2\n    input  logic wen1,                    // Write-enable signal\n    input  logic ren1,                    // Read-enable signal 1\n    input  logic ren2,                    // Read-enable signal 2\n    input  logic clk,                     // Clock signal\n    input  logic resetn,                  // Active-low reset\n\n    // Outputs\n    output logic [DATA_WIDTH-1:0] dout1,   // Output data 1\n    output logic [DATA_WIDTH-1:0] dout2,   // Output data 2\n    output logic collision                 // Collision flag\n);\n\n    // -------------------------------\n    // Internal Registers and Wires\n    // -------------------------------\n\n    // Register file memory with 32 entries of DATA_WIDTH-bit words\n    logic [DATA_WIDTH-1:0] rf_mem [0:31];\n    logic [31:0] rf_valid;                   // Validity of each register entry\n    integer i;\n\n    // Clock Gating Enable Signal: High when any read or write operation is active\n    wire clk_en = wen1 | ren1 | ren2;\n\n    // Clock Gating Logic (Integrated from cgate module)\n    logic gated_clk;    // Gated clock output\n    logic en_latch;     // Enable latch\n\n    // Latch to hold the enable signal when clk is low\n    always @ (clk or clk_en) begin\n        if (!clk)\n            en_latch <= clk_en;\n    end\n\n    // Gated clock generation\n    assign gated_clk = clk && en_latch;\n\n    // -------------------------------\n    // Register File Operations\n    // -------------------------------\n\n    // Reset and Write Operation Logic with Gated Clock\n    always_ff @(posedge gated_clk or negedge resetn) begin\n        if (!resetn) begin\n            // Initialize all memory locations to zero\n            for (i = 0; i < 32; i = i + 1) begin\n                rf_mem[i] <= {DATA_WIDTH{1'b0}};\n            end\n            rf_valid <= 0;  // Mark all entries as invalid\n        end \n        else if (wen1) begin\n            rf_mem[wad1]    <= din;  // Write operation\n            rf_valid[wad1]  <= 1;    // Mark written address as valid\n        end\n    end\n\n    // Read Data Output Logic for Port 1 with Gated Clock\n    always_ff @(posedge gated_clk or negedge resetn) begin\n        if (!resetn) begin\n            dout1 <= 0;\n        end \n        else if (ren1) begin\n            dout1 <= rf_valid[rad1] ? rf_mem[rad1] : 0;\n        end \n        else begin\n            dout1 <= 0;\n        end\n    end\n\n    // Read Data Output Logic for Port 2 with Gated Clock\n    always_ff @(posedge gated_clk or negedge resetn) begin\n        if (!resetn) begin\n            dout2 <= 0;\n        end \n        else if (ren2) begin\n            dout2 <= rf_valid[rad2] ? rf_mem[rad2] : 0;\n        end \n        else begin\n            dout2 <= 0;\n        end\n    end\n\n    // -------------------------------\n    // Collision Detection Logic\n    // -------------------------------\n\n    // Collision Flag Logic with Original Clock (non-gated)\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            collision <= 0;\n        end \n        else begin\n            collision <= (\n                (ren1 && ren2 && (rad1 == rad2)) ||          // Both reads to the same address\n                (wen1 && ren1 && (wad1 == rad1)) ||          // Write and read to the same address\n                (wen1 && ren2 && (wad1 == rad2))             // Write and read to the same address\n            );\n        end\n    end\n\nendmodule"}, "output": {"rtl/cvdp_copilot_register_file_2R1W.sv": "module cvdp_copilot_register_file_2R1W #(\n    parameter DATA_WIDTH = 32  // Configurable data width\n) (\n    // Inputs\n    input  logic [DATA_WIDTH-1:0] din,    // Input data\n    input  logic [4:0] wad1,              // Write address\n    input  logic [4:0] rad1,              // Read address 1\n    input  logic [4:0] rad2,              // Read address 2\n    input  logic wen1,                    // Write-enable signal\n    input  logic ren1,                    // Read-enable signal 1\n    input  logic ren2,                    // Read-enable signal 2\n    input  logic clk,                     // Clock signal\n    input  logic resetn,                  // Active-low reset\n\n    // Outputs\n    output logic [DATA_WIDTH-1:0] dout1,   // Output data 1\n    output logic [DATA_WIDTH-1:0] dout2,   // Output data 2\n    output logic collision                 // Collision flag\n);\n\n    // -------------------------------\n    // Internal Registers and Wires\n    // -------------------------------\n\n    // Register file memory with 32 entries of DATA_WIDTH-bit words\n    logic [DATA_WIDTH-1:0] rf_mem [0:31];\n    logic [31:0] rf_valid;                   // Validity of each register entry\n    integer i;\n\n    // Clock Gating Enable Signal: High when any read or write operation is active\n    wire clk_en = wen1 | ren1 | ren2;\n\n    // Clock Gating Logic (Integrated from cgate module)\n    logic gated_clk;    // Gated clock output\n    logic en_latch;     // Enable latch\n\n    // Latch to hold the enable signal when clk is low\n    always @ (clk or clk_en) begin\n        if (!clk)\n            en_latch <= clk_en;\n    end\n\n    // Gated clock generation\n    assign gated_clk = clk && en_latch;\n\n    // -------------------------------\n    // Register File Operations\n    // -------------------------------\n\n    // Reset and Write Operation Logic with Gated Clock\n    always_ff @(posedge gated_clk or negedge resetn) begin\n        if (!resetn) begin\n            // Initialize all memory locations to zero\n            for (i = 0; i < 32; i = i + 1) begin\n                rf_mem[i] <= {DATA_WIDTH{1'b0}};\n            end\n            rf_valid <= 0;  // Mark all entries as invalid\n        end \n        else if (wen1) begin\n            rf_mem[wad1]    <= din;  // Write operation\n            rf_valid[wad1]  <= 1;    // Mark written address as valid\n        end\n    end\n\n    // Read Data Output Logic for Port 1 with Gated Clock\n    always_ff @(posedge gated_clk or negedge resetn) begin\n        if (!resetn) begin\n            dout1 <= 0;\n        end \n        else if (ren1) begin\n            dout1 <= rf_valid[rad1] ? rf_mem[rad1] : 0;\n        end \n        else begin\n            dout1 <= 0;\n        end\n    end\n\n    // Read Data Output Logic for Port 2 with Gated Clock\n    always_ff @(posedge gated_clk or negedge resetn) begin\n        if (!resetn) begin\n            dout2 <= 0;\n        end \n        else if (ren2) begin\n            dout2 <= rf_valid[rad2] ? rf_mem[rad2] : 0;\n        end \n        else begin\n            dout2 <= 0;\n        end\n    end\n\n    // -------------------------------\n    // Collision Detection Logic\n    // -------------------------------\n\n    // Collision Flag Logic with Original Clock (non-gated)\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            collision <= 0;\n        end \n        else begin\n            collision <= (\n                (ren1 && ren2 && (rad1 == rad2)) ||          // Both reads to the same address\n                (wen1 && ren1 && (wad1 == rad1)) ||          // Write and read to the same address\n                (wen1 && ren2 && (wad1 == rad2))             // Write and read to the same address\n            );\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_register_file_2R1W_0013": {"input": {}, "output": {"rtl/cvdp_copilot_register_file_2R1W.sv": ""}, "obj": true}}
{"cvdp_copilot_restoring_division_0001": {"input": {}, "output": {"rtl/restore_division.sv": ""}, "obj": true}}
{"cvdp_copilot_reverse_bits_0001": {"input": {}, "output": {"rtl/reverse_bits.v": ""}, "obj": true}}
{"cvdp_copilot_rgb2ycbcr_0001": {"input": {"rtl/axis_rgb2ycbcr.sv": "module axis_rgb2ycbcr #(\n    parameter PIXEL_WIDTH = 16,\n    parameter FIFO_DEPTH = 16\n)(\n    input  wire            aclk,\n    input  wire            aresetn,\n\n    // AXI Stream Slave Interface (Input)\n    input  wire [15:0]     s_axis_tdata,\n    input  wire            s_axis_tvalid,\n    output wire            s_axis_tready,\n    input  wire            s_axis_tlast,\n    input  wire            s_axis_tuser,\n\n    // AXI Stream Master Interface (Output)\n    output wire [15:0]     m_axis_tdata,\n    output wire            m_axis_tvalid,\n    input  wire            m_axis_tready,\n    output wire            m_axis_tlast,\n    output wire            m_axis_tuser\n);\n\n    // -----------------------------\n    // FIFO Buffer (16-depth buffer)\n    // -----------------------------\n    reg [15:0] fifo_data [0:FIFO_DEPTH-1];\n    reg        fifo_tlast [0:FIFO_DEPTH-1];\n    reg        fifo_tuser [0:FIFO_DEPTH-1];\n\n    reg [3:0]  write_ptr, read_ptr; // 4-bit pointers for FIFO\n    reg        full;\n    wire       empty;\n\n    wire       fifo_write = s_axis_tvalid && !full;\n    wire       fifo_read  = !empty && m_axis_tready;\n\n    // -----------------------------\n    // RGB Extraction \n    // -----------------------------\n    reg [7:0] r, g, b;\n    always @(posedge aclk) begin\n        if (!aresetn) begin\n            r <= 0; g <= 0; b <= 0;\n        end else if (fifo_write) begin\n            r <= {s_axis_tdata[15:11], 3'b0}; // 5-bit to 8-bit\n            g <= {s_axis_tdata[10:5],  2'b0}; // 6-bit to 8-bit\n            b <= {s_axis_tdata[4:0],   3'b0}; // 5-bit to 8-bit\n        end\n    end\n\n    // -----------------------------\n    // RGB to YCbCr Conversion\n    // -----------------------------\n    wire [7:0] y_calc  = (( 77 * r + 150 * g +  29 * b) >> 8) + 16;\n    wire [7:0] cb_calc = ((-43 * r - 85 * g + 128 * b) >> 8) + 128;\n    wire [7:0] cr_calc = ((128 * r - 107 * g - 21 * b) >> 8) + 128;\n\n    reg [7:0] y_reg, cb_reg, cr_reg;\n    always @(posedge aclk) begin\n        if (!aresetn) begin\n            y_reg <= 0; cb_reg <= 0; cr_reg <= 0;\n        end else if (fifo_write) begin\n            y_reg  <= y_calc;\n            cb_reg <= cb_calc;\n            cr_reg <= cr_calc;\n        end\n    end\n\n    // -----------------------------\n    // FIFO Buffer Write\n    // -----------------------------\n    always @(posedge aclk) begin\n        if (!aresetn) begin\n            write_ptr <= 0;\n            full <= 0;\n        end else if (fifo_write) begin\n            fifo_data[write_ptr] <= {y_reg[7:3], cb_reg[7:2], cr_reg[7:3]}; // Store YCbCr in buffer\n            fifo_tlast[write_ptr] <= s_axis_tlast;\n            fifo_tuser[write_ptr] <= s_axis_tuser;\n            write_ptr <= write_ptr + 1;\n            full <= (write_ptr == FIFO_DEPTH-1);\n        end\n    end\n\n    // -----------------------------\n    // FIFO Buffer Read\n    // -----------------------------\n    always @(posedge aclk) begin\n        if (!aresetn) begin\n            read_ptr <= 0;\n            //empty <= 1;\n        end else if (fifo_read) begin\n            read_ptr <= read_ptr + 1;\n        end\n    end\n    assign empty = (read_ptr == write_ptr);\n\n    // -----------------------------\n    // AXI-Stream Output Signals\n    // -----------------------------\n    assign s_axis_tready = !full; // Only accept data when FIFO is not full\n    assign m_axis_tvalid = !empty; // Only transmit when FIFO has data\n    assign m_axis_tdata  = fifo_data[read_ptr];\n    assign m_axis_tlast  = fifo_tlast[read_ptr];\n    assign m_axis_tuser  = fifo_tuser[read_ptr];\n\nendmodule"}, "output": {"rtl/axis_rgb2ycbcr.sv": "module axis_rgb2ycbcr #(\n    parameter PIXEL_WIDTH = 16,\n    parameter FIFO_DEPTH = 16\n)(\n    input  wire            aclk,\n    input  wire            aresetn,\n\n    // AXI Stream Slave Interface (Input)\n    input  wire [15:0]     s_axis_tdata,\n    input  wire            s_axis_tvalid,\n    output wire            s_axis_tready,\n    input  wire            s_axis_tlast,\n    input  wire            s_axis_tuser,\n\n    // AXI Stream Master Interface (Output)\n    output wire [15:0]     m_axis_tdata,\n    output wire            m_axis_tvalid,\n    input  wire            m_axis_tready,\n    output wire            m_axis_tlast,\n    output wire            m_axis_tuser\n);\n\n    // -----------------------------\n    // FIFO Buffer (16-depth buffer)\n    // -----------------------------\n    reg [15:0] fifo_data [0:FIFO_DEPTH-1];\n    reg        fifo_tlast [0:FIFO_DEPTH-1];\n    reg        fifo_tuser [0:FIFO_DEPTH-1];\n\n    reg [3:0]  write_ptr, read_ptr; // 4-bit pointers for FIFO\n    reg        full;\n    wire       empty;\n\n    wire       fifo_write = s_axis_tvalid && !full;\n    wire       fifo_read  = !empty && m_axis_tready;\n\n    // -----------------------------\n    // RGB Extraction \n    // -----------------------------\n    reg [7:0] r, g, b;\n    always @(posedge aclk) begin\n        if (!aresetn) begin\n            r <= 0; g <= 0; b <= 0;\n        end else if (fifo_write) begin\n            r <= {s_axis_tdata[15:11], 3'b0}; // 5-bit to 8-bit\n            g <= {s_axis_tdata[10:5],  2'b0}; // 6-bit to 8-bit\n            b <= {s_axis_tdata[4:0],   3'b0}; // 5-bit to 8-bit\n        end\n    end\n\n    // -----------------------------\n    // RGB to YCbCr Conversion\n    // -----------------------------\n    wire [7:0] y_calc  = (( 77 * r + 150 * g +  29 * b) >> 8) + 16;\n    wire [7:0] cb_calc = ((-43 * r - 85 * g + 128 * b) >> 8) + 128;\n    wire [7:0] cr_calc = ((128 * r - 107 * g - 21 * b) >> 8) + 128;\n\n    reg [7:0] y_reg, cb_reg, cr_reg;\n    always @(posedge aclk) begin\n        if (!aresetn) begin\n            y_reg <= 0; cb_reg <= 0; cr_reg <= 0;\n        end else if (fifo_write) begin\n            y_reg  <= y_calc;\n            cb_reg <= cb_calc;\n            cr_reg <= cr_calc;\n        end\n    end\n\n    // -----------------------------\n    // FIFO Buffer Write\n    // -----------------------------\n    always @(posedge aclk) begin\n        if (!aresetn) begin\n            write_ptr <= 0;\n            full <= 0;\n        end else if (fifo_write) begin\n            fifo_data[write_ptr] <= {y_reg[7:3], cb_reg[7:2], cr_reg[7:3]}; // Store YCbCr in buffer\n            fifo_tlast[write_ptr] <= s_axis_tlast;\n            fifo_tuser[write_ptr] <= s_axis_tuser;\n            write_ptr <= write_ptr + 1;\n            full <= (write_ptr == FIFO_DEPTH-1);\n        end\n    end\n\n    // -----------------------------\n    // FIFO Buffer Read\n    // -----------------------------\n    always @(posedge aclk) begin\n        if (!aresetn) begin\n            read_ptr <= 0;\n            //empty <= 1;\n        end else if (fifo_read) begin\n            read_ptr <= read_ptr + 1;\n        end\n    end\n    assign empty = (read_ptr == write_ptr);\n\n    // -----------------------------\n    // AXI-Stream Output Signals\n    // -----------------------------\n    assign s_axis_tready = !full; // Only accept data when FIFO is not full\n    assign m_axis_tvalid = !empty; // Only transmit when FIFO has data\n    assign m_axis_tdata  = fifo_data[read_ptr];\n    assign m_axis_tlast  = fifo_tlast[read_ptr];\n    assign m_axis_tuser  = fifo_tuser[read_ptr];\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_round_robin_arbiter_0005": {"input": {"rtl/round_robin_arbiter.sv": "module round_robin_arbiter #(\n    parameter N = 4\n)(\n    input  wire             clk,\n    input  wire             rstn,\n    input  wire [N-1:0]     req,   \n    output reg  [N-1:0]     grant   \n);\n\n    reg [$clog2(N)-1:0] pointer;\n    reg [$clog2(N)-1:0] pointer_next;\n    reg found;\n    \n    integer i;\n    always @(*) begin\n        grant        = {N{1'b0}};\n        pointer_next = pointer;\n        \n        if (req != 0) begin\n           found = 1'b0;\n            for (i = 0; i < N; i = i + 1) begin\n                if (!found && req[(pointer + i) % N] == 1'b1) begin\n                    grant[(pointer + i) % N] = 1'b1;\n                    \n                    pointer_next = (pointer + i + 1) % N;\n                    found        = 1'b1;                    \n                end\n            end\n        end\n    end\n\n    always @(posedge clk or negedge rstn) begin\n        if (!rstn) begin\n            pointer <= 0;\n        end else begin\n            pointer <= pointer_next;\n        end\n    end\n\nendmodule"}, "output": {"rtl/round_robin_arbiter.sv": "module round_robin_arbiter #(\n    parameter N = 4\n)(\n    input  wire             clk,\n    input  wire             rstn,\n    input  wire [N-1:0]     req,   \n    output reg  [N-1:0]     grant   \n);\n\n    reg [$clog2(N)-1:0] pointer;\n    reg [$clog2(N)-1:0] pointer_next;\n    reg found;\n    \n    integer i;\n    always @(*) begin\n        grant        = {N{1'b0}};\n        pointer_next = pointer;\n        \n        if (req != 0) begin\n           found = 1'b0;\n            for (i = 0; i < N; i = i + 1) begin\n                if (!found && req[(pointer + i) % N] == 1'b1) begin\n                    grant[(pointer + i) % N] = 1'b1;\n                    \n                    pointer_next = (pointer + i + 1) % N;\n                    found        = 1'b1;                    \n                end\n            end\n        end\n    end\n\n    always @(posedge clk or negedge rstn) begin\n        if (!rstn) begin\n            pointer <= 0;\n        end else begin\n            pointer <= pointer_next;\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_rounding_0001": {"input": {}, "output": {"rtl/rounding.sv": ""}, "obj": true}}
{"cvdp_copilot_rs_232_0001": {"input": {}, "output": {"rtl/copilot_rs_232.sv": ""}, "obj": true}}
{"cvdp_copilot_run_length_0001": {"input": {}, "output": {"rtl/run_length.sv": ""}, "obj": true}}
{"cvdp_copilot_run_length_0007": {"input": {"rtl/run_length.sv": "\nmodule run_length\n#(\n    parameter DATA_WIDTH = 8                        // Width of the output run-length counter\n)\n(\n    input wire clk,                                 // Clock signal      \n    input wire reset_n,                             // Active-low reset signal     \n    input wire data_in,                             // Input data stream\n    output reg  data_out,                           // Output data to indicate the previous data_in\n    output reg [$clog2(DATA_WIDTH):0] run_value,    // Output the run length value \n    output reg valid                                // Output valid flag for run length \n\n);\n\n    \n    reg [$clog2(DATA_WIDTH):0] run_length;\n    reg prev_data_in;\n\n    \n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            run_length   <= 'b0;           \n            run_value    <= 'b0;\t       \n            prev_data_in <= 1'b0;\t\t\t               \n        end\n        else begin\n             if (data_in == prev_data_in) begin\n                \n                if(run_length == (DATA_WIDTH)) begin\n                    run_value  <= run_length;\n                end\n                if (run_length < (DATA_WIDTH)) begin\n                    run_length <= run_length + 1'b1;\n                end\n                \n                else begin\n                    run_length <= 1'b1;\t\t\t            \n                end\n            end\n            else begin\n                run_value  <= run_length;\t\t            \n                run_length <= 1'b1;\t\t\t                \n            end\n            prev_data_in   <= data_in;\t\t\t            \n        end\n        \n    end\n    \n   \n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            valid    <= 1'b0;\t\t\t\t                \n            data_out <= 1'b0;\t\t\t\t                \n        end \n        else begin\n            if (run_length == (DATA_WIDTH) || data_in != prev_data_in) begin\n                valid    <= 1'b1;                          \t\t\t\t   \n                data_out <= prev_data_in;\t\t            \n            end\n            else begin\n                valid    <= 1'b0;\t\t\t                \n                data_out <= 1'b0;\t\t\t                \n            end\n        end \n    end\nendmodule"}, "output": {"rtl/run_length.sv": ""}, "obj": true}}
{"cvdp_copilot_scrambler_0001": {"input": {"rtl/scrambler.sv": "module scrambler #(\n    parameter DATA_WIDTH = 128   // Width of input data\n) (\n    input  logic                  clk,        // Clock signal\n    input  logic                  rst_n,      // Active-low reset\n    input  logic [DATA_WIDTH-1:0] data_in,    // Input data\n    input  logic [3:0]            mode,       // Mode to select polynomial\n    output logic [DATA_WIDTH-1:0] data_out    // Scrambled data\n);\n\n    localparam LFSR_WIDTH = 16;    // Width of the LFSR\n    localparam [LFSR_WIDTH-1:0] LFSR_INIT = {1'b0,1'b1,{(LFSR_WIDTH-2){1'b0}}};\n    // LFSR registers and feedback logic\n    logic [LFSR_WIDTH-1:0] lfsr;\n    logic feedback;\n\n    // Polynomial selection based on mode\n    always_comb begin\n        case (mode)\n            4'b0000: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-15];                // Mode 0: ( x^{16} + x^{15} + 1 )\n            4'b0001: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-14];                // Mode 1: ( x^{16} + x^{14} + 1 )\n            4'b0010: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-8] ^ lfsr[1];      // Mode 2: ( x^{16} + x^{8} + x + 1 )\n            4'b0011: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-8];                // Mode 3: ( x^{16} + x^{8} + 1 )\n            4'b0100: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-13] ^ lfsr[4];      // Mode 4: ( x^{16} + x^{13} + x^2 + 1 )\n            4'b0101: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-12];                // Mode 5: ( x^{16} + x^{12} + 1 )\n            4'b0110: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[3] ^ lfsr[0];                 // Mode 6: ( x^{16} + x^3 + x + 1 )\n            4'b0111: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-11] ^ lfsr[4];      // Mode 7: ( x^{16} + x^{11} + x^4 + 1 )\n            default: feedback = lfsr[LFSR_WIDTH-16];                                     // Default:( x^{16} + 1 )\n        endcase\n    end\n\n    // LFSR shift logic\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            lfsr <= LFSR_INIT; // Initialize LFSR with a fixed value\n        end else begin\n            lfsr <= {lfsr[LFSR_WIDTH-2:0], feedback};\n        end\n    end\n\n    // Scramble data block\n    genvar i;\n    generate\n        for (i = 0; i < DATA_WIDTH; i++) begin\n            assign data_out[i] = data_in[i] ^ lfsr[i % LFSR_WIDTH];\n        end\n    endgenerate\n\nendmodule"}, "output": {"rtl/scrambler.sv": "module scrambler #(\n    parameter DATA_WIDTH = 128   // Width of input data\n) (\n    input  logic                  clk,        // Clock signal\n    input  logic                  rst_n,      // Active-low reset\n    input  logic [DATA_WIDTH-1:0] data_in,    // Input data\n    input  logic [3:0]            mode,       // Mode to select polynomial\n    output logic [DATA_WIDTH-1:0] data_out    // Scrambled data\n);\n\n    localparam LFSR_WIDTH = 16;    // Width of the LFSR\n    localparam [LFSR_WIDTH-1:0] LFSR_INIT = {1'b0,1'b1,{(LFSR_WIDTH-2){1'b0}}};\n    // LFSR registers and feedback logic\n    logic [LFSR_WIDTH-1:0] lfsr;\n    logic feedback;\n\n    // Polynomial selection based on mode\n    always_comb begin\n        case (mode)\n            4'b0000: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-15];                // Mode 0: ( x^{16} + x^{15} + 1 )\n            4'b0001: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-14];                // Mode 1: ( x^{16} + x^{14} + 1 )\n            4'b0010: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-8] ^ lfsr[1];      // Mode 2: ( x^{16} + x^{8} + x + 1 )\n            4'b0011: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-8];                // Mode 3: ( x^{16} + x^{8} + 1 )\n            4'b0100: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-13] ^ lfsr[4];      // Mode 4: ( x^{16} + x^{13} + x^2 + 1 )\n            4'b0101: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-12];                // Mode 5: ( x^{16} + x^{12} + 1 )\n            4'b0110: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[3] ^ lfsr[0];                 // Mode 6: ( x^{16} + x^3 + x + 1 )\n            4'b0111: feedback = lfsr[LFSR_WIDTH-16] ^ lfsr[LFSR_WIDTH-11] ^ lfsr[4];      // Mode 7: ( x^{16} + x^{11} + x^4 + 1 )\n            default: feedback = lfsr[LFSR_WIDTH-16];                                     // Default:( x^{16} + 1 )\n        endcase\n    end\n\n    // LFSR shift logic\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            lfsr <= LFSR_INIT; // Initialize LFSR with a fixed value\n        end else begin\n            lfsr <= {lfsr[LFSR_WIDTH-2:0], feedback};\n        end\n    end\n\n    // Scramble data block\n    genvar i;\n    generate\n        for (i = 0; i < DATA_WIDTH; i++) begin\n            assign data_out[i] = data_in[i] ^ lfsr[i % LFSR_WIDTH];\n        end\n    endgenerate\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_scrambler_0009": {"input": {"rtl/deinter_block.sv": "module deinter_block #(\n    parameter ROW_COL_WIDTH = 16,\n    parameter SUB_BLOCKS    = 4,\n    parameter DATA_WIDTH    = ROW_COL_WIDTH*ROW_COL_WIDTH,\n    parameter OUT_DATA_WIDTH= 16,\n    parameter WAIT_CYCLES   = 4\n)(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic i_valid,\n    input  logic [DATA_WIDTH-1:0] in_data, // Input: 256 bits\n    output logic [OUT_DATA_WIDTH-1:0] out_data // Output: 256 bits rearranged\n);\n\nlocalparam CHUNK = 8;\nlocalparam NBW_COUNTER = $clog2(SUB_BLOCKS) + 1;\nlocalparam NBW_COUNTER_SUB_OUT = 2;\n\nlocalparam OUT_CYCLES = 32;\n\nlocalparam N_CYCLES = SUB_BLOCKS*DATA_WIDTH/OUT_DATA_WIDTH;\nlocalparam NBW_COUNTER_OUTPUT = $clog2(N_CYCLES);\nlogic [NBW_COUNTER_OUTPUT-1:0] counter_output;\n\nlogic [NBW_COUNTER-1:0] counter_sub_blocks;\nlogic [NBW_COUNTER_SUB_OUT-1:0] counter_sub_out;\n\nlogic [DATA_WIDTH-1:0] in_data_reg [SUB_BLOCKS-1:0];\nlogic [DATA_WIDTH-1:0] out_data_intra_block [SUB_BLOCKS-1:0];\nlogic [DATA_WIDTH-1:0] out_data_intra_block_reg [SUB_BLOCKS-1:0];\nlogic [DATA_WIDTH-1:0] out_data_aux [SUB_BLOCKS-1:0];\nlogic start_intra;\n\nalways_ff @(posedge clk or negedge rst_n ) begin\n   if(!rst_n) begin\n      counter_sub_blocks <= {NBW_COUNTER{1'b0}};\n      start_intra <= 0;\n      for(int i = 0; i < SUB_BLOCKS; i++) begin\n         in_data_reg[i] <= {DATA_WIDTH{1'b0}};\n      end\n   end\n   else begin\n      if(i_valid) begin\n         in_data_reg[counter_sub_blocks] <= in_data;\n\n         if(counter_sub_blocks == SUB_BLOCKS) begin\n            counter_sub_blocks <= {NBW_COUNTER{1'b0}};\n         end\n         else begin\n            start_intra <= 0;\n            counter_sub_blocks <= counter_sub_blocks + 1;\n         end\n      end\n      else if(counter_sub_blocks == SUB_BLOCKS) begin\n         start_intra        <= 1;\n         counter_sub_blocks <= {NBW_COUNTER{1'b0}};\n      end\n   end\nend\n\nalways_ff @(posedge clk or negedge rst_n) begin\n   if(!rst_n) begin\n      for(int i = 0; i < SUB_BLOCKS; i++)\n         out_data_intra_block_reg[i] <= {DATA_WIDTH{1'b0}};\n   end\n   else begin\n      if(start_intra)\n         for(int i = 0; i < SUB_BLOCKS; i++) \n            out_data_intra_block_reg[i] <= in_data_reg[i];\n   end\nend\n\nlogic [WAIT_CYCLES-1:0] start_intra_ff;\nlogic enable_output;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n   if(!rst_n) begin\n      enable_output  <= 0;\n      start_intra_ff <= 0;\n   end\n   else begin\n      enable_output <= start_intra_ff[WAIT_CYCLES-1];\n      start_intra_ff<= {start_intra_ff[WAIT_CYCLES-1:1],start_intra};\n   end\nend\n\nalways_ff @(posedge clk or negedge rst_n) begin\n   if(!rst_n) begin\n      for(int i = 0; i < SUB_BLOCKS; i++)\n         out_data_aux[i] <= {DATA_WIDTH{1'b0}};\n   end\n   else begin\n      if(start_intra) begin\n         for(int i = 0; i < 32; i++) begin\n            out_data_aux[0][(i+1)*CHUNK-1-:CHUNK] <= out_data_intra_block_reg[i%4][((i+1)*CHUNK)-1-:CHUNK];\n            out_data_aux[1][(i+1)*CHUNK-1-:CHUNK] <= out_data_intra_block_reg[i%4][(((i+1)%OUT_CYCLES+1)*CHUNK)-1-:CHUNK];\n            out_data_aux[2][(i+1)*CHUNK-1-:CHUNK] <= out_data_intra_block_reg[i%4][(((i+2)%OUT_CYCLES+1)*CHUNK)-1-:CHUNK];\n            out_data_aux[3][(i+1)*CHUNK-1-:CHUNK] <= out_data_intra_block_reg[i%4][(((i+3)%OUT_CYCLES+1)*CHUNK)-1-:CHUNK];\n         end\n      end\n   end\nend\n\nalways_ff @(posedge clk or negedge rst_n) begin\n   if(!rst_n) begin\n      out_data        <= {DATA_WIDTH{1'b0}};      \n      counter_sub_out <= {NBW_COUNTER_SUB_OUT{1'b0}};\n      counter_output  <= {NBW_COUNTER_OUTPUT{1'b0}};     \n   end\n   else begin\n      counter_sub_out <= counter_sub_out + 1;\n      counter_output  <= counter_output  + 1;\n      out_data        <= out_data_aux[counter_sub_out][((counter_output%(DATA_WIDTH/OUT_DATA_WIDTH) + 1))*OUT_DATA_WIDTH-1-:OUT_DATA_WIDTH];\n   end\nend\n\nendmodule"}, "output": {"rtl/deinter_block.sv": ""}, "obj": true}}
{"cvdp_copilot_scrambler_0018": {"input": {"rtl/inter_block.sv": "module inter_block #(\n    parameter ROW_COL_WIDTH = 16,\n    parameter SUB_BLOCKS    = 4,\n    parameter DATA_WIDTH    = ROW_COL_WIDTH*ROW_COL_WIDTH\n)(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic i_valid,\n    input  logic [DATA_WIDTH-1:0] in_data, // Input: 256 bits\n    output logic [DATA_WIDTH-1:0] out_data // Output: 256 bits rearranged\n);\n\nlocalparam CHUNK = 8;\nlocalparam NBW_COUNTER = $clog2(SUB_BLOCKS) + 1;\nlocalparam NBW_COUNTER_SUB_OUT = 2;\nlocalparam OUT_CYCLES = 32;\nlocalparam NBW_COUNTER_OUTPUT = $clog2(OUT_CYCLES);\nlogic [NBW_COUNTER_OUTPUT-1:0] counter_output;\nlogic [NBW_COUNTER-1:0] counter_sub_blocks;\nlogic [NBW_COUNTER_SUB_OUT-1:0] counter_sub_out;\n\nlogic [DATA_WIDTH-1:0] in_data_reg [SUB_BLOCKS-1:0];\nlogic [DATA_WIDTH-1:0] out_data_intra_block [SUB_BLOCKS-1:0];\nlogic [DATA_WIDTH-1:0] out_data_intra_block_reg [SUB_BLOCKS-1:0];\nlogic [DATA_WIDTH-1:0] out_data_aux [SUB_BLOCKS-1:0];\nlogic start_intra;\n\nalways_ff @(posedge clk or negedge rst_n ) begin\n   if(!rst_n) begin\n      counter_sub_blocks <= {NBW_COUNTER{1'b0}};\n      start_intra <= 0;\n      for(int i = 0; i < SUB_BLOCKS; i++) begin\n         in_data_reg[i] <= {DATA_WIDTH{1'b0}};\n      end\n   end\n   else begin\n      if(i_valid) begin\n         in_data_reg[counter_sub_blocks] <= in_data;\n\n         if(counter_sub_blocks == SUB_BLOCKS) begin\n            counter_sub_blocks <= {NBW_COUNTER{1'b0}};\n         end\n         else begin\n            start_intra <= 0;\n            counter_sub_blocks <= counter_sub_blocks + 1;\n         end\n      end\n      else if(counter_sub_blocks == SUB_BLOCKS) begin\n         start_intra        <= 1;\n         counter_sub_blocks <= {NBW_COUNTER{1'b0}};\n      end\n   end\nend\n\ngenvar k;\ngenerate \n   for(k = 0; k < SUB_BLOCKS; k++) begin\n      intra_block uu_intra_block (\n         .in_data(in_data_reg[k]),\n         .out_data(out_data_intra_block[k])\n      );\n   end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_n) begin\n   if(!rst_n) begin\n      for(int i = 0; i < SUB_BLOCKS; i++) begin\n         out_data_intra_block_reg[i] <= {DATA_WIDTH{1'b0}};\n      end\n   end\n   else begin\n      if(start_intra) begin\n         for(int i = 0; i < SUB_BLOCKS; i++) begin\n            out_data_intra_block_reg[i] <= out_data_intra_block[i];\n         end\n      end\n   end\nend\n\nalways_ff @(posedge clk or negedge rst_n) begin\n   if(!rst_n) begin\n      counter_sub_out <= {NBW_COUNTER_SUB_OUT{1'b1}};\n      out_data        <= {DATA_WIDTH{1'b0}};\n      for(int i = 0; i < SUB_BLOCKS; i++) begin\n         out_data_aux[i] <= {DATA_WIDTH{1'b0}};\n      end      \n   end\n   else begin\n      if(start_intra) begin\n         for(int i = 0; i < 32; i++) begin\n            out_data_aux[0][(i+1)*CHUNK-1-:CHUNK] = out_data_intra_block_reg[i%4][((i+1)*CHUNK)-1-:CHUNK];\n            out_data_aux[1][(i+1)*CHUNK-1-:CHUNK] = out_data_intra_block_reg[i%4][(((i+1)%OUT_CYCLES+1)*CHUNK)-1-:CHUNK];\n            out_data_aux[2][(i+1)*CHUNK-1-:CHUNK] = out_data_intra_block_reg[i%4][(((i+2)%OUT_CYCLES+1)*CHUNK)-1-:CHUNK];\n            out_data_aux[3][(i+1)*CHUNK-1-:CHUNK] = out_data_intra_block_reg[i%4][(((i+3)%OUT_CYCLES+1)*CHUNK)-1-:CHUNK];\n         end\n         counter_sub_out <= counter_sub_out + 1;\n         out_data        <= out_data_aux[counter_sub_out];\n      end\n   end\nend\n\nendmodule", "rtl/intra_block.sv": "module intra_block #(\n    parameter ROW_COL_WIDTH = 16,\n    parameter DATA_WIDTH = ROW_COL_WIDTH*ROW_COL_WIDTH\n)(\n    input logic [DATA_WIDTH-1:0] in_data,  // Input: 256 bits\n    output logic [DATA_WIDTH-1:0] out_data // Output: 256 bits rearranged\n);\n\n    // Temporary storage for intermediate calculations\n    logic [3:0] r_prime [0:255]; // Row index for each bit\n    logic [3:0] c_prime [0:255]; // Column index for each bit\n\n    logic [ROW_COL_WIDTH-1:0] prev_out_data [ROW_COL_WIDTH-1:0];\n\n    always_comb begin\n       for(int i = 0; i < 256; i++) begin\n         if (i < 128) begin\n            r_prime[i] = (i - 2 * (i / 16)) % 16;\n            c_prime[i] = (i -     (i / 16)) % 16;\n         end\n         else begin\n            r_prime[i] = (i - 2 * (i / 16) - 1) % 16;\n            c_prime[i] = (i - (i / 16) - 1) % 16;\n         end\n       end\n    end\n    int j, k;\n    logic [7:0] output_index[256];\n    always_comb begin\n      for (j = 0; j < 256; j++) begin\n           output_index[j] = r_prime[j] * 16 + c_prime[j];\n           out_data[j]     = in_data[output_index[j]];\n        end\n    end\nendmodule"}, "output": {"rtl/inter_block.sv": "module inter_block #(\n    parameter ROW_COL_WIDTH = 16,\n    parameter SUB_BLOCKS    = 4,\n    parameter DATA_WIDTH    = ROW_COL_WIDTH*ROW_COL_WIDTH\n)(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic i_valid,\n    input  logic [DATA_WIDTH-1:0] in_data, // Input: 256 bits\n    output logic [DATA_WIDTH-1:0] out_data // Output: 256 bits rearranged\n);\n\nlocalparam CHUNK = 8;\nlocalparam NBW_COUNTER = $clog2(SUB_BLOCKS) + 1;\nlocalparam NBW_COUNTER_SUB_OUT = 2;\nlocalparam OUT_CYCLES = 32;\nlocalparam NBW_COUNTER_OUTPUT = $clog2(OUT_CYCLES);\nlogic [NBW_COUNTER_OUTPUT-1:0] counter_output;\nlogic [NBW_COUNTER-1:0] counter_sub_blocks;\nlogic [NBW_COUNTER_SUB_OUT-1:0] counter_sub_out;\n\nlogic [DATA_WIDTH-1:0] in_data_reg [SUB_BLOCKS-1:0];\nlogic [DATA_WIDTH-1:0] out_data_intra_block [SUB_BLOCKS-1:0];\nlogic [DATA_WIDTH-1:0] out_data_intra_block_reg [SUB_BLOCKS-1:0];\nlogic [DATA_WIDTH-1:0] out_data_aux [SUB_BLOCKS-1:0];\nlogic start_intra;\n\nalways_ff @(posedge clk or negedge rst_n ) begin\n   if(!rst_n) begin\n      counter_sub_blocks <= {NBW_COUNTER{1'b0}};\n      start_intra <= 0;\n      for(int i = 0; i < SUB_BLOCKS; i++) begin\n         in_data_reg[i] <= {DATA_WIDTH{1'b0}};\n      end\n   end\n   else begin\n      if(i_valid) begin\n         in_data_reg[counter_sub_blocks] <= in_data;\n\n         if(counter_sub_blocks == SUB_BLOCKS) begin\n            counter_sub_blocks <= {NBW_COUNTER{1'b0}};\n         end\n         else begin\n            start_intra <= 0;\n            counter_sub_blocks <= counter_sub_blocks + 1;\n         end\n      end\n      else if(counter_sub_blocks == SUB_BLOCKS) begin\n         start_intra        <= 1;\n         counter_sub_blocks <= {NBW_COUNTER{1'b0}};\n      end\n   end\nend\n\ngenvar k;\ngenerate \n   for(k = 0; k < SUB_BLOCKS; k++) begin\n      intra_block uu_intra_block (\n         .in_data(in_data_reg[k]),\n         .out_data(out_data_intra_block[k])\n      );\n   end\nendgenerate\n\nalways_ff @(posedge clk or negedge rst_n) begin\n   if(!rst_n) begin\n      for(int i = 0; i < SUB_BLOCKS; i++) begin\n         out_data_intra_block_reg[i] <= {DATA_WIDTH{1'b0}};\n      end\n   end\n   else begin\n      if(start_intra) begin\n         for(int i = 0; i < SUB_BLOCKS; i++) begin\n            out_data_intra_block_reg[i] <= out_data_intra_block[i];\n         end\n      end\n   end\nend\n\nalways_ff @(posedge clk or negedge rst_n) begin\n   if(!rst_n) begin\n      counter_sub_out <= {NBW_COUNTER_SUB_OUT{1'b1}};\n      out_data        <= {DATA_WIDTH{1'b0}};\n      for(int i = 0; i < SUB_BLOCKS; i++) begin\n         out_data_aux[i] <= {DATA_WIDTH{1'b0}};\n      end      \n   end\n   else begin\n      if(start_intra) begin\n         for(int i = 0; i < 32; i++) begin\n            out_data_aux[0][(i+1)*CHUNK-1-:CHUNK] = out_data_intra_block_reg[i%4][((i+1)*CHUNK)-1-:CHUNK];\n            out_data_aux[1][(i+1)*CHUNK-1-:CHUNK] = out_data_intra_block_reg[i%4][(((i+1)%OUT_CYCLES+1)*CHUNK)-1-:CHUNK];\n            out_data_aux[2][(i+1)*CHUNK-1-:CHUNK] = out_data_intra_block_reg[i%4][(((i+2)%OUT_CYCLES+1)*CHUNK)-1-:CHUNK];\n            out_data_aux[3][(i+1)*CHUNK-1-:CHUNK] = out_data_intra_block_reg[i%4][(((i+3)%OUT_CYCLES+1)*CHUNK)-1-:CHUNK];\n         end\n         counter_sub_out <= counter_sub_out + 1;\n         out_data        <= out_data_aux[counter_sub_out];\n      end\n   end\nend\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_scrambler_0024": {"input": {"rtl/intra_block.sv": "module intra_block #(\n    parameter ROW_COL_WIDTH = 16,\n    parameter DATA_WIDTH = ROW_COL_WIDTH*ROW_COL_WIDTH\n)(\n    input logic [DATA_WIDTH-1:0] in_data,  // Input: 256 bits\n    output logic [DATA_WIDTH-1:0] out_data // Output: 256 bits rearranged\n);\n\n    // Temporary storage for intermediate calculations\n    logic [3:0] r_prime [0:255]; // Row index for each bit\n    logic [3:0] c_prime [0:255]; // Column index for each bit\n\n    logic [ROW_COL_WIDTH-1:0] prev_out_data [ROW_COL_WIDTH-1:0];\n\n    always_comb begin\n       for(int i = 0; i < 256; i++) begin\n         if (i < 128) begin\n            r_prime[i] = (i - 2 * (i / 16)) % 16;\n            c_prime[i] = (i -     (i / 16)) % 16;\n         end\n         else begin\n            r_prime[i] = (i - 2 * (i / 16) - 1) % 16;\n            c_prime[i] = (i - (i / 16) - 1) % 16;\n         end\n       end\n    end\n    int j, k;\n    logic [7:0] output_index[256];\n    always_comb begin\n      for (j = 0; j < 256; j++) begin\n           output_index[j] = r_prime[j] * 16 + c_prime[j];\n           out_data[j]     = in_data[output_index[j]];\n        end\n    end\nendmodule"}, "output": {"rtl/intra_block.sv": ""}, "obj": true}}
{"cvdp_copilot_sdram_controller_0001": {"input": {}, "output": {"rtl/sdram_controller.sv": ""}, "obj": true}}
{"cvdp_copilot_secure_ALU_0001": {"input": {}, "output": {"rtl/alu_seq.v": ""}, "obj": true}}
{"cvdp_copilot_secure_read_write_bus_0001": {"input": {}, "output": {"rtl/secure_read_write_bus_interface.v": ""}, "obj": true}}
{"cvdp_copilot_secure_read_write_register_bank_0001": {"input": {}, "output": {"rtl/secure_read_write_register_bank.v": ""}, "obj": true}}
{"cvdp_copilot_secure_variable_timer_0001": {"input": {}, "output": {"rtl/secure_variable_timer.v": ""}, "obj": true}}
{"cvdp_copilot_sequencial_binary_to_one_hot_decoder_0001": {"input": {}, "output": {"rtl/binary_to_one_hot_decoder_sequential.v": ""}, "obj": true}}
{"cvdp_copilot_serial_in_parallel_out_0004": {"input": {"docs/Documentation.md": "# 8-bit Shift-Left Register with Positive-Edge Clock, Serial In, and Parallel Out #\n\nThis document describes the design and functionality of an 8-bit shift-left register implemented in Verilog. The module takes a serial input and provides a parallel output, shifting its contents left on each positive edge of the clock signal.\n\n## SIPO (Serial In, and Parallel Out) Specification ##\n\nInputs\n- **clock**: The clock signal that triggers the shift operation on its positive edge.\n- **serial_in**: The serial input bit to be shifted into the register.\n\nOutput\n- **parallel_out [7:0]**: An 8-bit parallel output representing the current state of the register.\n\n## Signals Table for 8-bit Shift-Left Register ##\n\n| **Signal Name** | **Direction** | **Width** | **Description**                         |\n|-----------------|---------------|-----------|-----------------------------------------|\n| clock           | Input         | 1 bit     | Clock signal that triggers the shift operation on its positive edge. |\n| serial_in       | Input         | 1 bit     | Serial input bit to be shifted into the register. |\n| parallel_out    | Output        | 8 bits    | 8-bit parallel output representing the current state of the register. |\n\n## SIPO (Serial In, and Parallel Out) Specification Description ##\n- **Clock Signal (`clock`)**: The register shifts its contents on the rising edge of this signal. The shift operation only occurs during the transition from low to high of the clock signal.\n- **Serial Input (`serial_in`)**: This single-bit input is shifted into the least significant bit (LSB) of the register on each clock pulse.\n- **Parallel Output (`parallel_out`)**: This is an 8-bit wide output that holds the current value of the register. It updates on each positive clock edge to reflect the shifted contents.\n\n## SIPO (Serial In, and Parallel Out) Functional Overview ##\n- On every positive edge of the clock signal, the register's contents are shifted one position to the left.\n- The bit in `serial_in` is placed in the least significant bit position (`parallel_out[0]`).\n- The most significant bit (`parallel_out[7]`) is discarded during the shift operation.\n- The new value of the register is available at the parallel output (`parallel_out`).\n\n"}, "output": {"rtl/serial_in_parallel_out_8bit.sv": ""}, "obj": true}}
{"cvdp_copilot_serial_in_parallel_out_0011": {"input": {"rtl/serial_in_parallel_out_8bit.sv": "module serial_in_parallel_out_8bit (input clock,serial_in,output reg [7:0] parallel_out);\n  \nalways @(posedge clock)  \n  begin\n    parallel_out[7:1] <=parallel_out[6:0];     \n    parallel_out[0] <= serial_in;  \n  end  \n  \nendmodule"}, "output": {"rtl/serial_in_parallel_out_8bit.sv": ""}, "obj": true}}
{"cvdp_copilot_serial_in_parallel_out_0014": {"input": {"rtl/serial_in_parallel_out_8bit.sv": "module sipo_top#(parameter DATA_WIDTH = 16,                                   // Width of the shift register\n                 parameter SHIFT_DIRECTION = 1,                               // Determines Left or right shift\n                 parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1)   // Encoded width\n                 ) (\n   \n   input clk,                                   // Clock input\n   input reset_n,                               // Reset input\n   input serial_in,                             // Serial input to SIPO\n   input shift_en,                              // Shift enable                     \n   input [CODE_WIDTH-1:0] received,             // Received encoded data \n   output done,                                 // Done signal indicating completion of shift\n   output [DATA_WIDTH-1:0] data_out,            // corrected output of ecc block\n   output [CODE_WIDTH-1:0] encoded,             // Encoded output\n   output error_detected,                       // Error detected flag\n   output error_corrected                       // Error corrected  flag\n   \n   );\n\nwire [DATA_WIDTH-1:0] parallel_out;\nwire [DATA_WIDTH-1:0] sipo_out_ecc_in;\n\nserial_in_parallel_out_8bit  #(.WIDTH(DATA_WIDTH), .SHIFT_DIRECTION(SHIFT_DIRECTION)) uut_sipo (\n        .clk           (clk),               // Clock input\n        .reset_n       (reset_n),           // Reset input\n        .sin           (serial_in),         // Serial input to SIPO\n        .shift_en      (shift_en),          // Shift enable for SIPO\n        .done          (done),              // Done signal from SIPO\n        .parallel_out  (parallel_out)       // Parallel output from SIPO\n    );\n \n//assign sipo_out_ecc_in = (done)? parallel_out: {DATA_WIDTH{1'b0}};\n\nonebit_ecc#(.DATA_WIDTH(DATA_WIDTH),.CODE_WIDTH(CODE_WIDTH)) uut_onebit_ecc1 (\n\n    .data_in(parallel_out),\n    .encoded(encoded),\n    .received(received),\n    .data_out(data_out),\n    .error_detected(error_detected),\n    .error_corrected(error_corrected)\n    );\n\nendmodule\n\nmodule serial_in_parallel_out_8bit  #(\n    parameter WIDTH = 64,               // Width of the shift register\n    parameter SHIFT_DIRECTION = 1       // Determines if shifting\n)(\n    input clk,                          // Clock signal\n    input reset_n,                      // Active low reset\n    input sin,                          // Serial input\n    input shift_en,                     // Shift enable signal\n    output reg done,                    // Done signal indicating completion of shift\n    output reg [WIDTH-1:0] parallel_out // Parallel output\n);\n    \n    localparam COUNT_WIDTH = $clog2(WIDTH); // Calculate width for shift_count\n    \n    reg [COUNT_WIDTH:0] shift_count;        // Parameterized counter to track number of shifts\n    \n   \n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin                                   \n            parallel_out     <= {WIDTH{1'b0}};                \n            done             <= 1'b0;                         \n            shift_count      <= {COUNT_WIDTH{1'b0}};          \n        end else begin\n            if (shift_en) begin\n                if (SHIFT_DIRECTION) begin\n                    parallel_out    <= {parallel_out[WIDTH-2:0], sin}; \n                end else begin\n                    parallel_out    <= {sin, parallel_out[WIDTH-1:1]}; \n                end\n                shift_count   <= shift_count + 1;                      \n            end\n            \n            if (shift_count == (WIDTH - 1)) begin\n                done         <= 1'b1;                                 \n                shift_count  <= {COUNT_WIDTH{1'b0}};                  \n            end else begin\n                done         <= 1'b0;                                  \n            end\n        end\n    end \nendmodule\n\n\nmodule onebit_ecc #(\n    parameter DATA_WIDTH = 4,                                  // Width of the data input\n    parameter CODE_WIDTH = DATA_WIDTH + $clog2(DATA_WIDTH + 1) // Encoded width\n)(\n    input [DATA_WIDTH-1:0] data_in,                     // Input data\n    output reg [CODE_WIDTH-1:0] encoded,                // Encoded output\n    input [CODE_WIDTH-1:0] received,                    // Received encoded data\n    output reg [DATA_WIDTH-1:0] data_out,               // Corrected output\n    output reg error_detected,                          // Error detected flag\n    output reg error_corrected                          // Error corrected flag\n);\n\n    localparam PARITY_BITS = CODE_WIDTH - DATA_WIDTH;   // Number of parity bits\n\n    reg [PARITY_BITS-1:0] syndrome;                     // Syndrome for error detection\n    reg [CODE_WIDTH-1:0] corrected_data;                // Corrected received data\n\n\n    integer idx_i, idx_j, idx_k;\n    integer idx_m, idx_n;\n    integer idx_p, idx_q;\n\n\n    always @(*) begin\n        encoded = 0;\n        idx_k = 0;\n\n\n        for (idx_i = 0; idx_i < CODE_WIDTH; idx_i = idx_i + 1) begin\n            if ((idx_i + 1) & (idx_i)) begin\n                encoded[idx_i] = data_in[idx_k];\n                idx_k = idx_k + 1;\n            end\n        end\n\n\n        for (idx_i = 0; idx_i < PARITY_BITS; idx_i = idx_i + 1) begin\n            encoded[(1 << idx_i) - 1] = 0; \n            for (idx_j = 0; idx_j < CODE_WIDTH; idx_j = idx_j + 1) begin\n                if (((idx_j + 1) & (1 << idx_i)) && ((idx_j + 1) != (1 << idx_i))) begin\n                    encoded[(1 << idx_i) - 1] = encoded[(1 << idx_i) - 1] ^ encoded[idx_j];\n                end\n            end\n        end\n    end\n\n\n    always @(*) begin\n        syndrome = 0; \n        for (idx_m = 0; idx_m < PARITY_BITS; idx_m = idx_m + 1) begin\n            for (idx_n = 0; idx_n < CODE_WIDTH; idx_n = idx_n + 1) begin\n                if ((idx_n + 1) & (1 << idx_m)) begin\n                    syndrome[idx_m] = syndrome[idx_m] ^ received[idx_n];\n                end\n            end\n        end\n    end\n\n  \n    always @(*) begin\n        error_detected = |syndrome; \n    end\n\n    \n    always @(*) begin\n        corrected_data = received;\n        if (error_detected) begin\n            corrected_data[syndrome - 1] = ~corrected_data[syndrome - 1]; \n        end\n    end\n\n \n    always @(*) begin\n        idx_q = 0;\n        for (idx_p = 0; idx_p < CODE_WIDTH; idx_p = idx_p + 1) begin\n            if ((idx_p + 1) & (idx_p)) begin\n                data_out[idx_q] = corrected_data[idx_p];\n                idx_q = idx_q + 1;\n            end\n        end\n    end\n\n\n    always @(*) begin\n        error_corrected = error_detected; \n    end\n\nendmodule"}, "output": {"rtl/serial_in_parallel_out_8bit.sv": ""}, "obj": true}}
{"cvdp_copilot_set_bit_calculator_0001": {"input": {}, "output": {"rtl/SetBitStreamCalculator.v": ""}, "obj": true}}
{"cvdp_copilot_sigma_delta_audio_0007": {"input": {"rtl/sigma_delta_audio.sv": "module sigma_delta_audio\n(\n  input   clk_sig,\n  input   clk_en_sig,\n  input  [14:0] load_data_sum,\n  input  [14:0] read_data_sum,\n  output  reg left_sig=0,\n  output  reg right_sig=0\n);\n\nlocalparam DATA_WIDTH = 15;\nlocalparam CLOCK_WIDTH = 2;\nlocalparam READ_WIDTH  = 4;\nlocalparam A1_WIDTH = 2;\nlocalparam A2_WIDTH = 5;\n\nwire [DATA_WIDTH+2+0  -1:0] l_er0, r_er0;\nreg  [DATA_WIDTH+2+0  -1:0] l_er0_prev=0, r_er0_prev=0;\nwire [DATA_WIDTH+A1_WIDTH+2-1:0] l_aca1,  r_aca1;\nwire [DATA_WIDTH+A2_WIDTH+2-1:0] l_aca2,  r_aca2;\nreg  [DATA_WIDTH+A1_WIDTH+2-1:0] l_ac1=0, r_ac1=0;\nreg  [DATA_WIDTH+A2_WIDTH+2-1:0] l_ac2=0, r_ac2=0;\nwire [DATA_WIDTH+A2_WIDTH+3-1:0] l_quant, r_quant;\n\nreg [24-1:0] seed_1 = 24'h654321;\nreg [19-1:0] seed_2 = 19'h12345;\nreg [24-1:0] s_sum=0, s_prev=0, s_out=0;\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    if (&seed_1)\n      seed_1 <= #1 24'h654321;\n    else\n      seed_1 <= #1 {seed_1[22:0], ~(seed_1[23] ^ seed_1[22] ^ seed_1[21] ^ seed_1[16])};\n  end\nend\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    if (&seed_2)\n      seed_2 <= #1 19'h12345;\n    else\n      seed_2 <= #1 {seed_2[17:0], ~(seed_2[18] ^ seed_2[17] ^ seed_2[16] ^ seed_2[13] ^ seed_2[0])};\n  end\nend\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    s_sum  <= #1 seed_1 + {5'b0, seed_2};\n    s_prev <= #1 s_sum;\n    s_out  <= #1 s_sum - s_prev;\n  end\nend\n\nlocalparam INPUT_DATA=4;\nreg  [INPUT_DATA+0-1:0] integer_count = 0;\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    integer_count <= #1 integer_count + 'd1;\n  end\nend\n\nreg  [DATA_WIDTH+0-1:0] ldata_current=0, ldata_previous=0;\nreg  [DATA_WIDTH+0-1:0] rdata_current=0, rdata_previous=0;\nwire [DATA_WIDTH+1-1:0] load_data_step, read_data_step;\nreg  [DATA_WIDTH+INPUT_DATA-1:0] load_data_int=0, read_data_int=0;\nwire [DATA_WIDTH+0-1:0] load_data_int_out, read_data_int_out;\nassign load_data_step = {ldata_current[DATA_WIDTH-1], ldata_current} - {ldata_previous[DATA_WIDTH-1], ldata_previous};\nassign read_data_step = {rdata_current[DATA_WIDTH-1], rdata_current} - {rdata_previous[DATA_WIDTH-1], rdata_previous};\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    if (~|integer_count) begin\n      ldata_previous <= #1 ldata_current;\n      ldata_current  <= #1 load_data_sum;\n      rdata_previous <= #1 rdata_current;\n      rdata_current  <= #1 read_data_sum;\n      load_data_int  <= #1 {ldata_current[DATA_WIDTH-1], ldata_current, {INPUT_DATA{1'b0}}};\n      read_data_int  <= #1 {rdata_current[DATA_WIDTH-1], rdata_current, {INPUT_DATA{1'b0}}};\n    end else begin\n      load_data_int  <= #1 load_data_int + {{INPUT_DATA{load_data_step[DATA_WIDTH+1-1]}}, load_data_step};\n      read_data_int  <= #1 read_data_int + {{INPUT_DATA{read_data_step[DATA_WIDTH+1-1]}}, read_data_step};\n    end\n  end\nend\nassign load_data_int_out = load_data_int[DATA_WIDTH+INPUT_DATA-1:INPUT_DATA];\nassign read_data_int_out = read_data_int[DATA_WIDTH+INPUT_DATA-1:INPUT_DATA];\n\nwire [DATA_WIDTH+2-1:0] load_data_gain, read_data_gain;\nassign load_data_gain = {load_data_int_out[DATA_WIDTH-1], load_data_int_out, 1'b0} + {{(2){load_data_int_out[DATA_WIDTH-1]}}, load_data_int_out};\nassign read_data_gain = {read_data_int_out[DATA_WIDTH-1], read_data_int_out, 1'b0} + {{(2){read_data_int_out[DATA_WIDTH-1]}}, read_data_int_out};\n\nassign l_aca1 = {{(A1_WIDTH){load_data_gain[DATA_WIDTH+2-1]}}, load_data_gain} - {{(A1_WIDTH){l_er0[DATA_WIDTH+2-1]}}, l_er0} + l_ac1;\nassign r_aca1 = {{(A1_WIDTH){read_data_gain[DATA_WIDTH+2-1]}}, read_data_gain} - {{(A1_WIDTH){r_er0[DATA_WIDTH+2-1]}}, r_er0} + r_ac1;\nassign l_aca2 = {{(A2_WIDTH-A1_WIDTH){l_aca1[DATA_WIDTH+A1_WIDTH+2-1]}}, l_aca1} - {{(A2_WIDTH){l_er0[DATA_WIDTH+2-1]}}, l_er0} - {{(A2_WIDTH+1){l_er0_prev[DATA_WIDTH+2-1]}}, l_er0_prev[DATA_WIDTH+2-1:1]} + l_ac2;\nassign r_aca2 = {{(A2_WIDTH-A1_WIDTH){r_aca1[DATA_WIDTH+A1_WIDTH+2-1]}}, r_aca1} - {{(A2_WIDTH){r_er0[DATA_WIDTH+2-1]}}, r_er0} - {{(A2_WIDTH+1){r_er0_prev[DATA_WIDTH+2-1]}}, r_er0_prev[DATA_WIDTH+2-1:1]} + r_ac2;\n\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    l_ac1 <= #1 l_aca1;\n    r_ac1 <= #1 r_aca1;\n    l_ac2 <= #1 l_aca2;\n    r_ac2 <= #1 r_aca2;\n  end\nend\n\nassign l_quant = {l_ac2[DATA_WIDTH+A2_WIDTH+2-1], l_ac2} + {{(DATA_WIDTH+A2_WIDTH+3-READ_WIDTH){s_out[READ_WIDTH-1]}}, s_out[READ_WIDTH-1:0]};\nassign r_quant = {r_ac2[DATA_WIDTH+A2_WIDTH+2-1], r_ac2} + {{(DATA_WIDTH+A2_WIDTH+3-READ_WIDTH){s_out[READ_WIDTH-1]}}, s_out[READ_WIDTH-1:0]};\n\nassign l_er0 = l_quant[DATA_WIDTH+A2_WIDTH+3-1] ? {1'b1, {(DATA_WIDTH+2-1){1'b0}}} : {1'b0, {(DATA_WIDTH+2-1){1'b1}}};\nassign r_er0 = r_quant[DATA_WIDTH+A2_WIDTH+3-1] ? {1'b1, {(DATA_WIDTH+2-1){1'b0}}} : {1'b0, {(DATA_WIDTH+2-1){1'b1}}};\n\nalways @ (posedge clk_sig)\nbegin\n  if (clk_en_sig)\n  begin\n    if (~|load_data_gain)\n    begin\n      left_sig <= #1 ~left_sig;\n    end\n    else\n    begin\n      left_sig <= #1 ~l_er0[DATA_WIDTH+2-1];\n    end\n\n    if (~|read_data_gain)\n    begin\n      right_sig <= #1 ~right_sig;\n    end\n    else\n    begin\n      right_sig <= #1 ~r_er0[DATA_WIDTH+2-1];\n    end\n  end\nend\nendmodule"}, "output": {"rtl/sigma_delta_audio.sv": "module sigma_delta_audio\n(\n  input   clk_sig,\n  input   clk_en_sig,\n  input  [14:0] load_data_sum,\n  input  [14:0] read_data_sum,\n  output  reg left_sig=0,\n  output  reg right_sig=0\n);\n\nlocalparam DATA_WIDTH = 15;\nlocalparam CLOCK_WIDTH = 2;\nlocalparam READ_WIDTH  = 4;\nlocalparam A1_WIDTH = 2;\nlocalparam A2_WIDTH = 5;\n\nwire [DATA_WIDTH+2+0  -1:0] l_er0, r_er0;\nreg  [DATA_WIDTH+2+0  -1:0] l_er0_prev=0, r_er0_prev=0;\nwire [DATA_WIDTH+A1_WIDTH+2-1:0] l_aca1,  r_aca1;\nwire [DATA_WIDTH+A2_WIDTH+2-1:0] l_aca2,  r_aca2;\nreg  [DATA_WIDTH+A1_WIDTH+2-1:0] l_ac1=0, r_ac1=0;\nreg  [DATA_WIDTH+A2_WIDTH+2-1:0] l_ac2=0, r_ac2=0;\nwire [DATA_WIDTH+A2_WIDTH+3-1:0] l_quant, r_quant;\n\nreg [24-1:0] seed_1 = 24'h654321;\nreg [19-1:0] seed_2 = 19'h12345;\nreg [24-1:0] s_sum=0, s_prev=0, s_out=0;\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    if (&seed_1)\n      seed_1 <= #1 24'h654321;\n    else\n      seed_1 <= #1 {seed_1[22:0], ~(seed_1[23] ^ seed_1[22] ^ seed_1[21] ^ seed_1[16])};\n  end\nend\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    if (&seed_2)\n      seed_2 <= #1 19'h12345;\n    else\n      seed_2 <= #1 {seed_2[17:0], ~(seed_2[18] ^ seed_2[17] ^ seed_2[16] ^ seed_2[13] ^ seed_2[0])};\n  end\nend\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    s_sum  <= #1 seed_1 + {5'b0, seed_2};\n    s_prev <= #1 s_sum;\n    s_out  <= #1 s_sum - s_prev;\n  end\nend\n\nlocalparam INPUT_DATA=4;\nreg  [INPUT_DATA+0-1:0] integer_count = 0;\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    integer_count <= #1 integer_count + 'd1;\n  end\nend\n\nreg  [DATA_WIDTH+0-1:0] ldata_current=0, ldata_previous=0;\nreg  [DATA_WIDTH+0-1:0] rdata_current=0, rdata_previous=0;\nwire [DATA_WIDTH+1-1:0] load_data_step, read_data_step;\nreg  [DATA_WIDTH+INPUT_DATA-1:0] load_data_int=0, read_data_int=0;\nwire [DATA_WIDTH+0-1:0] load_data_int_out, read_data_int_out;\nassign load_data_step = {ldata_current[DATA_WIDTH-1], ldata_current} - {ldata_previous[DATA_WIDTH-1], ldata_previous};\nassign read_data_step = {rdata_current[DATA_WIDTH-1], rdata_current} - {rdata_previous[DATA_WIDTH-1], rdata_previous};\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    if (~|integer_count) begin\n      ldata_previous <= #1 ldata_current;\n      ldata_current  <= #1 load_data_sum;\n      rdata_previous <= #1 rdata_current;\n      rdata_current  <= #1 read_data_sum;\n      load_data_int  <= #1 {ldata_current[DATA_WIDTH-1], ldata_current, {INPUT_DATA{1'b0}}};\n      read_data_int  <= #1 {rdata_current[DATA_WIDTH-1], rdata_current, {INPUT_DATA{1'b0}}};\n    end else begin\n      load_data_int  <= #1 load_data_int + {{INPUT_DATA{load_data_step[DATA_WIDTH+1-1]}}, load_data_step};\n      read_data_int  <= #1 read_data_int + {{INPUT_DATA{read_data_step[DATA_WIDTH+1-1]}}, read_data_step};\n    end\n  end\nend\nassign load_data_int_out = load_data_int[DATA_WIDTH+INPUT_DATA-1:INPUT_DATA];\nassign read_data_int_out = read_data_int[DATA_WIDTH+INPUT_DATA-1:INPUT_DATA];\n\nwire [DATA_WIDTH+2-1:0] load_data_gain, read_data_gain;\nassign load_data_gain = {load_data_int_out[DATA_WIDTH-1], load_data_int_out, 1'b0} + {{(2){load_data_int_out[DATA_WIDTH-1]}}, load_data_int_out};\nassign read_data_gain = {read_data_int_out[DATA_WIDTH-1], read_data_int_out, 1'b0} + {{(2){read_data_int_out[DATA_WIDTH-1]}}, read_data_int_out};\n\nassign l_aca1 = {{(A1_WIDTH){load_data_gain[DATA_WIDTH+2-1]}}, load_data_gain} - {{(A1_WIDTH){l_er0[DATA_WIDTH+2-1]}}, l_er0} + l_ac1;\nassign r_aca1 = {{(A1_WIDTH){read_data_gain[DATA_WIDTH+2-1]}}, read_data_gain} - {{(A1_WIDTH){r_er0[DATA_WIDTH+2-1]}}, r_er0} + r_ac1;\nassign l_aca2 = {{(A2_WIDTH-A1_WIDTH){l_aca1[DATA_WIDTH+A1_WIDTH+2-1]}}, l_aca1} - {{(A2_WIDTH){l_er0[DATA_WIDTH+2-1]}}, l_er0} - {{(A2_WIDTH+1){l_er0_prev[DATA_WIDTH+2-1]}}, l_er0_prev[DATA_WIDTH+2-1:1]} + l_ac2;\nassign r_aca2 = {{(A2_WIDTH-A1_WIDTH){r_aca1[DATA_WIDTH+A1_WIDTH+2-1]}}, r_aca1} - {{(A2_WIDTH){r_er0[DATA_WIDTH+2-1]}}, r_er0} - {{(A2_WIDTH+1){r_er0_prev[DATA_WIDTH+2-1]}}, r_er0_prev[DATA_WIDTH+2-1:1]} + r_ac2;\n\nalways @ (posedge clk_sig) begin\n  if (clk_en_sig) begin\n    l_ac1 <= #1 l_aca1;\n    r_ac1 <= #1 r_aca1;\n    l_ac2 <= #1 l_aca2;\n    r_ac2 <= #1 r_aca2;\n  end\nend\n\nassign l_quant = {l_ac2[DATA_WIDTH+A2_WIDTH+2-1], l_ac2} + {{(DATA_WIDTH+A2_WIDTH+3-READ_WIDTH){s_out[READ_WIDTH-1]}}, s_out[READ_WIDTH-1:0]};\nassign r_quant = {r_ac2[DATA_WIDTH+A2_WIDTH+2-1], r_ac2} + {{(DATA_WIDTH+A2_WIDTH+3-READ_WIDTH){s_out[READ_WIDTH-1]}}, s_out[READ_WIDTH-1:0]};\n\nassign l_er0 = l_quant[DATA_WIDTH+A2_WIDTH+3-1] ? {1'b1, {(DATA_WIDTH+2-1){1'b0}}} : {1'b0, {(DATA_WIDTH+2-1){1'b1}}};\nassign r_er0 = r_quant[DATA_WIDTH+A2_WIDTH+3-1] ? {1'b1, {(DATA_WIDTH+2-1){1'b0}}} : {1'b0, {(DATA_WIDTH+2-1){1'b1}}};\n\nalways @ (posedge clk_sig)\nbegin\n  if (clk_en_sig)\n  begin\n    if (~|load_data_gain)\n    begin\n      left_sig <= #1 ~left_sig;\n    end\n    else\n    begin\n      left_sig <= #1 ~l_er0[DATA_WIDTH+2-1];\n    end\n\n    if (~|read_data_gain)\n    begin\n      right_sig <= #1 ~right_sig;\n    end\n    else\n    begin\n      right_sig <= #1 ~r_er0[DATA_WIDTH+2-1];\n    end\n  end\nend\nendmodule"}, "obj": true}}
{"cvdp_copilot_signal_correlator_0015": {"input": {"rtl/signal_correlator.sv": "module signal_correlator(\n    input clk,\n    input reset,\n    input [7:0] input_signal,\n    input [7:0] reference_signal,\n    output reg [3:0] correlation_output // 4-bit output\n);\n\ninteger i;\nreg [3:0] sum;  \n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        correlation_output <= 0;\n        sum = 0;  \n    end else begin\n        sum = 0;  \n        for (i = 0; i < 8; i = i + 1) begin\n            sum = sum + (input_signal[i] & reference_signal[i]); \n        end\n    end\nend\n\nendmodule"}, "output": {"rtl/signal_correlator.sv": ""}, "obj": true}}
{"cvdp_copilot_signed_adder_0001": {"input": {}, "output": {"rtl/signedadder.v": ""}, "obj": true}}
{"cvdp_copilot_simple_spi_0001": {"input": {}, "output": {"rtl/spi_fsm.v": ""}, "obj": true}}
{"cvdp_copilot_single_number_0001": {"input": {}, "output": {"rtl/unique_number_identifier.v": ""}, "obj": true}}
{"cvdp_copilot_skid_buffer_0001": {"input": {}, "output": {"rtl/pipelined_skid_buffer.sv": ""}, "obj": true}}
{"cvdp_copilot_sobel_filter_0011": {"input": {"rtl/sobel_filter.sv": "module sobel_filter (\n    input            clk,\n    input            rst_n,\n    input      [7:0] pixel_in,\n    input            valid_in,\n    output reg [7:0] edge_out,\n    output reg       valid_out\n);\n    // Internal signals for gradients\n    reg signed [10:0] Gx, Gy;  // To accommodate larger values after convolution\n    reg [7:0] pixel_buffer[0:8]; // 3x3 pixel window\n    integer i;\n\n    // Parameters for thresholding\n    parameter THRESHOLD = 11'd128;\n\n    // Sliding window logic\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            for (i = 0; i < 9; i = i + 1) begin\n                pixel_buffer[i] <= 8'd0;\n            end    \n        end else if (valid_in) begin\n            pixel_buffer[8] <= pixel_buffer[7];\n            pixel_buffer[7] <= pixel_buffer[6];\n            pixel_buffer[6] <= pixel_buffer[5];\n            pixel_buffer[5] <= pixel_buffer[4];\n            pixel_buffer[4] <= pixel_buffer[3];\n            pixel_buffer[3] <= pixel_buffer[2];\n            pixel_buffer[2] <= pixel_buffer[1];\n            pixel_buffer[1] <= pixel_buffer[0];\n            pixel_buffer[0] <= pixel_in;\n        end\n    end\n\n    // Sobel convolution and edge detection\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Gx        <= 11'sd0;\n            Gy        <= 11'sd0;\n            edge_out  <= 8'd0;\n            valid_out <= 1'b0;\n        end else if (valid_in) begin\n            // Compute Gx and Gy using Sobel kernels\n            Gx <= -pixel_buffer[6] - (pixel_buffer[3] << 1) - pixel_buffer[0]\n                  +pixel_buffer[8] + (pixel_buffer[5] << 1) + pixel_buffer[2];\n            Gy <= -pixel_buffer[6] - (pixel_buffer[7] << 1) - pixel_buffer[8]\n                  +pixel_buffer[0] + (pixel_buffer[1] << 1) + pixel_buffer[2];\n\n            // Compute gradient magnitude (simplified as |Gx| + |Gy|)\n            edge_out <= ((Gx < 0 ? -Gx : Gx) + (Gy < 0 ? -Gy : Gy)) > THRESHOLD ? 8'd255 : 8'd0;\n\n            // Set valid output\n            valid_out <= 1'b1;\n        end else begin\n            valid_out <= 1'b0;\n        end\n    end\nendmodule"}, "output": {"rtl/sobel_filter.sv": ""}, "obj": true}}
{"cvdp_copilot_sorter_0001": {"input": {}, "output": {"rtl/sorting_engine.sv": ""}, "obj": true}}
{"cvdp_copilot_sorter_0003": {"input": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal registers to hold the array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0]  state, next_state;\n\n    // Variables for bubble sort indexing\n    reg [$clog2(N)-1:0] i;  // Outer loop index\n    reg [$clog2(N)-1:0] j;  // Inner loop index\n\n    // Wires for comparison and swap\n    wire [WIDTH-1:0] val_j;\n    wire [WIDTH-1:0] val_j1;\n\n    assign val_j  = array[j];\n    assign val_j1 = array[j+1];\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Transition to DONE once all passes are complete\n                if (i == (N-1) && j == (N-2))\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM: Output and counter updates\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            i <= 0;\n            j <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load the array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 0;\n                        j <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform a single comparison and swap if needed\n                    if (val_j > val_j1) begin\n                        array[j]   <= val_j1;\n                        array[j+1] <= val_j;\n                    end\n\n                    // Update j\n                    if (j == N-2) begin\n                        // One pass completed, increment i\n                        j <= 0;\n                        i <= i + 1;\n                    end else begin\n                        j <= j + 1;\n                    end\n                end\n\n                DONE: begin\n                    // Sorting complete\n                    done <= 1;\n                    // Output the sorted data\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule"}, "output": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal registers to hold the array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0]  state, next_state;\n\n    // Variables for bubble sort indexing\n    reg [$clog2(N)-1:0] i;  // Outer loop index\n    reg [$clog2(N)-1:0] j;  // Inner loop index\n\n    // Wires for comparison and swap\n    wire [WIDTH-1:0] val_j;\n    wire [WIDTH-1:0] val_j1;\n\n    assign val_j  = array[j];\n    assign val_j1 = array[j+1];\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Transition to DONE once all passes are complete\n                if (i == (N-1) && j == (N-2))\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM: Output and counter updates\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            i <= 0;\n            j <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load the array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 0;\n                        j <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform a single comparison and swap if needed\n                    if (val_j > val_j1) begin\n                        array[j]   <= val_j1;\n                        array[j+1] <= val_j;\n                    end\n\n                    // Update j\n                    if (j == N-2) begin\n                        // One pass completed, increment i\n                        j <= 0;\n                        i <= i + 1;\n                    end else begin\n                        j <= j + 1;\n                    end\n                end\n\n                DONE: begin\n                    // Sorting complete\n                    done <= 1;\n                    // Output the sorted data\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_sorter_0009": {"input": {}, "output": {"rtl/sorting_engine.sv": ""}, "obj": true}}
{"cvdp_copilot_sorter_0031": {"input": {}, "output": {"rtl/sorting_engine.sv": ""}, "obj": true}}
{"cvdp_copilot_sorter_0051": {"input": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal registers to hold the array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0]  state, next_state;\n\n    // Variables for bubble sort indexing\n    int i;  // Outer loop index\n    int j;  // Inner loop index\n\n    // Wires for comparison and swap\n    wire [WIDTH-1:0] val_j;\n    wire [WIDTH-1:0] val_j1;\n\n    assign val_j  = array[j];\n    assign val_j1 = array[j+1];\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Transition to DONE once all passes are complete\n                if (i == (N-1) && j == (N-2))\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM: Output and counter updates\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            i <= 0;\n            j <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load the array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 0;\n                        j <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform a single comparison and swap if needed\n                    if (val_j > val_j1) begin\n                        array[j]   <= val_j1;\n                        array[j+1] <= val_j;\n                    end\n\n                    // Update j\n                    if (j == N-2) begin\n                        // One pass completed, increment i\n                        j <= 0;\n                        i <= i + 1;\n                    end else begin\n                        j <= j + 1;\n                    end\n                end\n\n                DONE: begin\n                    // Sorting complete\n                    done <= 1;\n                    // Output the sorted data\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule"}, "output": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal registers to hold the array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0]  state, next_state;\n\n    // Variables for bubble sort indexing\n    int i;  // Outer loop index\n    int j;  // Inner loop index\n\n    // Wires for comparison and swap\n    wire [WIDTH-1:0] val_j;\n    wire [WIDTH-1:0] val_j1;\n\n    assign val_j  = array[j];\n    assign val_j1 = array[j+1];\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Transition to DONE once all passes are complete\n                if (i == (N-1) && j == (N-2))\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM: Output and counter updates\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            i <= 0;\n            j <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load the array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 0;\n                        j <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform a single comparison and swap if needed\n                    if (val_j > val_j1) begin\n                        array[j]   <= val_j1;\n                        array[j+1] <= val_j;\n                    end\n\n                    // Update j\n                    if (j == N-2) begin\n                        // One pass completed, increment i\n                        j <= 0;\n                        i <= i + 1;\n                    end else begin\n                        j <= j + 1;\n                    end\n                end\n\n                DONE: begin\n                    // Sorting complete\n                    done <= 1;\n                    // Output the sorted data\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n                default: begin\n                end\n            endcase\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_sorter_0057": {"input": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    //-------------------------------------------------\n    // Local Parameters & Functions\n    //-------------------------------------------------\n    localparam IDLE  = 0;\n    localparam LOAD  = 1;\n    localparam SORT  = 2;\n    localparam MERGE = 3;\n    localparam DONE  = 4;\n\n    // Function to compute floor(log2(value)) at compile time\n    function integer clog2;\n        input integer value;\n        integer i;\n        begin\n            clog2 = 0;\n            for (i = 1; i < value; i = i << 1) begin\n                clog2 = clog2 + 1;\n            end\n        end\n    endfunction\n\n    // We choose ADDR_WIDTH big enough so we can store up to ~4*N in subarray_size\n    // For N=8, 4*N=32 => log2(32)=5 => plus 1 => 6 bits => can store up to 63 safely.\n    localparam ADDR_WIDTH = clog2(4 * N) + 1;\n\n    //-------------------------------------------------\n    // Internal Signals\n    //-------------------------------------------------\n    reg [2:0]                 state; // Enough for 5 states: IDLE..DONE\n\n    // Internal memory of N elements\n    reg [WIDTH-1:0]           data_mem [0:N-1];\n\n    // Indices and counters with widened bit-width\n    reg [ADDR_WIDTH-1:0]      base_idx;\n    reg [ADDR_WIDTH-1:0]      left_idx;\n    reg [ADDR_WIDTH-1:0]      right_idx;\n    reg [ADDR_WIDTH-1:0]      merge_idx;\n    reg [ADDR_WIDTH-1:0]      subarray_size;\n\n    // Temporary buffer for merged sub-array\n    reg [WIDTH-1:0]           tmp_merge [0:N-1];\n\n    // Temporary registers for current left/right values\n    reg [WIDTH-1:0]           left_val;\n    reg [WIDTH-1:0]           right_val;\n\n    integer i, k;\n    integer left_end, right_end;\n    integer l_addr,    r_addr;\n\n    //-------------------------------------------------\n    // State Machine\n    //-------------------------------------------------\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset\n            state         <= IDLE;\n            done          <= 1'b0;\n            out_data      <= {N*WIDTH{1'b0}};\n            base_idx      <= 0;\n            left_idx      <= 0;\n            right_idx     <= 0;\n            merge_idx     <= 0;\n            subarray_size <= 1;\n        end else begin\n            case (state)\n\n                //----------------------------------\n                // IDLE: Wait for start signal\n                //----------------------------------\n                IDLE: begin\n                    done <= 1'b0;\n                    if (start) begin\n                        state <= LOAD;\n                    end\n                end\n\n                //----------------------------------\n                // LOAD: Copy from in_data to data_mem\n                //----------------------------------\n                LOAD: begin\n                    for (i = 0; i < N; i = i + 1) begin\n                        data_mem[i] <= in_data[i*WIDTH +: WIDTH];\n                    end\n\n                    // Initialize for sorting\n                    base_idx      <= 0;\n                    left_idx      <= 0;\n                    right_idx     <= 0;\n                    merge_idx     <= 0;\n                    subarray_size <= 1;\n\n                    state <= SORT;\n                end\n\n                //----------------------------------\n                // SORT: Each pass merges sub-arrays of size subarray_size\n                //----------------------------------\n                SORT: begin\n                    // If subarray_size is strictly greater than N, we've fully sorted\n                    // (ensures we do a merge pass at subarray_size == N)\n                    if (subarray_size >= N) begin\n                        state <= DONE;\n                    end else begin\n                        // Prepare to merge pairs of sub-arrays\n                        base_idx  <= 0;\n                        merge_idx <= 0;\n                        left_idx  <= 0;\n                        right_idx <= 0;\n                        state     <= MERGE;\n                    end\n                end\n\n                //----------------------------------\n                // MERGE: Merge one pair of sub-arrays\n                //----------------------------------\n                MERGE: begin\n                    // Compare/pick smaller\n                    if ((l_addr <= left_end) && (r_addr <= right_end)) begin\n                        if (left_val <= right_val) begin\n                            tmp_merge[merge_idx] <= left_val;\n                            left_idx <= left_idx + 1;\n                        end else begin\n                            tmp_merge[merge_idx] <= right_val;\n                            right_idx <= right_idx + 1;\n                        end\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else if (l_addr <= left_end) begin\n                        // Only left sub-array has data\n                        tmp_merge[merge_idx] <= left_val;\n                        left_idx <= left_idx + 1;\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else if (r_addr <= right_end) begin\n                        // Only right sub-array has data\n                        tmp_merge[merge_idx] <= right_val;\n                        right_idx <= right_idx + 1;\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else begin\n                        // Both sub-arrays are exhausted => write back merged results\n                        for (k = 0; k < N; k = k + 1) begin\n                            if ( (k < merge_idx) && (k < (subarray_size << 1)) && ((base_idx + k) < N) )\n                            begin\n                                data_mem[base_idx + k] <= tmp_merge[k];\n                            end\n                        end\n\n                        // Move base_idx to next pair of sub-arrays\n                        base_idx  <= base_idx + (subarray_size << 1);\n                        left_idx  <= 0;\n                        right_idx <= 0;\n                        merge_idx <= 0;\n\n                        // If we merged all pairs in this pass, double subarray_size\n                        if ((base_idx + (subarray_size << 1)) >= N) begin\n                            subarray_size <= subarray_size << 1;\n                            state         <= SORT;\n                        end\n                    end\n                end\n\n                //----------------------------------\n                // DONE: Output the fully sorted array\n                //----------------------------------\n                DONE: begin\n                    for (i = 0; i < N; i = i + 1) begin\n                        out_data[i*WIDTH +: WIDTH] <= data_mem[i];\n                    end\n                    done  <= 1'b1;\n                    state <= IDLE;  // or remain in DONE, your preference\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nalways @ (*) begin\n    if(state == MERGE) begin\n        left_end  = base_idx + subarray_size - 1;\n        right_end = base_idx + (subarray_size << 1) - 1;\n\n        // Boundaries of left and right sub-arrays\n        if (left_end >= N) left_end = N - 1;\n        if (right_end >= N) right_end = N - 1;\n\n        // Calculate addresses\n        l_addr = base_idx + left_idx;\n        r_addr = base_idx + subarray_size + right_idx;\n\n        // Safe read for left_val\n        if ((l_addr <= left_end) && (l_addr < N))\n            left_val = data_mem[l_addr];\n        else\n            left_val = {WIDTH{1'b1}};  // or '0' if you prefer\n\n        // Safe read for right_val\n        if ((r_addr <= right_end) && (r_addr < N))\n            right_val = data_mem[r_addr];\n        else\n            right_val = {WIDTH{1'b1}};\n    end else begin\n        left_end = 0;\n        right_end = 0;\n        l_addr = 0;\n        r_addr = 0;\n        left_val = 0;\n        right_val = 0;\n    end\nend\n\nendmodule"}, "output": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    //-------------------------------------------------\n    // Local Parameters & Functions\n    //-------------------------------------------------\n    localparam IDLE  = 0;\n    localparam LOAD  = 1;\n    localparam SORT  = 2;\n    localparam MERGE = 3;\n    localparam DONE  = 4;\n\n    // Function to compute floor(log2(value)) at compile time\n    function integer clog2;\n        input integer value;\n        integer i;\n        begin\n            clog2 = 0;\n            for (i = 1; i < value; i = i << 1) begin\n                clog2 = clog2 + 1;\n            end\n        end\n    endfunction\n\n    // We choose ADDR_WIDTH big enough so we can store up to ~4*N in subarray_size\n    // For N=8, 4*N=32 => log2(32)=5 => plus 1 => 6 bits => can store up to 63 safely.\n    localparam ADDR_WIDTH = clog2(4 * N) + 1;\n\n    //-------------------------------------------------\n    // Internal Signals\n    //-------------------------------------------------\n    reg [2:0]                 state; // Enough for 5 states: IDLE..DONE\n\n    // Internal memory of N elements\n    reg [WIDTH-1:0]           data_mem [0:N-1];\n\n    // Indices and counters with widened bit-width\n    reg [ADDR_WIDTH-1:0]      base_idx;\n    reg [ADDR_WIDTH-1:0]      left_idx;\n    reg [ADDR_WIDTH-1:0]      right_idx;\n    reg [ADDR_WIDTH-1:0]      merge_idx;\n    reg [ADDR_WIDTH-1:0]      subarray_size;\n\n    // Temporary buffer for merged sub-array\n    reg [WIDTH-1:0]           tmp_merge [0:N-1];\n\n    // Temporary registers for current left/right values\n    reg [WIDTH-1:0]           left_val;\n    reg [WIDTH-1:0]           right_val;\n\n    integer i, k;\n    integer left_end, right_end;\n    integer l_addr,    r_addr;\n\n    //-------------------------------------------------\n    // State Machine\n    //-------------------------------------------------\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset\n            state         <= IDLE;\n            done          <= 1'b0;\n            out_data      <= {N*WIDTH{1'b0}};\n            base_idx      <= 0;\n            left_idx      <= 0;\n            right_idx     <= 0;\n            merge_idx     <= 0;\n            subarray_size <= 1;\n        end else begin\n            case (state)\n\n                //----------------------------------\n                // IDLE: Wait for start signal\n                //----------------------------------\n                IDLE: begin\n                    done <= 1'b0;\n                    if (start) begin\n                        state <= LOAD;\n                    end\n                end\n\n                //----------------------------------\n                // LOAD: Copy from in_data to data_mem\n                //----------------------------------\n                LOAD: begin\n                    for (i = 0; i < N; i = i + 1) begin\n                        data_mem[i] <= in_data[i*WIDTH +: WIDTH];\n                    end\n\n                    // Initialize for sorting\n                    base_idx      <= 0;\n                    left_idx      <= 0;\n                    right_idx     <= 0;\n                    merge_idx     <= 0;\n                    subarray_size <= 1;\n\n                    state <= SORT;\n                end\n\n                //----------------------------------\n                // SORT: Each pass merges sub-arrays of size subarray_size\n                //----------------------------------\n                SORT: begin\n                    // If subarray_size is strictly greater than N, we've fully sorted\n                    // (ensures we do a merge pass at subarray_size == N)\n                    if (subarray_size >= N) begin\n                        state <= DONE;\n                    end else begin\n                        // Prepare to merge pairs of sub-arrays\n                        base_idx  <= 0;\n                        merge_idx <= 0;\n                        left_idx  <= 0;\n                        right_idx <= 0;\n                        state     <= MERGE;\n                    end\n                end\n\n                //----------------------------------\n                // MERGE: Merge one pair of sub-arrays\n                //----------------------------------\n                MERGE: begin\n                    // Compare/pick smaller\n                    if ((l_addr <= left_end) && (r_addr <= right_end)) begin\n                        if (left_val <= right_val) begin\n                            tmp_merge[merge_idx] <= left_val;\n                            left_idx <= left_idx + 1;\n                        end else begin\n                            tmp_merge[merge_idx] <= right_val;\n                            right_idx <= right_idx + 1;\n                        end\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else if (l_addr <= left_end) begin\n                        // Only left sub-array has data\n                        tmp_merge[merge_idx] <= left_val;\n                        left_idx <= left_idx + 1;\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else if (r_addr <= right_end) begin\n                        // Only right sub-array has data\n                        tmp_merge[merge_idx] <= right_val;\n                        right_idx <= right_idx + 1;\n                        merge_idx <= merge_idx + 1;\n                    end\n                    else begin\n                        // Both sub-arrays are exhausted => write back merged results\n                        for (k = 0; k < N; k = k + 1) begin\n                            if ( (k < merge_idx) && (k < (subarray_size << 1)) && ((base_idx + k) < N) )\n                            begin\n                                data_mem[base_idx + k] <= tmp_merge[k];\n                            end\n                        end\n\n                        // Move base_idx to next pair of sub-arrays\n                        base_idx  <= base_idx + (subarray_size << 1);\n                        left_idx  <= 0;\n                        right_idx <= 0;\n                        merge_idx <= 0;\n\n                        // If we merged all pairs in this pass, double subarray_size\n                        if ((base_idx + (subarray_size << 1)) >= N) begin\n                            subarray_size <= subarray_size << 1;\n                            state         <= SORT;\n                        end\n                    end\n                end\n\n                //----------------------------------\n                // DONE: Output the fully sorted array\n                //----------------------------------\n                DONE: begin\n                    for (i = 0; i < N; i = i + 1) begin\n                        out_data[i*WIDTH +: WIDTH] <= data_mem[i];\n                    end\n                    done  <= 1'b1;\n                    state <= IDLE;  // or remain in DONE, your preference\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nalways @ (*) begin\n    if(state == MERGE) begin\n        left_end  = base_idx + subarray_size - 1;\n        right_end = base_idx + (subarray_size << 1) - 1;\n\n        // Boundaries of left and right sub-arrays\n        if (left_end >= N) left_end = N - 1;\n        if (right_end >= N) right_end = N - 1;\n\n        // Calculate addresses\n        l_addr = base_idx + left_idx;\n        r_addr = base_idx + subarray_size + right_idx;\n\n        // Safe read for left_val\n        if ((l_addr <= left_end) && (l_addr < N))\n            left_val = data_mem[l_addr];\n        else\n            left_val = {WIDTH{1'b1}};  // or '0' if you prefer\n\n        // Safe read for right_val\n        if ((r_addr <= right_end) && (r_addr < N))\n            right_val = data_mem[r_addr];\n        else\n            right_val = {WIDTH{1'b1}};\n    end else begin\n        left_end = 0;\n        right_end = 0;\n        l_addr = 0;\n        r_addr = 0;\n        left_val = 0;\n        right_val = 0;\n    end\nend\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_sorter_0059": {"input": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0] state, next_state;\n\n    // Insertion sort variables\n    integer i;\n    integer j;\n    reg [WIDTH-1:0] key;\n\n    // Insertion sort phases for each i\n    // 0: Initialize key and j\n    // 1: Shift elements greater than key\n    // 2: Insert key\n    reg [1:0] insert_phase;\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Once i reaches N, sorting is done\n                if (i == N)\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM: main logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state         <= IDLE;\n            done          <= 0;\n            i             <= 0;\n            j             <= 0;\n            key           <= 0;\n            insert_phase  <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 1; // Start insertion sort from index 1\n                        j <= 0;\n                        key <= 0;\n                        insert_phase <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform insertion sort step-by-step\n                    case (insert_phase)\n                        0: begin\n                            // Phase 0: Setup for inserting array[i]\n                            if (i < N) begin\n                                key <= array[i];\n                                j <= i - 1;\n                                insert_phase <= 1;\n                            end\n                            // If i == N, sorting complete, next cycle moves to DONE\n                        end\n\n                        1: begin\n                            // Phase 1: Shift elements to the right until the correct spot is found\n                            if (j >= 0 && array[j] > key) begin\n                                array[j+1] <= array[j];\n                                j <= j - 1;\n                            end else begin\n                                // We found the spot (or j < 0)\n                                insert_phase <= 2;\n                            end\n                        end\n\n                        2: begin\n                            // Phase 2: Insert the key at array[j+1]\n                            array[j+1] <= key;\n                            i <= i + 1;\n                            insert_phase <= 0; \n                        end\n\n                        default: insert_phase <= 0;\n                    endcase\n                end\n\n                DONE: begin\n                    // Sorting complete, output the result\n                    done <= 1;\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n\n                default: begin\n                    // Should not get here\n                end\n            endcase\n        end\n    end\n\nendmodule"}, "output": {"rtl/sorting_engine.sv": "module sorting_engine #(\n    parameter N = 8,             // Number of elements to sort\n    parameter WIDTH = 8          // Bit-width of each element\n)(\n    input  wire                clk,\n    input  wire                rst,\n    input  wire                start,\n    input  wire [N*WIDTH-1:0]  in_data,\n    output reg                 done,\n    output reg [N*WIDTH-1:0]   out_data\n);\n\n    // Internal array\n    reg [WIDTH-1:0] array [0:N-1];\n\n    // FSM states\n    localparam IDLE    = 2'd0;\n    localparam SORTING = 2'd1;\n    localparam DONE    = 2'd2;\n\n    reg [1:0] state, next_state;\n\n    // Insertion sort variables\n    integer i;\n    integer j;\n    reg [WIDTH-1:0] key;\n\n    // Insertion sort phases for each i\n    // 0: Initialize key and j\n    // 1: Shift elements greater than key\n    // 2: Insert key\n    reg [1:0] insert_phase;\n\n    // FSM: Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start)\n                    next_state = SORTING;\n            end\n            SORTING: begin\n                // Once i reaches N, sorting is done\n                if (i == N)\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM: main logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state         <= IDLE;\n            done          <= 0;\n            i             <= 0;\n            j             <= 0;\n            key           <= 0;\n            insert_phase  <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (start) begin\n                        // Load array from in_data\n                        for (int k = 0; k < N; k = k + 1) begin\n                            array[k] <= in_data[(k+1)*WIDTH-1 -: WIDTH];\n                        end\n                        i <= 1; // Start insertion sort from index 1\n                        j <= 0;\n                        key <= 0;\n                        insert_phase <= 0;\n                    end\n                end\n\n                SORTING: begin\n                    // Perform insertion sort step-by-step\n                    case (insert_phase)\n                        0: begin\n                            // Phase 0: Setup for inserting array[i]\n                            if (i < N) begin\n                                key <= array[i];\n                                j <= i - 1;\n                                insert_phase <= 1;\n                            end\n                            // If i == N, sorting complete, next cycle moves to DONE\n                        end\n\n                        1: begin\n                            // Phase 1: Shift elements to the right until the correct spot is found\n                            if (j >= 0 && array[j] > key) begin\n                                array[j+1] <= array[j];\n                                j <= j - 1;\n                            end else begin\n                                // We found the spot (or j < 0)\n                                insert_phase <= 2;\n                            end\n                        end\n\n                        2: begin\n                            // Phase 2: Insert the key at array[j+1]\n                            array[j+1] <= key;\n                            i <= i + 1;\n                            insert_phase <= 0; \n                        end\n\n                        default: insert_phase <= 0;\n                    endcase\n                end\n\n                DONE: begin\n                    // Sorting complete, output the result\n                    done <= 1;\n                    for (int m = 0; m < N; m = m + 1) begin\n                        out_data[(m+1)*WIDTH-1 -: WIDTH] <= array[m];\n                    end\n                end\n\n                default: begin\n                    // Should not get here\n                end\n            endcase\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_sound_generator_0001": {"input": {}, "output": {"rtl/soundgenerator.sv": ""}, "obj": true}}
{"cvdp_copilot_sprite_0004": {"input": {}, "output": {"rtl/sprite_fsm.sv": ""}, "obj": true}}
{"cvdp_copilot_sprite_0010": {"input": {"rtl/Bitstream.sv": "module Bitstream(input  logic clk,rst_n,\n                 input  logic enb,\n                 input  logic rempty_in,\n                 input  logic rinc_in,\n                 input  logic [7:0] i_byte,\n                 output logic o_bit,\n                 output logic rempty_out,\n                 output logic rinc_out);\n    \n    parameter IDLE  = 3'b000;\n    parameter WaitR = 3'b001;\n    parameter Ready = 3'b010;\n    logic [1:0] curr_state,next_state;\n\n    logic [0:7] byte_buf;\n    logic [3:0] bp;\n    logic rde;\n\n    //FSM block\n\n    always_ff @(posedge clk) begin\n        if(!rst_n) curr_state <= IDLE;\n        else curr_state <= next_state;\n    end\n\n    always_comb begin\n        case(curr_state)\n            IDLE: next_state = Ready;\n            IDLE:begin\n                if(enb)begin\n                    next_state = WaitR;\n                    rempty_out = 1'b1;\n                    rinc_out   = 1'b0;\n                end\n                else begin\n                    next_state = IDLE;\n                    rempty_out = 1'b1;\n                    rinc_out   = 1'b0;\n                end\n            end\n            WaitR:begin\n                if(rempty_in)begin\n                    next_state = WaitR;\n                    rempty_out = 1'b1;\n                    rinc_out   = 1'b0;\n                end\n                else begin\n                    next_state = Ready;\n                    rempty_out = 1'b1;\n                    rinc_out   = 1'b1;\n                end\n            end\n            Ready:begin\n                if(rde)begin\n                    if(rempty_in)begin\n                        next_state = WaitR;\n                        rempty_out = 1'b1;\n                        rinc_out   = 1'b0;\n                    end\n                    else begin\n                        next_state = Ready;\n                        rempty_out = 1'b1;\n                        rinc_out   = 1'b1;\n                    end\n                end\n                else begin\n                    next_state = Ready;\n                    rempty_out = 1'b0;\n                    rinc_out   = 1'b0;\n                end\n            end\n            default:begin\n                next_state = IDLE;\n                rempty_out = 1'b1;\n                rinc_out   = 1'b0;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(rinc_out) \n           byte_buf <= i_byte[7:1];\n    end\n\n    always @(posedge clk) begin\n        if(rinc_out) \n            bp <= 4'b0;\n        else \n            if(rinc_in & ~rempty_out) \n               bp <= bp + 1'b1;\n    end\n\n    //Other comb logic\n\n    assign rde = bp[3];\n    assign o_bit = byte_buf[bp];\n\nendmodule"}, "output": {"rtl/Bitstream.sv": "module Bitstream(input  logic clk,rst_n,\n                 input  logic enb,\n                 input  logic rempty_in,\n                 input  logic rinc_in,\n                 input  logic [7:0] i_byte,\n                 output logic o_bit,\n                 output logic rempty_out,\n                 output logic rinc_out);\n    \n    parameter IDLE  = 3'b000;\n    parameter WaitR = 3'b001;\n    parameter Ready = 3'b010;\n    logic [1:0] curr_state,next_state;\n\n    logic [0:7] byte_buf;\n    logic [3:0] bp;\n    logic rde;\n\n    //FSM block\n\n    always_ff @(posedge clk) begin\n        if(!rst_n) curr_state <= IDLE;\n        else curr_state <= next_state;\n    end\n\n    always_comb begin\n        case(curr_state)\n            IDLE: next_state = Ready;\n            IDLE:begin\n                if(enb)begin\n                    next_state = WaitR;\n                    rempty_out = 1'b1;\n                    rinc_out   = 1'b0;\n                end\n                else begin\n                    next_state = IDLE;\n                    rempty_out = 1'b1;\n                    rinc_out   = 1'b0;\n                end\n            end\n            WaitR:begin\n                if(rempty_in)begin\n                    next_state = WaitR;\n                    rempty_out = 1'b1;\n                    rinc_out   = 1'b0;\n                end\n                else begin\n                    next_state = Ready;\n                    rempty_out = 1'b1;\n                    rinc_out   = 1'b1;\n                end\n            end\n            Ready:begin\n                if(rde)begin\n                    if(rempty_in)begin\n                        next_state = WaitR;\n                        rempty_out = 1'b1;\n                        rinc_out   = 1'b0;\n                    end\n                    else begin\n                        next_state = Ready;\n                        rempty_out = 1'b1;\n                        rinc_out   = 1'b1;\n                    end\n                end\n                else begin\n                    next_state = Ready;\n                    rempty_out = 1'b0;\n                    rinc_out   = 1'b0;\n                end\n            end\n            default:begin\n                next_state = IDLE;\n                rempty_out = 1'b1;\n                rinc_out   = 1'b0;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if(rinc_out) \n           byte_buf <= i_byte[7:1];\n    end\n\n    always @(posedge clk) begin\n        if(rinc_out) \n            bp <= 4'b0;\n        else \n            if(rinc_in & ~rempty_out) \n               bp <= bp + 1'b1;\n    end\n\n    //Other comb logic\n\n    assign rde = bp[3];\n    assign o_bit = byte_buf[bp];\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_square_root_0003": {"input": {"rtl/square_root.sv": "module square_root #(parameter WIDTH = 16) (\n    input  wire [WIDTH-1:0] num,       \n    output reg  [WIDTH/2-1:0] root     \n);\n    reg [WIDTH-1:0] remainder,square;         \n    reg [WIDTH/2-1:0] test_bit, temp_square;        \n    integer i,j;\n\n    always @(*) \n    begin\n        remainder = num;               \n        root = 0;                      \n        temp_square = 0;\n        \n      \n        for (i = WIDTH/2-1; i >= 0; i = i - 1) \n        begin\n            test_bit = 1'b1 << i;      \n            temp_square = (root | test_bit);        \n            square = 0; \n            for (j = 0; j < WIDTH; j = j + 1) \n            begin\n              if (temp_square[j]) \n              begin \n                  square = square + (temp_square << j); \n              end \n            end\n          \n            if (square <= remainder) \n            begin\n                root = root | test_bit; \n            end\n        end\n    end\nendmodule"}, "output": {"rtl/square_root_seq.sv": ""}, "obj": true}}
{"cvdp_copilot_static_branch_predict_0001": {"input": {}, "output": {"rtl/static_branch_predict.sv": ""}, "obj": true}}
{"cvdp_copilot_static_branch_predict_0009": {"input": {"rtl/static_branch_predict.sv": "module static_branch_predict (\n  \n  // Instruction from fetch stage\n  input  logic [31:0] fetch_rdata_i,\n  input  logic [31:0] fetch_pc_i,\n  input  logic [31:0] register_addr_i,\n  input  logic        fetch_valid_i,\n\n  // Prediction for supplied instruction\n  output logic        predict_branch_taken_o,\n  output logic [31:0] predict_branch_pc_o\n);\n  logic [31:0] reg_addr;\n  logic [31:0] imm_jal_type;\n  logic [31:0] imm_jalr_type;\n  logic [31:0] imm_b_type;\n  logic [31:0] imm_cj_type;\n  logic [31:0] imm_cb_type;\n\n  logic [31:0] branch_imm;\n\n  logic [31:0] instr;\n\n  logic instr_jal;\n  logic instr_jalr;\n  logic instr_b;\n  logic instr_cj;\n  logic instr_cb;\n\n  logic instr_b_taken;\n  \n    \n  localparam OPCODE_BRANCH = 7'h63;\n  localparam OPCODE_JAL    = 7'h6F;\n  localparam OPCODE_JALR   = 7'h67;\n\n  assign instr = fetch_rdata_i;\n  assign reg_addr = register_addr_i;\n\n  assign imm_jal_type = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n  assign imm_jalr_type = {{20{instr[31]}}, instr[31:20]}+reg_addr;\n  assign imm_b_type = { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\n  assign imm_cj_type = { {20{instr[12]}}, instr[12], instr[8], instr[10:9], instr[6], instr[7],\n    instr[2], instr[11], instr[5:3], 1'b0 };\n\n  assign imm_cb_type = { {23{instr[12]}}, instr[12], instr[6:5], instr[2], instr[11:10],\n    instr[4:3], 1'b0};\n\n  assign instr_b    = instr[6:0] == OPCODE_BRANCH;\n  assign instr_jal  = instr[6:0] == OPCODE_JAL;\n  assign instr_jalr = instr[6:0] == OPCODE_JALR;\n\n  assign instr_cb = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b110) | (instr[15:13] == 3'b111));\n  assign instr_cj = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b101) | (instr[15:13] == 3'b001));\n\n  always_comb begin\n    branch_imm = imm_b_type;\n\n    case(1'b1)\n      instr_jal  : branch_imm = imm_jal_type;\n      instr_jalr : branch_imm = imm_jalr_type;\n      instr_b    : branch_imm = imm_b_type;\n      instr_cj   : branch_imm = imm_cj_type;\n      instr_cb   : branch_imm = imm_cb_type;\n      default    : ;\n    endcase\n  end\n  assign predict_branch_pc_o    = fetch_pc_i + branch_imm; \n  assign instr_b_taken = (instr_b & imm_b_type[31]) | (instr_cb & imm_cb_type[31]);\n  assign predict_branch_taken_o = fetch_valid_i & (instr_jal | instr_jalr | instr_cj | instr_b_taken);\n  \nendmodule"}, "output": {"rtl/static_branch_predict.sv": "module static_branch_predict (\n  \n  // Instruction from fetch stage\n  input  logic [31:0] fetch_rdata_i,\n  input  logic [31:0] fetch_pc_i,\n  input  logic [31:0] register_addr_i,\n  input  logic        fetch_valid_i,\n\n  // Prediction for supplied instruction\n  output logic        predict_branch_taken_o,\n  output logic [31:0] predict_branch_pc_o\n);\n  logic [31:0] reg_addr;\n  logic [31:0] imm_jal_type;\n  logic [31:0] imm_jalr_type;\n  logic [31:0] imm_b_type;\n  logic [31:0] imm_cj_type;\n  logic [31:0] imm_cb_type;\n\n  logic [31:0] branch_imm;\n\n  logic [31:0] instr;\n\n  logic instr_jal;\n  logic instr_jalr;\n  logic instr_b;\n  logic instr_cj;\n  logic instr_cb;\n\n  logic instr_b_taken;\n  \n    \n  localparam OPCODE_BRANCH = 7'h63;\n  localparam OPCODE_JAL    = 7'h6F;\n  localparam OPCODE_JALR   = 7'h67;\n\n  assign instr = fetch_rdata_i;\n  assign reg_addr = register_addr_i;\n\n  assign imm_jal_type = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n  assign imm_jalr_type = {{20{instr[31]}}, instr[31:20]}+reg_addr;\n  assign imm_b_type = { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\n  assign imm_cj_type = { {20{instr[12]}}, instr[12], instr[8], instr[10:9], instr[6], instr[7],\n    instr[2], instr[11], instr[5:3], 1'b0 };\n\n  assign imm_cb_type = { {23{instr[12]}}, instr[12], instr[6:5], instr[2], instr[11:10],\n    instr[4:3], 1'b0};\n\n  assign instr_b    = instr[6:0] == OPCODE_BRANCH;\n  assign instr_jal  = instr[6:0] == OPCODE_JAL;\n  assign instr_jalr = instr[6:0] == OPCODE_JALR;\n\n  assign instr_cb = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b110) | (instr[15:13] == 3'b111));\n  assign instr_cj = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b101) | (instr[15:13] == 3'b001));\n\n  always_comb begin\n    branch_imm = imm_b_type;\n\n    case(1'b1)\n      instr_jal  : branch_imm = imm_jal_type;\n      instr_jalr : branch_imm = imm_jalr_type;\n      instr_b    : branch_imm = imm_b_type;\n      instr_cj   : branch_imm = imm_cj_type;\n      instr_cb   : branch_imm = imm_cb_type;\n      default    : ;\n    endcase\n  end\n  assign predict_branch_pc_o    = fetch_pc_i + branch_imm; \n  assign instr_b_taken = (instr_b & imm_b_type[31]) | (instr_cb & imm_cb_type[31]);\n  assign predict_branch_taken_o = fetch_valid_i & (instr_jal | instr_jalr | instr_cj | instr_b_taken);\n  \nendmodule"}, "obj": true}}
{"cvdp_copilot_static_branch_predict_0013": {"input": {}, "output": {"rtl/static_branch_predict.sv": ""}, "obj": true}}
{"cvdp_copilot_static_branch_predict_0014": {"input": {}, "output": {"rtl/static_branch_predict.sv": ""}, "obj": true}}
{"cvdp_copilot_strobe_divider_0001": {"input": {}, "output": {"rtl/strobe_divider.sv": ""}, "obj": true}}
{"cvdp_copilot_swizzler_0009": {"input": {"rtl/swizzler.sv": "module swizzler #(\n    // Parameter N: Number of serial data lanes (default is 8)\n    parameter int N = 8\n)(\n    input clk,\n    input reset,\n    // Serial Input data lanes\n    input  logic [N-1:0]                 data_in,\n    // Encoded mapping input: concatenation of N mapping indices, each M bits wide\n    input  logic [N*$clog2(N)-1:0]       mapping_in,\n    // Control signal: 0 - mapping is LSB to MSB, 1 - mapping is MSB to LSB\n    input  logic                         config_in,\n    // Serial Output data lanes\n    output logic [N-1:0]                 data_out\n);\n    localparam int M = $clog2(N);\n    logic [M-1:0] map_idx [N];\n    genvar j;\n    generate\n        for (j = 0; j < N; j++) begin : lane_mapping\n            assign map_idx[j] = mapping_in[j*M +: M];\n        end\n    endgenerate\n\n    always_ff @ (posedge clk) begin\n        if (reset) begin\n            data_out <= '0;\n        end\n        else begin\n            for (int i = 0; i < N; i++) begin\n                if (map_idx[i] >= 0 && map_idx[i] < N) begin\n                    if (config_in) begin\n                        data_out[i] <= data_in[map_idx[i]];\n                    end\n                    else begin\n                        data_out[N-1-i] <= data_in[map_idx[i]];\n                    end\n                end\n                else begin\n                    data_out[i] <= '0;\n                end\n            end\n        end\n    end\nendmodule"}, "output": {"rtl/swizzler.sv": "module swizzler #(\n    // Parameter N: Number of serial data lanes (default is 8)\n    parameter int N = 8\n)(\n    input clk,\n    input reset,\n    // Serial Input data lanes\n    input  logic [N-1:0]                 data_in,\n    // Encoded mapping input: concatenation of N mapping indices, each M bits wide\n    input  logic [N*$clog2(N)-1:0]       mapping_in,\n    // Control signal: 0 - mapping is LSB to MSB, 1 - mapping is MSB to LSB\n    input  logic                         config_in,\n    // Serial Output data lanes\n    output logic [N-1:0]                 data_out\n);\n    localparam int M = $clog2(N);\n    logic [M-1:0] map_idx [N];\n    genvar j;\n    generate\n        for (j = 0; j < N; j++) begin : lane_mapping\n            assign map_idx[j] = mapping_in[j*M +: M];\n        end\n    endgenerate\n\n    always_ff @ (posedge clk) begin\n        if (reset) begin\n            data_out <= '0;\n        end\n        else begin\n            for (int i = 0; i < N; i++) begin\n                if (map_idx[i] >= 0 && map_idx[i] < N) begin\n                    if (config_in) begin\n                        data_out[i] <= data_in[map_idx[i]];\n                    end\n                    else begin\n                        data_out[N-1-i] <= data_in[map_idx[i]];\n                    end\n                end\n                else begin\n                    data_out[i] <= '0;\n                end\n            end\n        end\n    end\nendmodule"}, "obj": true}}
{"cvdp_copilot_swizzler_0014": {"input": {"rtl/swizzler.sv": "`timescale 1ns/1ps\n\nmodule swizzler #(\n    parameter int N = 8\n)(\n    input  logic clk,\n    input  logic reset,\n    input  logic [N-1:0] data_in,\n    input  logic [N*($clog2(N+1))-1:0] mapping_in,\n    input  logic config_in,\n    input  logic [2:0] operation_mode,\n    output logic [N-1:0] data_out,\n    output logic error_flag\n);\n\n    localparam int M = $clog2(N+1);\n\n    logic [M-1:0] map_idx [N];\n    genvar j;\n    generate\n        for (j = 0; j < N; j++) begin\n            assign map_idx[j] = mapping_in[j*M + 1 +: M];\n        end\n    endgenerate\n\n    logic [N-1:0] temp_swizzled_data;\n    logic [N-1:0] processed_swizzle_data;\n    logic         temp_error_flag;\n    logic [N-1:0] swizzle_reg;\n    logic         error_reg;\n    logic [N-1:0] operation_reg;\n\n    always_comb begin\n        temp_error_flag = 1'b0;\n\n        for (int i = 0; i < N; i++) begin\n            // Was: if (map_idx[i] >= N)\n            if (map_idx[i] > N) begin\n                temp_error_flag = 1'b1;\n            end\n        end\n\n        if (temp_error_flag) begin\n            temp_swizzled_data = '0;\n        end else begin\n            for (int i = 0; i < N; i++) begin\n                temp_swizzled_data[i] = data_in[map_idx[i]];\n            end\n        end\n\n        for (int i = 0; i < N; i++) begin\n            if (config_in) begin\n                processed_swizzle_data[i] = temp_swizzled_data[i];\n            end else begin\n                processed_swizzle_data[i] = temp_swizzled_data[N - 1 - i];\n            end\n        end\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            swizzle_reg <= '0;\n            error_reg   <= 1'b0;\n        end else begin\n            swizzle_reg <= processed_swizzle_data + 1; \n            error_reg   <= temp_error_flag;\n        end\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            operation_reg <= '0;\n        end else begin\n            case (operation_mode)\n                3'b000: operation_reg <= swizzle_reg;\n                3'b001: operation_reg <= swizzle_reg;\n                3'b010: for (int i = 0; i < N; i++) operation_reg[i] <= swizzle_reg[N-1-i];\n                3'b011: operation_reg <= {swizzle_reg[N/2-1:0], swizzle_reg[N-1:N/2]};\n                3'b100: operation_reg <= ~swizzle_reg;\n                3'b101: operation_reg <= {swizzle_reg[N-2:0], swizzle_reg[N]};\n                3'b110: operation_reg <= {swizzle_reg[0], swizzle_reg[N-1:1]};\n                default: operation_reg <= swizzle_reg;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            data_out   <= '0;\n            error_flag <= 1'b0;\n        end else begin\n            for (int i = 1; i < N; i++) begin\n                data_out[i] <= operation_reg[N-1-i];\n            end\n            error_flag <= error_reg;\n        end\n    end\n\nendmodule"}, "output": {"rtl/swizzler.sv": "`timescale 1ns/1ps\n\nmodule swizzler #(\n    parameter int N = 8\n)(\n    input  logic clk,\n    input  logic reset,\n    input  logic [N-1:0] data_in,\n    input  logic [N*($clog2(N+1))-1:0] mapping_in,\n    input  logic config_in,\n    input  logic [2:0] operation_mode,\n    output logic [N-1:0] data_out,\n    output logic error_flag\n);\n\n    localparam int M = $clog2(N+1);\n\n    logic [M-1:0] map_idx [N];\n    genvar j;\n    generate\n        for (j = 0; j < N; j++) begin\n            assign map_idx[j] = mapping_in[j*M + 1 +: M];\n        end\n    endgenerate\n\n    logic [N-1:0] temp_swizzled_data;\n    logic [N-1:0] processed_swizzle_data;\n    logic         temp_error_flag;\n    logic [N-1:0] swizzle_reg;\n    logic         error_reg;\n    logic [N-1:0] operation_reg;\n\n    always_comb begin\n        temp_error_flag = 1'b0;\n\n        for (int i = 0; i < N; i++) begin\n            // Was: if (map_idx[i] >= N)\n            if (map_idx[i] > N) begin\n                temp_error_flag = 1'b1;\n            end\n        end\n\n        if (temp_error_flag) begin\n            temp_swizzled_data = '0;\n        end else begin\n            for (int i = 0; i < N; i++) begin\n                temp_swizzled_data[i] = data_in[map_idx[i]];\n            end\n        end\n\n        for (int i = 0; i < N; i++) begin\n            if (config_in) begin\n                processed_swizzle_data[i] = temp_swizzled_data[i];\n            end else begin\n                processed_swizzle_data[i] = temp_swizzled_data[N - 1 - i];\n            end\n        end\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            swizzle_reg <= '0;\n            error_reg   <= 1'b0;\n        end else begin\n            swizzle_reg <= processed_swizzle_data + 1; \n            error_reg   <= temp_error_flag;\n        end\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            operation_reg <= '0;\n        end else begin\n            case (operation_mode)\n                3'b000: operation_reg <= swizzle_reg;\n                3'b001: operation_reg <= swizzle_reg;\n                3'b010: for (int i = 0; i < N; i++) operation_reg[i] <= swizzle_reg[N-1-i];\n                3'b011: operation_reg <= {swizzle_reg[N/2-1:0], swizzle_reg[N-1:N/2]};\n                3'b100: operation_reg <= ~swizzle_reg;\n                3'b101: operation_reg <= {swizzle_reg[N-2:0], swizzle_reg[N]};\n                3'b110: operation_reg <= {swizzle_reg[0], swizzle_reg[N-1:1]};\n                default: operation_reg <= swizzle_reg;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            data_out   <= '0;\n            error_flag <= 1'b0;\n        end else begin\n            for (int i = 1; i < N; i++) begin\n                data_out[i] <= operation_reg[N-1-i];\n            end\n            error_flag <= error_reg;\n        end\n    end\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_sync_lifo_0001": {"input": {}, "output": {"rtl/sync_lifo.sv": ""}, "obj": true}}
{"cvdp_copilot_sync_lifo_0010": {"input": {"rtl/sync_lifo.sv": "`timescale 1ns / 1ps\n\nmodule sync_lifo #(\n    parameter DATA_WIDTH = 8,  // Width of the data\n    parameter ADDR_WIDTH = 3   // Number of bits for the address (determines the depth)\n)(\n    input wire clock,                         // System clock\n    input wire reset,                         // Synchronous reset\n    input wire write_en,                      // Write enable\n    input wire read_en,                       // Read enable\n    input wire [DATA_WIDTH-1:0] data_in,      // Data input to be written into LIFO\n    output wire empty,                        // Indicates if LIFO is empty\n    output wire full,                         // Indicates if LIFO is full\n    output wire [DATA_WIDTH-1:0] data_out     // Data output from LIFO\n);\n\n    // Calculate depth of the LIFO using the address width\n    localparam DEPTH = (1 << ADDR_WIDTH);      // Depth = 2^ADDR_WIDTH\n\n    // Registers for LIFO logic\n    reg [DEPTH-1:0] ptr;                       // Pointer for write/read operations\n    reg [DEPTH-1:0] lifo_counter;              // Counter to track the number of elements in the LIFO\n    reg [DATA_WIDTH-1:0] memory [DEPTH-1:0];   // Memory array to store LIFO data\n    reg [DATA_WIDTH-1:0] temp_data_out;        // Temporary register for output data\n    integer i;\n\n    // Output assignments for empty and full flags\n    assign empty = (lifo_counter == 0) ? 1'b1 : 1'b0;                  // LIFO is empty if counter is zero\n    assign full  = (lifo_counter == DEPTH)? 1'b1 : 1'b0;               // LIFO is full if counter equals DEPTH\n\n    // Counter logic to track the number of elements in LIFO\n    always @(posedge clock) begin\n        if (reset) begin\n            lifo_counter <= 0;                                          // Reset the counter when reset signal is active\n        end else if (!full && write_en) begin\n            lifo_counter <= lifo_counter + 1;                           // Increment counter on write if LIFO is not full\n        end else if (!empty && read_en) begin\n            lifo_counter <= lifo_counter - 1;                           // Decrement counter on read if LIFO is not empty\n        end\n    end\n\n    // Memory write logic: writes data into the LIFO\n    always @(posedge clock) begin\n        if (reset) begin\n            ptr <= {ADDR_WIDTH {1'b0}};                                  // Reset pointer to zero on reset\n        end else if (write_en && !full) begin\n            memory[ptr] <= data_in;                                      // Write input data into memory at current pointer\n            ptr <= ptr + 1;                                              // Increment pointer to next memory location\n        end\n    end\n\n    // Memory read logic: reads data from the LIFO\n    always @(posedge clock) begin\n        if (reset) begin\n            temp_data_out <= {DATA_WIDTH{1'b0}};                         // Clear output data on reset\n        end else if (read_en && !empty) begin\n            temp_data_out <= memory[ptr - 1'b1];                         // Read data from memory at (pointer - 1)\n            ptr <= ptr - 1;                                              // Decrement pointer after reading\n        end\n    end\n\n    // Assign the output data\n    assign data_out = temp_data_out;                                     // Assign temp data output to the actual output\nendmodule"}, "output": {"rtl/sync_lifo.sv": ""}, "obj": true}}
{"cvdp_copilot_sync_serial_communication_0001": {"input": {}, "output": {"rtl/sync_serial_communication_top.sv": ""}, "obj": true}}
{"cvdp_copilot_sync_serial_communication_0014": {"input": {"rtl/sync_serial_communication_top.sv": "`timescale 1ns / 1ps\nmodule sync_serial_communication_tx_rx(\n    input clk,                     // Clock signal\n    input reset_n,                 // Active low reset signal\n    input [2:0] sel,               // Selection signal for TX block\n    input [63:0] data_in,          // 64-bit data input for TX block\n    output [63:0] data_out,        // 64-bit data output from RX block\n    output done                    // Done signal indicating completion\n);\n\n// Internal signals\nwire tx_out;                       // Serial data output from TX block\nwire tx_done;                      // Done signal from TX block\nwire serial_clk_in;                // Serial clock generated by TX block\n\n// Instantiate the TX block\ntx_block uut_tx_block (\n    .clk(clk),                     // Clock input to TX block\n    .reset_n(reset_n),             // Reset input to TX block\n    .data_in(data_in),             // 64-bit data input to TX block\n    .sel(sel),                     // Selection signal to TX block\n    .serial_out(tx_out),           // Serial data output from TX block\n    .done(tx_done),                // Done signal from TX block\n    .serial_clk(serial_clk_in)     // Serial clock output from TX block\n);\n\n// Instantiate the RX block\nrx_block uut_rx_block (\n    .clk(clk),                     // Clock input to RX block\n    .serial_clk(serial_clk_in),    // Serial clock input to RX block\n    .reset_n(reset_n),             // Reset input to RX block\n    .sel(sel),                     // Selection signal to RX block\n    .data_in(tx_out),              // Serial data input to RX block\n    .data_out(data_out),           // 64-bit data output from RX block\n    .done(done)                    // Done signal from RX block\n);\n\nendmodule\n\n///// tx_block\nmodule tx_block(\n    input clk,               // Clock input\n    input reset_n,           // Active-low reset input\n    input [63:0] data_in,    // 64-bit parallel data input\n    input [2:0] sel,         // Selection input to choose data width\n    output reg serial_out,   // Serial data output\n    output reg done,         // Done signal indicating completion of transmission\n    output serial_clk        // Clock for serial data transmission\n);\n\n// Internal registers\nreg [63:0] data_reg;         // Register to hold the data being transmitted\nreg [6:0] bit_count;         // Counter to track number of bits to transmit\nreg [6:0] reg_count;         // Register for counting bits for serial clock control\nreg [6:0] temp_reg_count;    // Temporary register to track reg_count\n\n// Sequential block for state control and data selection\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Reset all values on active-low reset\n        data_reg     <= 64'h0;\t\t\t     \t           // Clear the data register\n        bit_count    <= 7'h0;\t\t\t     \t           // Reset bit count to zero\n        reg_count    <= 7'h0;\t\t             \t       // Reset reg_count to zero\n    end else begin\n        if (done == 1'b1) begin\n\t    // Case block to determine the width of data to transmit based on the 'sel' input\n            case (sel)\n                3'b000: begin\n                    data_reg  <= 64'h0;             \t   // No data selected\n                    bit_count <= 7'd0;                     // No bits to transmit\n                end\n                3'b001: begin\n                    data_reg  <= {56'h0, data_in[7:0]};    // Transmit lowest 8 bits\n                    bit_count <= 7'd7;              \t   // 8 bits to transmit\n                end\n                3'b010: begin\n                    data_reg  <= {48'h0, data_in[15:0]};   // Transmit lowest 16 bits\n                    bit_count <= 7'd15;             \t   // 16 bits to transmit\n                end\n                3'b011: begin\n                    data_reg  <= {32'h0, data_in[31:0]};   // Transmit lowest 32 bits\n                    bit_count <= 7'd31;             \t   // 32 bits to transmit\n                end\n                3'b100: begin\n                    data_reg  <= data_in[63:0];     \t   // Transmit all 64 bits\n                    bit_count <= 7'd63;             \t   // 64 bits to transmit\n                end\n                default: begin\n                    data_reg  <= 64'h0;             \t   // Default case: no data\n                    bit_count <= 7'h0;              \t   // No bits to transmit\n                end\n            endcase\n           \n        end else if (bit_count > 7'h0) begin\n            data_reg   <= data_reg >> 1;                   // Shift the data to the right\n            bit_count  <= bit_count - 1'b1;                // Decrement the bit count\n            \n        end\n        reg_count <= bit_count;                            // Update reg_count for serial clock control\n    end\nend\n\n// Generate serial clock based on reg_count\n//`ifdef SIMULATION\nassign  #1 serial_clk = clk && (temp_reg_count !== 7'd0) ;  // To avoid SImulator issue \n//`else\n//assign  serial_clk = clk && (temp_reg_count !== 7'd0) ;  \n//`endif\n\n// Register to keep track of reg_count and use for clock gating\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n        temp_reg_count <= 7'h0;\t\t\t\t\t           // Reset temporary reg_count\n    end\n    else begin\n        temp_reg_count <= reg_count;\t\t\t           // Update temp_reg_count with current reg_count\n    end\nend\n\n\n// Sequential logic to drive the serial_out signal based on reg_count and bit_count\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n\t   serial_out <= 1'b0;\t\t\t\t                  // Reset serial output\n    end\n    else if(reg_count > 7'h0 || bit_count > 7'h0) begin\n\t   serial_out <= data_reg[0];\t\t\t              // Output the least significant bit of data_reg\n    end\nend\n\n// Set the done signal when transmission is complete (bit_count reaches zero)\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        done <= 1'b0;\t\t\t\t\t                  // Reset done output\n    end \n    else begin\n     if(bit_count == 7'h0) begin\n\t    done <= 1'b1; \t\t\t                          // Set done signal high when transmission is done\n     end\n     else begin \n\t    done <= 1'b0;\t\t\t\t\t                  // Clear done signal during transmission\n     end\nend\nend\n\n\nendmodule\n\n///// rx_block\nmodule rx_block(\n    input wire clk,  \t\t\t    // clock input\n    input wire reset_n,\t\t\t    // Active-low reset\n    input wire data_in,\t\t\t    // Serial input data\t\n    input wire serial_clk,\t\t    // Clock signal for serial data\n    input wire [2:0] sel,           // Selection output to choose data width\n    output reg done,\t\t\t    // Done signal to indicate data reception complete\t\t\n    output reg [63:0] data_out  \t// Parallel output data after serial operation\n\n);\n\n    // Internal registers\n    reg [63:0] data_reg;\t\t    // Register to hold incoming serial data\n    reg [7:0] bit_count;\t\t    // Counter for the number of bits received\t\n    reg [7:0] count;\t\t\t    // General purpose counter to sync with bit_count\n\n\n    // Sequential logic block to capture serial data on the rising edge of serial_clk\n    always @(posedge serial_clk or negedge  reset_n) begin\n        if (!reset_n) begin\t\t    // Reset all registers on reset_n (active low)\n            data_reg <= 64'h0;\t\t// Clear the data register\n            bit_count <= 8'd0;\t\t// Clear the bit counter\n        end else begin\n            if(done == 1'b1) begin                   // If done signal is asserted, reset the bit counter and data register  \n                bit_count <= 8'b0;\n                data_reg <= 64'h0;\n            end\n            else begin\n                 bit_count <= bit_count;\t\t\t // Maintain the bit counter if not done\n            end\n                bit_count <= bit_count + 1'b1;\t     // Increment bit count\n                data_reg[bit_count]<=data_in; \t     // Store the incoming data bit \n           end\n    end  \n    \n    // Sequential logic block to monitor the completion of data reception and update outputs\n    always@(posedge clk or negedge reset_n) begin\n    \tif(!reset_n) begin\t\t\t \t             // Reset all registers on reset_n (active low)\n    \t   count <= 8'd0;\t\t\t\t\t         // Clear the bit counter\n           done <= 1'b0;\t\t\t\t\t         // Deassert done signal\n           data_out <= 64'h0;\t\t\t\t\t     // Clear the output data register\t\t\t\t\t \n        end \n        else if(count >= bit_count && count != 8'd0) begin       // When the count reaches the bit_count, assert done and output the data\n           done <= 1'b1;\t\t\t\t             // Set done to indicate transmission complete\n           case(sel)\n            3'b000:begin\n                data_out <= 64'h0;                   // no bits to transmit\n            end\n            3'b001:begin\n                data_out <= {56'h0,data_reg};        // 8 bits of data_reg \n            end\n            3'b010:begin\n                data_out <= {48'h0,data_reg};        // 16 bits of data_reg\n            end\n            3'b011:begin\n                data_out <= {32'h0,data_reg};        // 32 bits of data_reg\n            end\n            3'b100:begin\n                data_out <= data_reg;                // 64 bits of data_reg\n            end\n            default:begin\n                data_out <= 64'h0;                   // no bits to transmit, default state\n            end\n           endcase\n        end\n        else if(bit_count > 8'd0) begin              // If bits are being received, increment the count and deassert done\n           count <= count+ 1'b1;\t\t\t\t     // Increment count\n           done <= 1'b0;\t\t\t\t\t         // Clear done signal while receiving\n        end\n        else begin  \t\t\t                     // If no bits have been received, reset the count and deassert done\n           count <= 8'd0;\t\t\t\t\t         // Reset count\n           done <= 1'b0;\t\t\t\t\t         // Clear done signal   \n        end \n    end\n\nendmodule"}, "output": {"rtl/sync_serial_communication_top.sv": ""}, "obj": true}}
{"cvdp_copilot_sync_serial_communication_0052": {"input": {"rtl/sync_serial_communication_top.sv": "`timescale 1ns / 1ps\nmodule sync_serial_communication_tx_rx(\n    input clk,                     // Clock signal\n    input reset_n,                 // Active low reset signal\n    input [2:0] sel,               // Selection signal for TX block\n    input [63:0] data_in,          // 64-bit data input for TX block\n    output [63:0] data_out,        // 64-bit data output from RX block\n    output done                    // Done signal indicating completion\n);\n\n// Internal signals\nwire tx_out;                       // Serial data output from TX block\nwire tx_done;                      // Done signal from TX block\nwire serial_clk_in;                // Serial clock generated by TX block\n\n// Instantiate the TX block\ntx_block uut_tx_block (\n    .clk(clk),                     // Clock input to TX block\n    .reset_n(reset_n),             // Reset input to TX block\n    .data_in(data_in),             // 64-bit data input to TX block\n    .sel(sel),                     // Selection signal to TX block\n    .serial_out(tx_out),           // Serial data output from TX block\n    .done(tx_done),                // Done signal from TX block\n    .serial_clk(serial_clk_in)     // Serial clock output from TX block\n);\n\n// Instantiate the RX block\nrx_block uut_rx_block (\n    .clk(clk),                     // Clock input to RX block\n    .serial_clk(serial_clk_in),    // Serial clock input to RX block\n    .reset_n(reset_n),             // Reset input to RX block\n    .sel(sel),                     // Selection signal to RX block\n    .data_in(tx_out),              // Serial data input to RX block\n    .data_out(data_out),           // 64-bit data output from RX block\n    .done(done)                    // Done signal from RX block\n);\n\nendmodule\n\n///// tx_block\nmodule tx_block(\n    input clk,               // Clock input\n    input reset_n,           // Active-low reset input\n    input [63:0] data_in,    // 64-bit parallel data input\n    input [2:0] sel,         // Selection input to choose data width\n    output reg serial_out,   // Serial data output\n    output reg done,         // Done signal indicating completion of transmission\n    output serial_clk        // Clock for serial data transmission\n);\n\n// Internal registers\nreg [63:0] data_reg;         // Register to hold the data being transmitted\nreg [6:0] bit_count;         // Counter to track number of bits to transmit\nreg [6:0] reg_count;         // Register for counting bits for serial clock control\nreg [6:0] temp_reg_count;    // Temporary register to track reg_count\n\n// Sequential block for state control and data selection\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        // Reset all values on active-low reset\n        data_reg     <= 64'h0;\t\t\t     \t           // Clear the data register\n        bit_count    <= 7'h0;\t\t\t     \t           // Reset bit count to zero\n        reg_count    <= 7'h0;\t\t             \t       // Reset reg_count to zero\n    end else begin\n        if (done == 1'b1) begin\n\t    // Case block to determine the width of data to transmit based on the 'sel' input\n            case (sel)\n                3'b000: begin\n                    data_reg  <= 64'h0;             \t   // No data selected\n                    bit_count <= 7'd0;                     // No bits to transmit\n                end\n                3'b001: begin\n                    data_reg  <= {56'h0, data_in[7:0]};    // Transmit lowest 8 bits\n                    bit_count <= 7'd7;              \t   // 8 bits to transmit\n                end\n                3'b010: begin\n                    data_reg  <= {48'h0, data_in[15:0]};   // Transmit lowest 16 bits\n                    bit_count <= 7'd15;             \t   // 16 bits to transmit\n                end\n                3'b011: begin\n                    data_reg  <= {32'h0, data_in[31:0]};   // Transmit lowest 32 bits\n                    bit_count <= 7'd31;             \t   // 32 bits to transmit\n                end\n                3'b100: begin\n                    data_reg  <= data_in[63:0];     \t   // Transmit all 64 bits\n                    bit_count <= 7'd63;             \t   // 64 bits to transmit\n                end\n                default: begin\n                    data_reg  <= 64'h0;             \t   // Default case: no data\n                    bit_count <= 7'h0;              \t   // No bits to transmit\n                end\n            endcase\n           \n        end else if (bit_count > 7'h0) begin\n            data_reg   <= data_reg >> 1;                   // Shift the data to the right\n            bit_count  <= bit_count - 1'b1;                // Decrement the bit count\n            \n        end\n        reg_count <= bit_count;                            // Update reg_count for serial clock control\n    end\nend\n\n// Generate serial clock based on reg_count\n//`ifdef SIMULATION\nassign  #1 serial_clk = clk && (temp_reg_count !== 7'd0) ;  // To avoid SImulator issue \n//`else\n//assign  serial_clk = clk && (temp_reg_count !== 7'd0) ;  \n//`endif\n\n// Register to keep track of reg_count and use for clock gating\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n        temp_reg_count <= 7'h0;\t\t\t\t\t           // Reset temporary reg_count\n    end\n    else begin\n        temp_reg_count <= reg_count;\t\t\t           // Update temp_reg_count with current reg_count\n    end\nend\n\n\n// Sequential logic to drive the serial_out signal based on reg_count and bit_count\nalways@(posedge clk or negedge reset_n) begin \n    if(!reset_n) begin\n\t   serial_out <= 1'b0;\t\t\t\t                  // Reset serial output\n    end\n    else if(reg_count > 7'h0 || bit_count > 7'h0) begin\n\t   serial_out <= data_reg[0];\t\t\t              // Output the least significant bit of data_reg\n    end\nend\n\n// Set the done signal when transmission is complete (bit_count reaches zero)\nalways@(posedge clk or negedge reset_n) begin\n    if(!reset_n) begin\n        done <= 1'b0;\t\t\t\t\t                  // Reset done output\n    end \n    else begin\n     if(bit_count == 7'h0) begin\n\t    done <= 1'b1; \t\t\t                          // Set done signal high when transmission is done\n     end\n     else begin \n\t    done <= 1'b0;\t\t\t\t\t                  // Clear done signal during transmission\n     end\nend\nend\n\n\nendmodule\n\n///// rx_block\nmodule rx_block(\n    input wire clk,  \t\t\t    // clock input\n    input wire reset_n,\t\t\t    // Active-low reset\n    input wire data_in,\t\t\t    // Serial input data\t\n    input wire serial_clk,\t\t    // Clock signal for serial data\n    input wire [2:0] sel,           // Selection output to choose data width\n    output reg done,\t\t\t    // Done signal to indicate data reception complete\t\t\n    output reg [63:0] data_out  \t// Parallel output data after serial operation\n\n);\n\n    // Internal registers\n    reg [63:0] data_reg;\t\t    // Register to hold incoming serial data\n    reg [7:0] bit_count;\t\t    // Counter for the number of bits received\t\n    reg [7:0] count;\t\t\t    // General purpose counter to sync with bit_count\n\n\n    // Sequential logic block to capture serial data on the rising edge of serial_clk\n    always @(posedge serial_clk or negedge  reset_n) begin\n        if (!reset_n) begin\t\t    // Reset all registers on reset_n (active low)\n            data_reg <= 64'h0;\t\t// Clear the data register\n            bit_count <= 8'd0;\t\t// Clear the bit counter\n        end else begin\n            if(done == 1'b1) begin                   // If done signal is asserted, reset the bit counter and data register  \n                bit_count <= 8'b0;\n                data_reg <= 64'h0;\n            end\n            else begin\n                 bit_count <= bit_count;\t\t\t // Maintain the bit counter if not done\n            end\n                bit_count <= bit_count + 1'b1;\t     // Increment bit count\n                data_reg[bit_count]<=data_in; \t     // Store the incoming data bit \n           end\n    end  \n    \n    // Sequential logic block to monitor the completion of data reception and update outputs\n    always@(posedge clk or negedge reset_n) begin\n    \tif(!reset_n) begin\t\t\t \t             // Reset all registers on reset_n (active low)\n    \t   count <= 8'd0;\t\t\t\t\t         // Clear the bit counter\n           done <= 1'b0;\t\t\t\t\t         // Deassert done signal\n           data_out <= 64'h0;\t\t\t\t\t     // Clear the output data register\t\t\t\t\t \n        end \n        else if(count >= bit_count && count != 8'd0) begin       // When the count reaches the bit_count, assert done and output the data\n           done <= 1'b1;\t\t\t\t             // Set done to indicate transmission complete\n           case(sel)\n            3'b000:begin\n                data_out <= 64'h0;                   // no bits to transmit\n            end\n            3'b001:begin\n                data_out <= {56'h0,data_reg};        // 8 bits of data_reg \n            end\n            3'b010:begin\n                data_out <= {48'h0,data_reg};        // 16 bits of data_reg\n            end\n            3'b011:begin\n                data_out <= {32'h0,data_reg};        // 32 bits of data_reg\n            end\n            3'b100:begin\n                data_out <= data_reg;                // 64 bits of data_reg\n            end\n            default:begin\n                data_out <= 64'h0;                   // no bits to transmit, default state\n            end\n           endcase\n        end\n        else if(bit_count > 8'd0) begin              // If bits are being received, increment the count and deassert done\n           count <= count+ 1'b1;\t\t\t\t     // Increment count\n           done <= 1'b0;\t\t\t\t\t         // Clear done signal while receiving\n        end\n        else begin  \t\t\t                     // If no bits have been received, reset the count and deassert done\n           count <= 8'd0;\t\t\t\t\t         // Reset count\n           done <= 1'b0;\t\t\t\t\t         // Clear done signal   \n        end \n    end\n\nendmodule"}, "output": {"rtl/sync_serial_communication_top.sv": ""}, "obj": true}}
{"cvdp_copilot_thermostat_0001": {"input": {}, "output": {"rtl/thermostat.v": ""}, "obj": true}}
{"cvdp_copilot_ttc_lite_0001": {"input": {}, "output": {"rtl/ttc_counter_lite.sv": ""}, "obj": true}}
{"cvdp_copilot_unpacker_one_hot_0001": {"input": {}, "output": {"rtl/unpack_one_hot.v": ""}, "obj": true}}
{"cvdp_copilot_vending_machine_0001": {"input": {}, "output": {"rtl/vending_machine.sv": ""}, "obj": true}}
{"cvdp_copilot_vga_controller_0001": {"input": {}, "output": {"rtl/vga_controller.sv": ""}, "obj": true}}
{"cvdp_copilot_vga_controller_0006": {"input": {}, "output": {"rtl/vga_controller.sv": ""}, "obj": true}}
{"cvdp_copilot_vga_controller_0026": {"input": {"rtl/vga_controller.sv": "module vga_controller (\n    input logic clock,      // 25 MHz\n    input logic reset,      // Active high\n    input logic [7:0] color_in, // Pixel color data (RRRGGGBB)\n    output logic [9:0] next_x,  // x-coordinate of NEXT pixel that will be drawn\n    output logic [9:0] next_y,  // y-coordinate of NEXT pixel that will be drawn\n    output logic hsync,     // HSYNC (to VGA connector)\n    output logic vsync,     // VSYNC (to VGA connector)\n    output logic [7:0] red, // RED (to resistor DAC VGA connector)\n    output logic [7:0] green, // GREEN (to resistor DAC to VGA connector)\n    output logic [7:0] blue, // BLUE (to resistor DAC to VGA connector)\n    output logic sync,      // SYNC to VGA connector\n    output logic clk,       // CLK to VGA connector\n    output logic blank,     // BLANK to VGA connector\n    output logic [7:0] h_state, // States of Horizontal FSM\n    output logic [7:0] v_state  // States of Vertical FSM\n);\n\n    parameter logic [9:0] H_ACTIVE  =  10'd640;\n    parameter logic [9:0] H_FRONT   =  10'd16;\n    parameter logic [9:0] H_PULSE   =  10'd96;\n    parameter logic [9:0] H_BACK    =  10'd48;\n    parameter logic [9:0] V_ACTIVE  =  10'd480;\n    parameter logic [9:0] V_FRONT   =  10'd10;\n    parameter logic [9:0] V_PULSE   =  10'd2;\n    parameter logic [9:0] V_BACK    =  10'd33;\n    parameter logic LOW   = 1'b0;\n    parameter logic HIGH  = 1'b1;\n    parameter logic [7:0] H_ACTIVE_STATE  = 8'd0;\n    parameter logic [7:0] H_FRONT_STATE   = 8'd1;\n    parameter logic [7:0] H_PULSE_STATE   = 8'd2;\n    parameter logic [7:0] H_BACK_STATE    = 8'd3;\n    parameter logic [7:0] V_ACTIVE_STATE  = 8'd0;\n    parameter logic [7:0] V_FRONT_STATE   = 8'd1;\n    parameter logic [7:0] V_PULSE_STATE   = 8'd2;\n    parameter logic [7:0] V_BACK_STATE    = 8'd3;\n\n    \n    logic line_done;\n    logic [9:0] h_counter;\n    logic [9:0] v_counter;\n    \n\n    always_ff @(posedge clock or posedge reset) begin\n        if (reset) begin\n            h_counter   <= 10'd0;\n            v_counter   <= 10'd0;\n            h_state     <= H_ACTIVE_STATE;\n            v_state     <= V_ACTIVE_STATE;\n            line_done   <= LOW;\n        end\n        else begin\n            case (h_state)\n                H_ACTIVE_STATE: begin\n                   h_counter <= (h_counter == (H_ACTIVE - 1)) ? 10'd0 : (h_counter + 10'd1);\n                   hsync     <= HIGH;\n                   line_done <= LOW;\n                   h_state   <= (h_counter == (H_ACTIVE - 1)) ? H_FRONT_STATE : H_ACTIVE_STATE;\n                end\n                H_FRONT_STATE: begin\n                   h_counter <= (h_counter == (H_FRONT - 1)) ? 10'd0 : (h_counter + 10'd1);\n                   hsync     <= HIGH;\n                   h_state   <= (h_counter == (H_FRONT - 1)) ? H_PULSE_STATE : H_FRONT_STATE;\n                end\n                H_PULSE_STATE: begin\n                  h_counter <= (h_counter == (H_PULSE - 1)) ? 10'd0 : (h_counter + 10'd1);\n                  hsync     <= LOW;\n                  h_state   <= (h_counter == (H_PULSE - 1)) ? H_BACK_STATE : H_PULSE_STATE;\n                end\n                H_BACK_STATE: begin\n                  h_counter <= (h_counter == (H_BACK - 1)) ? 10'd0 : (h_counter + 10'd1);\n                  hsync     <= HIGH;\n                  h_state   <= (h_counter == (H_BACK - 1)) ? H_ACTIVE_STATE : H_BACK_STATE;\n                  line_done <= (h_counter == (H_BACK - 1)) ? HIGH: LOW;\n                end\n            endcase\n            \n            case (v_state)\n                V_ACTIVE_STATE: begin\n                    if (line_done == HIGH) begin\n                        v_counter <= (v_counter == V_ACTIVE - 1) ? 10'd0 : (v_counter + 10'd1);\n                        v_state   <= (v_counter == V_ACTIVE - 1) ? V_FRONT_STATE : V_ACTIVE_STATE;\n                    end\n                    vsync  <= HIGH;\n                end\n                V_FRONT_STATE: begin\n                    if (line_done == HIGH) begin\n                        v_counter <= (v_counter == V_FRONT - 1) ? 10'd0 : (v_counter + 10'd1);\n                        v_state   <= (v_counter == V_FRONT - 1) ? V_PULSE_STATE : V_FRONT_STATE;\n                    end\n                    vsync  <= HIGH;\n                end\n                V_PULSE_STATE: begin\n                    if (line_done == HIGH) begin\n                        v_counter <= (v_counter == V_PULSE - 1) ? 10'd0 : (v_counter + 10'd1);\n                        v_state   <= (v_counter == V_PULSE - 1) ? V_BACK_STATE : V_PULSE_STATE;\n                    end\n                    vsync  <= LOW;\n                end\n                V_BACK_STATE: begin\n                    if (line_done == HIGH) begin\n                        v_counter <= (v_counter == V_BACK - 1) ? 10'd0 : (v_counter + 10'd1);\n                        v_state   <= (v_counter == V_BACK - 1) ? V_ACTIVE_STATE : V_BACK_STATE;\n                    end\n                    vsync  <= HIGH;\n                end\n            endcase\n            if (h_state == H_ACTIVE_STATE && v_state == V_ACTIVE_STATE) begin\n                red       <= {color_in[7:5], 5'd0};\n                green     <= {color_in[4:2], 5'd0};\n                blue      <= {color_in[1:0], 6'd0};\n            end\n            else begin\n                red       <= 8'd0;\n                green     <= 8'd0;\n                blue      <= 8'd0;\n            end\n        end\n    end\n    \n     \n    assign clk = clock;\n    assign sync = 1'b0;\n    assign blank = hsync & vsync;\n\n    assign next_x = (h_state == H_ACTIVE_STATE) ? h_counter : 10'd0;\n    assign next_y = (v_state == V_ACTIVE_STATE) ? v_counter : 10'd0;\n\nendmodule"}, "output": {"rtl/vga_controller.sv": "module vga_controller (\n    input logic clock,      // 25 MHz\n    input logic reset,      // Active high\n    input logic [7:0] color_in, // Pixel color data (RRRGGGBB)\n    output logic [9:0] next_x,  // x-coordinate of NEXT pixel that will be drawn\n    output logic [9:0] next_y,  // y-coordinate of NEXT pixel that will be drawn\n    output logic hsync,     // HSYNC (to VGA connector)\n    output logic vsync,     // VSYNC (to VGA connector)\n    output logic [7:0] red, // RED (to resistor DAC VGA connector)\n    output logic [7:0] green, // GREEN (to resistor DAC to VGA connector)\n    output logic [7:0] blue, // BLUE (to resistor DAC to VGA connector)\n    output logic sync,      // SYNC to VGA connector\n    output logic clk,       // CLK to VGA connector\n    output logic blank,     // BLANK to VGA connector\n    output logic [7:0] h_state, // States of Horizontal FSM\n    output logic [7:0] v_state  // States of Vertical FSM\n);\n\n    parameter logic [9:0] H_ACTIVE  =  10'd640;\n    parameter logic [9:0] H_FRONT   =  10'd16;\n    parameter logic [9:0] H_PULSE   =  10'd96;\n    parameter logic [9:0] H_BACK    =  10'd48;\n    parameter logic [9:0] V_ACTIVE  =  10'd480;\n    parameter logic [9:0] V_FRONT   =  10'd10;\n    parameter logic [9:0] V_PULSE   =  10'd2;\n    parameter logic [9:0] V_BACK    =  10'd33;\n    parameter logic LOW   = 1'b0;\n    parameter logic HIGH  = 1'b1;\n    parameter logic [7:0] H_ACTIVE_STATE  = 8'd0;\n    parameter logic [7:0] H_FRONT_STATE   = 8'd1;\n    parameter logic [7:0] H_PULSE_STATE   = 8'd2;\n    parameter logic [7:0] H_BACK_STATE    = 8'd3;\n    parameter logic [7:0] V_ACTIVE_STATE  = 8'd0;\n    parameter logic [7:0] V_FRONT_STATE   = 8'd1;\n    parameter logic [7:0] V_PULSE_STATE   = 8'd2;\n    parameter logic [7:0] V_BACK_STATE    = 8'd3;\n\n    \n    logic line_done;\n    logic [9:0] h_counter;\n    logic [9:0] v_counter;\n    \n\n    always_ff @(posedge clock or posedge reset) begin\n        if (reset) begin\n            h_counter   <= 10'd0;\n            v_counter   <= 10'd0;\n            h_state     <= H_ACTIVE_STATE;\n            v_state     <= V_ACTIVE_STATE;\n            line_done   <= LOW;\n        end\n        else begin\n            case (h_state)\n                H_ACTIVE_STATE: begin\n                   h_counter <= (h_counter == (H_ACTIVE - 1)) ? 10'd0 : (h_counter + 10'd1);\n                   hsync     <= HIGH;\n                   line_done <= LOW;\n                   h_state   <= (h_counter == (H_ACTIVE - 1)) ? H_FRONT_STATE : H_ACTIVE_STATE;\n                end\n                H_FRONT_STATE: begin\n                   h_counter <= (h_counter == (H_FRONT - 1)) ? 10'd0 : (h_counter + 10'd1);\n                   hsync     <= HIGH;\n                   h_state   <= (h_counter == (H_FRONT - 1)) ? H_PULSE_STATE : H_FRONT_STATE;\n                end\n                H_PULSE_STATE: begin\n                  h_counter <= (h_counter == (H_PULSE - 1)) ? 10'd0 : (h_counter + 10'd1);\n                  hsync     <= LOW;\n                  h_state   <= (h_counter == (H_PULSE - 1)) ? H_BACK_STATE : H_PULSE_STATE;\n                end\n                H_BACK_STATE: begin\n                  h_counter <= (h_counter == (H_BACK - 1)) ? 10'd0 : (h_counter + 10'd1);\n                  hsync     <= HIGH;\n                  h_state   <= (h_counter == (H_BACK - 1)) ? H_ACTIVE_STATE : H_BACK_STATE;\n                  line_done <= (h_counter == (H_BACK - 1)) ? HIGH: LOW;\n                end\n            endcase\n            \n            case (v_state)\n                V_ACTIVE_STATE: begin\n                    if (line_done == HIGH) begin\n                        v_counter <= (v_counter == V_ACTIVE - 1) ? 10'd0 : (v_counter + 10'd1);\n                        v_state   <= (v_counter == V_ACTIVE - 1) ? V_FRONT_STATE : V_ACTIVE_STATE;\n                    end\n                    vsync  <= HIGH;\n                end\n                V_FRONT_STATE: begin\n                    if (line_done == HIGH) begin\n                        v_counter <= (v_counter == V_FRONT - 1) ? 10'd0 : (v_counter + 10'd1);\n                        v_state   <= (v_counter == V_FRONT - 1) ? V_PULSE_STATE : V_FRONT_STATE;\n                    end\n                    vsync  <= HIGH;\n                end\n                V_PULSE_STATE: begin\n                    if (line_done == HIGH) begin\n                        v_counter <= (v_counter == V_PULSE - 1) ? 10'd0 : (v_counter + 10'd1);\n                        v_state   <= (v_counter == V_PULSE - 1) ? V_BACK_STATE : V_PULSE_STATE;\n                    end\n                    vsync  <= LOW;\n                end\n                V_BACK_STATE: begin\n                    if (line_done == HIGH) begin\n                        v_counter <= (v_counter == V_BACK - 1) ? 10'd0 : (v_counter + 10'd1);\n                        v_state   <= (v_counter == V_BACK - 1) ? V_ACTIVE_STATE : V_BACK_STATE;\n                    end\n                    vsync  <= HIGH;\n                end\n            endcase\n            if (h_state == H_ACTIVE_STATE && v_state == V_ACTIVE_STATE) begin\n                red       <= {color_in[7:5], 5'd0};\n                green     <= {color_in[4:2], 5'd0};\n                blue      <= {color_in[1:0], 6'd0};\n            end\n            else begin\n                red       <= 8'd0;\n                green     <= 8'd0;\n                blue      <= 8'd0;\n            end\n        end\n    end\n    \n     \n    assign clk = clock;\n    assign sync = 1'b0;\n    assign blank = hsync & vsync;\n\n    assign next_x = (h_state == H_ACTIVE_STATE) ? h_counter : 10'd0;\n    assign next_y = (v_state == V_ACTIVE_STATE) ? v_counter : 10'd0;\n\nendmodule"}, "obj": true}}
{"cvdp_copilot_virtual2physical_tlb_0001": {"input": {}, "output": {"rtl/virtual2physical_tlb.sv": ""}, "obj": true}}
{"cvdp_copilot_wb2ahb_0001": {"input": {}, "output": {"rtl/wishbone_to_ahb_bridge.sv": ""}, "obj": true}}
{"cvdp_copilot_word_change_detector_0001": {"input": {}, "output": {"rtl/Word_Change_Pulse.sv": ""}, "obj": true}}
{"cvdp_copilot_word_reducer_0001": {"input": {}, "output": {"rtl/Data_Reduction.sv": ""}, "obj": true}}
{"cvdp_copilot_word_reducer_0008": {"input": {"rtl/Data_Reduction.sv": "module Data_Reduction\n#(\n    parameter [2:0] REDUCTION_OP = 3'b000, // Default operation: AND\n    parameter DATA_WIDTH         = 4,      // Width of each data element\n    parameter DATA_COUNT         = 4,      // Number of data elements\n    localparam TOTAL_INPUT_WIDTH = DATA_WIDTH * DATA_COUNT\n)\n(\n    input  wire [TOTAL_INPUT_WIDTH-1:0] data_in,\n    output reg  [DATA_WIDTH-1:0]        reduced_data_out\n);\n\n    generate\n        genvar bit_index;\n\n        // Iterate over each bit position within a single data word\n        for (bit_index = 0; bit_index < DATA_WIDTH; bit_index = bit_index + 1) begin : bit_processing\n            wire [DATA_COUNT-1:0] extracted_bits;\n\n            // Extract bit at `bit_index` from each data word\n            genvar data_index;\n            for (data_index = 0; data_index < DATA_COUNT; data_index = data_index + 1) begin : bit_extraction\n                assign extracted_bits[data_index] = data_in[(data_index * DATA_WIDTH) + bit_index];\n            end\n\n            // Perform reduction on the extracted bits\n            Bitwise_Reduction\n            #(\n                .REDUCTION_OP (REDUCTION_OP),\n                .BIT_COUNT    (DATA_COUNT)\n            )\n            reducer_instance\n            (\n                .input_bits  (extracted_bits),\n                .reduced_bit (reduced_data_out[bit_index])\n            );\n        end\n    endgenerate\n\nendmodule\n\n\nmodule Bitwise_Reduction\n#(\n    parameter [2:0] REDUCTION_OP = 3'b000, // Default operation: AND\n    parameter BIT_COUNT          = 4       // Number of bits to reduce\n)\n(\n    input  wire [BIT_COUNT-1:0] input_bits,\n    output reg                  reduced_bit\n);\n\n    // Reduction Operation Codes\n    localparam [2:0] AND_OP  = 3'b000;\n    localparam [2:0] OR_OP   = 3'b001;\n    localparam [2:0] XOR_OP  = 3'b010;\n    localparam [2:0] NAND_OP = 3'b011;\n    localparam [2:0] NOR_OP  = 3'b100;\n    localparam [2:0] XNOR_OP = 3'b101;\n\n    integer i;\n    reg temp_result; // Intermediate result\n\n    always @(*) begin\n        // Initialize result with the first bit\n        temp_result = input_bits[0];\n\n        // Reduce bits using the selected operation\n        for (i = 1; i < BIT_COUNT; i = i + 1) begin\n            case (REDUCTION_OP)\n                AND_OP, NAND_OP  : temp_result = temp_result & input_bits[i];\n                OR_OP,  NOR_OP   : temp_result = temp_result | input_bits[i];\n                XOR_OP, XNOR_OP  : temp_result = temp_result ^ input_bits[i];\n                default          : temp_result = temp_result & input_bits[i];\n            endcase\n        end\n\n        // Apply final inversion if required\n        case (REDUCTION_OP)\n            NAND_OP : reduced_bit = ~temp_result;\n            NOR_OP  : reduced_bit = ~temp_result;\n            XNOR_OP : reduced_bit = ~temp_result;\n            default : reduced_bit = temp_result;\n        endcase\n    end\nendmodule"}, "output": {"rtl/Data_Reduction.sv": ""}, "obj": true}}
{"cvdp_copilot_write_buffer_merge_0001": {"input": {}, "output": {"rtl/write_buffer_merge.sv": ""}, "obj": true}}
{"cvdp_copilot_write_through_data_direct_mapped_cache_0012": {"input": {"rtl/ddm_cache.sv": "module ddm_cache (\n  input  logic        clk,           // Posedge clock\n  input  logic        rst_n,         // Asynchronous Negedge reset\n  input  logic [31:0] cpu_addr,      // Memory address emitted by the CPU\n  input  logic [31:0] cpu_dout,      // Data emitted by CPU\n  input  logic        cpu_strobe,    // CPU status signal to Cache to indicate it is going to perform a read or write operation\n  input  logic        cpu_rw,        // cpu_rw == 1, Memory Write Operation ; cpu_rw == 0 , Memory Read Operation\n  input  logic        uncached,      // uncached == 1 , IO port is accessed ; uncached == 0, Memory is accessed\n  input  logic [31:0] mem_dout,      // Data emitted by memory\n  input  logic        mem_ready,     // Memory is ready with the read data\n  output logic [31:0] cpu_din,       // CPU Data coming from Memory through Cache\n  output logic [31:0] mem_din,       // Memory Data coming from CPU through Cache\n  output logic        cpu_ready,     // Cache is ready with data to be provided to CPU\n  output logic        mem_strobe,    // Cache Status signal to Memory to indicate it is going to perform a read or write operation\n  output logic        mem_rw,        // mem_rw == 1, Memory Write Operation ; mem_rw == 0 , Memory Read Operation\n  output logic [31:0] mem_addr,      // Memory address to be accessed, emitted by the Cache\n  output logic        cache_hit,     // Indicates a memory location is available in the cache\n  output logic        cache_miss,    // Indicates a memory location is not available in the cache\n  output logic [31:0] d_data_dout     // Data at a cache index\n);\n\n  logic         d_valid [0:63];\n  logic [23:0]  d_tags  [0:63];\n  logic [31:0]  d_data  [0:63];\n  \n  logic [23:0] tag;\n  logic [5:0]  index;\n  \n  logic [31:0] cache_din;   \n  logic        cache_write; \n  logic [23:0] d_tag_out;\n  logic        valid;\n  logic [31:0] cache_dout;\n  \n  integer i;\n  \n  assign tag   = cpu_addr[31:8];\n  assign index = cpu_addr[7:2]; \n  assign cache_write = ~uncached & (cpu_rw | cache_miss & mem_ready); \n\n  always_ff @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n          for (i = 0; i < 64; i = i + 1) begin\n              d_valid[i] <= 0;\n          end\n      end else if (cache_write) begin\n          d_valid[index] = 1;  \n      end\n  end\n    \n  assign cache_din = cpu_rw ? cpu_dout : mem_dout;\n  always_ff@(posedge clk) begin\n       if(cache_write) begin\n            d_tags [index] <= tag;\n            d_data [index] = cache_din;\n       end else begin\n             d_tags [index] <= d_tags[index] + 32'd0;\n             d_data [index] = d_data[index]  + 32'd0;\n       end\n  end  \n  \n  assign valid          = d_valid[index];\n  assign d_tag_out      = d_tags [index];\n  assign cache_dout     = d_data [index];\n  \n  assign cache_hit      = cpu_strobe & valid & (d_tag_out == tag);\n  assign cache_miss     = cpu_strobe & (!valid | (d_tag_out != tag)); \n  assign mem_din        = cpu_dout;\n  assign mem_addr       = cpu_addr;\n  assign mem_rw         = cpu_rw;\n  assign mem_strobe     = cpu_strobe | cache_miss;\n  assign cpu_ready      = ~cpu_rw & cache_hit | (cache_miss | cpu_rw) & mem_ready; \n  assign cpu_din        = cache_hit ? cache_dout : mem_dout;\n  assign d_data_dout    = cache_dout;\nendmodule"}, "output": {"rtl/ddm_cache.sv": ""}, "obj": true}}
