import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge
import random

async def is_maximal_length_sequence(dut, cycles):
    """
    Check whether the sequence generated by the DUT is a maximal-length sequence.
    A maximal-length sequence for a 16-bit CA visits all 2^16 - 1 = 65535 unique states before repeating.
    """
    visited_states = set()

    for i in range(cycles):
        await RisingEdge(dut.clock)
        current_value = int(dut.CA_out.value)

        # Track visited states
        visited_states.add(current_value)

    # A maximal-length sequence for a 16-bit CA should have 65535 unique states
    expected_length = 2**16 - 1
    if len(visited_states) == expected_length:
        dut._log.info(f"Maximal-length sequence achieved with {len(visited_states)} unique states.")
        return True
    else:
        dut._log.warning(f"Sequence is not maximal-length. Only {len(visited_states)} unique states visited.")
        return False


@cocotb.test()
async def display_CA_out_and_check_sequence(dut):
    """
    Display the value of CA_out at each clock cycle, count repeated values, 
    and check whether the sequence is maximal-length.
    """
    # Start the clock
    cocotb.start_soon(Clock(dut.clock, 10, units="ns").start())

    # Initialize the DUT
    seed = 0b0001000100100011  # Non-zero seed
    dut.reset.value = 1
    dut.CA_seed.value = seed
    await RisingEdge(dut.clock)  # Apply reset
    dut.reset.value = 0
    await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset
    dut._log.info(f"Initialized with seed: {seed:#06x}")

    # Dictionary to track the count of each value
    value_count = {}

    # Number of cycles to run
    cycles = 65536  # Set to 2^16 for maximal-length sequence check

    for i in range(cycles):
        await RisingEdge(dut.clock)
        current_value = int(dut.CA_out.value)

        # Update the count for the current value
        if current_value in value_count:
            value_count[current_value] += 1
        else:
            value_count[current_value] = 1

        # Display the value and the current count for it
        dut._log.info(f"Cycle {i+1}: CA_out = {current_value:#06x}, Count = {value_count[current_value]}")

    # Log the values that were repeated
    repeated_values = {val: count for val, count in value_count.items() if count > 1}
    if repeated_values:
        dut._log.warning("Repeated values detected:")
        for val, count in repeated_values.items():
            dut._log.warning(f"Value {val:#06x} repeated {count} times.")
    else:
        dut._log.info("No repeated values detected.")

    # Check if the sequence is maximal-length
    maximal_length = await is_maximal_length_sequence(dut, cycles)
    if maximal_length:
        dut._log.info("The sequence generated by the DUT is maximal-length.")
    else:
        dut._log.warning("The sequence generated by the DUT is not maximal-length.")


@cocotb.test()
async def test_fixed_seed(dut):
    """
    Test the DUT with a fixed seed value.
    """
    # Start the clock
    cocotb.start_soon(Clock(dut.clock, 10, units="ns").start())

    # Use a fixed seed
    seed = 0x1234  # Example fixed seed
    dut.reset.value = 1
    dut.CA_seed.value = seed
    await RisingEdge(dut.clock)  # Apply reset
    dut.reset.value = 0
    await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset
    dut._log.info(f"Initialized with fixed seed: {seed:#06x}")

    # Observe behavior for 20 cycles
    for i in range(20):
        await RisingEdge(dut.clock)
        dut._log.info(f"Cycle {i + 1}: CA_out = {int(dut.CA_out.value):#06x}")


@cocotb.test()
async def test_incremental_seeds(dut):
    """
    Test the DUT with incremental seed values.
    """
    # Start the clock
    cocotb.start_soon(Clock(dut.clock, 10, units="ns").start())

    # Test for seeds from 0x0001 to 0x0010
    for seed in range(0x0001, 0x0011):
        dut.reset.value = 1
        dut.CA_seed.value = seed
        await RisingEdge(dut.clock)  # Apply reset
        dut.reset.value = 0
        await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset
        dut._log.info(f"Initialized with incremental seed: {seed:#06x}")

        # Observe behavior for 10 cycles
        for i in range(10):
            await RisingEdge(dut.clock)
            dut._log.info(f"Cycle {i + 1}: CA_out = {int(dut.CA_out.value):#06x}")


@cocotb.test()
async def test_all_zeros_seed(dut):
    """
    Test the DUT with an all-zeros seed.
    """
    # Start the clock
    cocotb.start_soon(Clock(dut.clock, 10, units="ns").start())

    # All-zeros seed
    seed = 0x0000
    dut.reset.value = 1
    dut.CA_seed.value = seed
    await RisingEdge(dut.clock)  # Apply reset
    dut.reset.value = 0
    await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset
    dut._log.info(f"Initialized with all-zeros seed: {seed:#06x}")

    # Observe behavior for 20 cycles
    for i in range(20):
        await RisingEdge(dut.clock)
        dut._log.info(f"Cycle {i + 1}: CA_out = {int(dut.CA_out.value):#06x}")


@cocotb.test()
async def test_random_seeds(dut):
    """
    Test the DUT with random seed values.
    """
    # Start the clock
    cocotb.start_soon(Clock(dut.clock, 10, units="ns").start())

    # Test for 5 random seeds
    for _ in range(5):
        seed = random.randint(1, 0xFFFF)  # Non-zero random seed
        dut.reset.value = 1
        dut.CA_seed.value = seed
        await RisingEdge(dut.clock)  # Apply reset
        dut.reset.value = 0
        await RisingEdge(dut.clock)  # Allow one clock cycle after deasserting reset
        dut._log.info(f"Initialized with random seed: {seed:#06x}")

        # Observe behavior for 10 cycles
        for i in range(10):
            await RisingEdge(dut.clock)
            dut._log.info(f"Cycle {i + 1}: CA_out = {int(dut.CA_out.value):#06x}")

